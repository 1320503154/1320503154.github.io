<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HEXO示例文件</title>
    <url>/post/4a17b156.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>OrangePiShell学习</title>
    <url>/post/95f630e6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>别人写的shell脚本,做一个保存<br>在香橙派zero3上运行,用于快速部署一个省电无感的小透明轻服务器<br>使用方法<br>通过ssh 连接到zero3,举例<br>ssh <a href="mailto:&#111;&#114;&#97;&#110;&#103;&#x65;&#x70;&#105;&#64;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x36;&#54;&#46;&#49;&#x30;&#54;">&#111;&#114;&#97;&#110;&#103;&#x65;&#x70;&#105;&#64;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x36;&#54;&#46;&#49;&#x30;&#54;</a></p>
<p>默认用户名:orangepi<br>默认密码:orangepi<br>GitHub License</p>
<p>wget -O pi.sh <a href="https://mirror.ghproxy.com/https://raw.githubusercontent.com/wukongdaily/OrangePiShell/master/zero3/pi.sh">https://mirror.ghproxy.com/https://raw.githubusercontent.com/wukongdaily/OrangePiShell/master/zero3/pi.sh</a> &amp;&amp; chmod +x pi.sh<br>.&#x2F;pi.sh proxy</p>
<p>网盘<br>docker 离线包：<a href="https://wwl.lanzouq.com/s/zero3">https://wwl.lanzouq.com/s/zero3</a> 密码:3c60<br>免费内网穿透工具:<a href="https://i.cpolar.com/m/5Ij6">https://i.cpolar.com/m/5Ij6</a><br>docker全部离线包：<a href="https://drive.google.com/drive/folders/1lN14zlHeLu0zckHNftpW8kPlqGZHolL8?usp=sharing">https://drive.google.com/drive/folders/1lN14zlHeLu0zckHNftpW8kPlqGZHolL8?usp=sharing</a><br>zero3开发版 Ubuntu Server(需要解压后再写入TF卡):<a href="https://pan.baidu.com/s/1EKlmccM6STFDb_01rv-qQQ?pwd=2gc7">https://pan.baidu.com/s/1EKlmccM6STFDb_01rv-qQQ?pwd=2gc7</a><br>TF卡写盘工具：<a href="https://etcher.balena.io/">https://etcher.balena.io/</a><br>教学视频：<a href="https://www.bilibili.com/video/BV1ND421T7nB/">https://www.bilibili.com/video/BV1ND421T7nB/</a><br>教学视频2:<a href="https://youtu.be/Ym4d7uCo9eg">https://youtu.be/Ym4d7uCo9eg</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义颜色输出函数</span></span><br><span class="line">red() &#123; echo -e &quot;\033[31m\033[01m[WARNING] $1\033[0m&quot;; &#125;</span><br><span class="line">green() &#123; echo -e &quot;\033[32m\033[01m[INFO] $1\033[0m&quot;; &#125;</span><br><span class="line">greenline() &#123; echo -e &quot;\033[32m\033[01m $1\033[0m&quot;; &#125;</span><br><span class="line">yellow() &#123; echo -e &quot;\033[33m\033[01m[NOTICE] $1\033[0m&quot;; &#125;</span><br><span class="line">blue() &#123; echo -e &quot;\033[34m\033[01m[MESSAGE] $1\033[0m&quot;; &#125;</span><br><span class="line">light_magenta() &#123; echo -e &quot;\033[95m\033[01m[NOTICE] $1\033[0m&quot;; &#125;</span><br><span class="line">highlight() &#123; echo -e &quot;\033[32m\033[01m$1\033[0m&quot;; &#125;</span><br><span class="line">cyan() &#123; echo -e &quot;\033[38;2;0;255;255m$1\033[0m&quot;; &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否以 root 用户身份运行</span></span><br><span class="line">if [ &quot;$(id -u)&quot; -ne 0 ]; then</span><br><span class="line">    echo &quot;此脚本需要以 root 用户权限运行，请输入当前用户的密码：&quot;</span><br><span class="line">    green &quot;注意！输入密码过程不显示*号属于正常现象&quot;</span><br><span class="line">    sudo &quot;$0&quot; &quot;$@&quot; # 重新以 root 权限运行此脚本</span><br><span class="line">    exit $?</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">proxy=&quot;&quot;</span><br><span class="line">if [ $# -gt 0 ]; then</span><br><span class="line">    proxy=&quot;https://mirror.ghproxy.com/&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">declare -a menu_options</span><br><span class="line">declare -A commands</span><br><span class="line">menu_options=(</span><br><span class="line">    &quot;更新系统软件包&quot;</span><br><span class="line">    &quot;安装并启动文件管理器FileBrowser&quot;</span><br><span class="line">    &quot;启动文件管理器FileBrowser&quot;</span><br><span class="line">    &quot;安装1panel面板管理工具&quot;</span><br><span class="line">    &quot;查看1panel用户信息&quot;</span><br><span class="line">    &quot;安装小雅和小雅keeper&quot;</span><br><span class="line">    &quot;修改阿里云盘Token(32位)&quot;</span><br><span class="line">    &quot;修改阿里云盘OpenToken(335位)&quot;</span><br><span class="line">    &quot;修改小雅转存文件夹ID(40位)&quot;</span><br><span class="line">    &quot;安装内网穿透工具Cpolar&quot;</span><br><span class="line">    &quot;安装盒子助手docker版&quot;</span><br><span class="line">    &quot;安装CasaOS面板&quot;</span><br><span class="line">    &quot;更新脚本&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">commands=(</span><br><span class="line">    [&quot;更新系统软件包&quot;]=&quot;update_system_packages&quot;</span><br><span class="line">    [&quot;安装并启动文件管理器FileBrowser&quot;]=&quot;install_filemanager&quot;</span><br><span class="line">    [&quot;启动文件管理器FileBrowser&quot;]=&quot;start_filemanager&quot;</span><br><span class="line">    [&quot;安装1panel面板管理工具&quot;]=&quot;install_1panel_on_linux&quot;</span><br><span class="line">    [&quot;查看1panel用户信息&quot;]=&quot;read_user_info&quot;</span><br><span class="line">    [&quot;安装小雅和小雅keeper&quot;]=&quot;install_xiaoya_alist&quot;</span><br><span class="line">    [&quot;修改阿里云盘Token(32位)&quot;]=&quot;update_aliyunpan_token&quot;</span><br><span class="line">    [&quot;修改阿里云盘OpenToken(335位)&quot;]=&quot;update_aliyunpan_opentoken&quot;</span><br><span class="line">    [&quot;修改小雅转存文件夹ID(40位)&quot;]=&quot;update_aliyunpan_folder_id&quot;</span><br><span class="line">    [&quot;安装内网穿透工具Cpolar&quot;]=&quot;install_cpolar&quot;</span><br><span class="line">    [&quot;安装盒子助手docker版&quot;]=&quot;install_wukongdaily_box&quot;</span><br><span class="line">    [&quot;安装CasaOS面板&quot;]=&quot;install_casaos&quot;</span><br><span class="line">    [&quot;更新脚本&quot;]=&quot;update_scripts&quot;</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新系统软件包</span></span><br><span class="line">update_system_packages() &#123;</span><br><span class="line">    green &quot;Setting timezone Asia/Shanghai...&quot;</span><br><span class="line">    sudo timedatectl set-timezone Asia/Shanghai</span><br><span class="line">    # 更新系统软件包</span><br><span class="line">    green &quot;Updating system packages...&quot;</span><br><span class="line">    sudo apt update</span><br><span class="line">    sudo DEBIAN_FRONTEND=noninteractive apt-get upgrade -y</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装文件管理器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">源自 https://filebrowser.org/installation</span></span><br><span class="line">install_filemanager()</span><br><span class="line">&#123;</span><br><span class="line">	trap &#x27;echo -e &quot;Aborted, error $? in command: $BASH_COMMAND&quot;; trap ERR; return 1&#x27; ERR</span><br><span class="line">	filemanager_os=&quot;unsupported&quot;</span><br><span class="line">	filemanager_arch=&quot;unknown&quot;</span><br><span class="line">	install_path=&quot;/usr/local/bin&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Termux on Android has <span class="variable">$PREFIX</span> <span class="built_in">set</span> <span class="built_in">which</span> already ends with /usr</span></span><br><span class="line">	if [[ -n &quot;$ANDROID_ROOT&quot; &amp;&amp; -n &quot;$PREFIX&quot; ]]; then</span><br><span class="line">		install_path=&quot;$PREFIX/bin&quot;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Fall back to /usr/bin <span class="keyword">if</span> necessary</span></span><br><span class="line">	if [[ ! -d $install_path ]]; then</span><br><span class="line">		install_path=&quot;/usr/bin&quot;</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Not every platform has or needs sudo (https://termux.com/linux.html)</span></span><br><span class="line">	((EUID)) &amp;&amp; [[ -z &quot;$ANDROID_ROOT&quot; ]] &amp;&amp; sudo_cmd=&quot;sudo&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="comment">########################</span></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Which OS and version? <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="comment">########################</span></span></span><br><span class="line"></span><br><span class="line">	filemanager_bin=&quot;filebrowser&quot;</span><br><span class="line">	filemanager_dl_ext=&quot;.tar.gz&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">NOTE: `<span class="built_in">uname</span> -m` is more accurate and universal than `<span class="built_in">arch</span>`</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">See https://en.wikipedia.org/wiki/Uname</span></span><br><span class="line">	unamem=&quot;$(uname -m)&quot;</span><br><span class="line">	case $unamem in</span><br><span class="line">	*aarch64*)</span><br><span class="line">		filemanager_arch=&quot;arm64&quot;;;</span><br><span class="line">	*64*)</span><br><span class="line">		filemanager_arch=&quot;amd64&quot;;;</span><br><span class="line">	*86*)</span><br><span class="line">		filemanager_arch=&quot;386&quot;;;</span><br><span class="line">	*armv5*)</span><br><span class="line">		filemanager_arch=&quot;armv5&quot;;;</span><br><span class="line">	*armv6*)</span><br><span class="line">		filemanager_arch=&quot;armv6&quot;;;</span><br><span class="line">	*armv7*)</span><br><span class="line">		filemanager_arch=&quot;armv7&quot;;;</span><br><span class="line">	*)</span><br><span class="line">		green &quot;Aborted, unsupported or unknown architecture: $unamem&quot;</span><br><span class="line">		return 2</span><br><span class="line">		;;</span><br><span class="line">	esac</span><br><span class="line"></span><br><span class="line">	unameu=&quot;$(tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27; &lt;&lt;&lt;$(uname))&quot;</span><br><span class="line">	if [[ $unameu == *DARWIN* ]]; then</span><br><span class="line">		filemanager_os=&quot;darwin&quot;</span><br><span class="line">	elif [[ $unameu == *LINUX* ]]; then</span><br><span class="line">		filemanager_os=&quot;linux&quot;</span><br><span class="line">	elif [[ $unameu == *FREEBSD* ]]; then</span><br><span class="line">		filemanager_os=&quot;freebsd&quot;</span><br><span class="line">	elif [[ $unameu == *NETBSD* ]]; then</span><br><span class="line">		filemanager_os=&quot;netbsd&quot;</span><br><span class="line">	elif [[ $unameu == *OPENBSD* ]]; then</span><br><span class="line">		filemanager_os=&quot;openbsd&quot;</span><br><span class="line">	elif [[ $unameu == *WIN* || $unameu == MSYS* ]]; then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">Should catch cygwin</span></span><br><span class="line">		sudo_cmd=&quot;&quot;</span><br><span class="line">		filemanager_os=&quot;windows&quot;</span><br><span class="line">		filemanager_bin=&quot;filebrowser.exe&quot;</span><br><span class="line">		filemanager_dl_ext=&quot;.zip&quot;</span><br><span class="line">	else</span><br><span class="line">		green &quot;Aborted, unsupported or unknown OS: $uname&quot;</span><br><span class="line">		return 6</span><br><span class="line">	fi</span><br><span class="line">	green &quot;Downloading File Browser for $filemanager_os/$filemanager_arch...&quot;</span><br><span class="line">	if type -p curl &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">		net_getter=&quot;curl -fsSL&quot;</span><br><span class="line">	elif type -p wget &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">		net_getter=&quot;wget -qO-&quot;</span><br><span class="line">	else</span><br><span class="line">		green &quot;Aborted, could not find curl or wget&quot;</span><br><span class="line">		return 7</span><br><span class="line">	fi</span><br><span class="line">	filemanager_file=&quot;$&#123;filemanager_os&#125;-$filemanager_arch-filebrowser$filemanager_dl_ext&quot;</span><br><span class="line">    filemanager_url=&quot;$&#123;proxy&#125;https://github.com/filebrowser/filebrowser/releases/download/v2.28.0/$filemanager_file&quot;</span><br><span class="line">	echo &quot;$filemanager_url&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Use <span class="variable">$PREFIX</span> <span class="keyword">for</span> compatibility with Termux on Android</span></span><br><span class="line">	rm -rf &quot;$PREFIX/tmp/$filemanager_file&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">&#123;net_getter&#125; <span class="string">&quot;<span class="variable">$filemanager_url</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$PREFIX</span>/tmp/<span class="variable">$filemanager_file</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line">	green &quot;Extracting...&quot;</span><br><span class="line">	case &quot;$filemanager_file&quot; in</span><br><span class="line">		*.zip)    unzip -o &quot;$PREFIX/tmp/$filemanager_file&quot; &quot;$filemanager_bin&quot; -d &quot;$PREFIX/tmp/&quot; ;;</span><br><span class="line">		*.tar.gz) tar -xzf &quot;$PREFIX/tmp/$filemanager_file&quot; -C &quot;$PREFIX/tmp/&quot; &quot;$filemanager_bin&quot; ;;</span><br><span class="line">	esac</span><br><span class="line">	chmod +x &quot;$PREFIX/tmp/$filemanager_bin&quot;</span><br><span class="line"></span><br><span class="line">	green &quot;Putting filemanager in $install_path (may require password)&quot;</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">sudo_cmd <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$PREFIX</span>/tmp/<span class="variable">$filemanager_bin</span>&quot;</span> <span class="string">&quot;<span class="variable">$install_path</span>/<span class="variable">$filemanager_bin</span>&quot;</span></span></span><br><span class="line">	if setcap_cmd=$(PATH+=$PATH:/sbin type -p setcap); then</span><br><span class="line"><span class="meta prompt_">		$</span><span class="language-bash">sudo_cmd <span class="variable">$setcap_cmd</span> cap_net_bind_service=+ep <span class="string">&quot;<span class="variable">$install_path</span>/<span class="variable">$filemanager_bin</span>&quot;</span></span></span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">sudo_cmd <span class="built_in">rm</span> -- <span class="string">&quot;<span class="variable">$PREFIX</span>/tmp/<span class="variable">$filemanager_file</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line">	if type -p $filemanager_bin &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">		green &quot;Successfully installed&quot;</span><br><span class="line">		trap ERR</span><br><span class="line">		return 0</span><br><span class="line">	else</span><br><span class="line">		red &quot;Something went wrong, File Browser is not in your path&quot;</span><br><span class="line">		trap ERR</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动文件管理器</span></span><br><span class="line">start_filemanager() &#123;</span><br><span class="line">    # 检查是否已经安装 filebrowser</span><br><span class="line">    if ! command -v filebrowser &amp;&gt;/dev/null; then</span><br><span class="line">        red &quot;Error: filebrowser 未安装，请先安装 filebrowser&quot;</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 启动 filebrowser 文件管理器</span><br><span class="line">    echo &quot;启动 filebrowser 文件管理器...&quot;</span><br><span class="line"></span><br><span class="line">    # 使用 nohup 和输出重定向，记录启动日志到 filebrowser.log 文件中</span><br><span class="line">    nohup sudo filebrowser -r / --address 0.0.0.0 --port 8080 &gt;filebrowser.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">    # 检查 filebrowser 是否成功启动</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">        red &quot;Error: 启动 filebrowser 文件管理器失败&quot;</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">    local host_ip</span><br><span class="line">    host_ip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">    echo &quot;filebrowser 文件管理器已启动，可以通过 http://$&#123;host_ip&#125;:8080 访问&quot;</span><br><span class="line">    echo &quot;登录用户名：admin&quot;</span><br><span class="line">    echo &quot;默认密码：admin（请尽快修改密码）&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装1panel面板</span></span><br><span class="line">install_1panel_on_linux() &#123;</span><br><span class="line">    curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh &amp;&amp; sudo bash quick_start.sh</span><br><span class="line">    intro=&quot;https://1panel.cn/docs/installation/cli/&quot;</span><br><span class="line">    if command -v 1pctl &amp;&gt;/dev/null; then</span><br><span class="line">        green &quot;如何卸载1panel 请参考：$intro&quot;</span><br><span class="line">    else</span><br><span class="line">        red &quot;未安装1panel&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看1panel用户信息</span></span><br><span class="line">read_user_info()&#123;</span><br><span class="line">    sudo 1pctl user-info</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装小雅和小雅keeper</span></span><br><span class="line">install_xiaoya_alist() &#123;</span><br><span class="line">    local host_ip</span><br><span class="line">    host_ip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">    if ! docker ps | grep -q &quot;xhofe/alist&quot;; then</span><br><span class="line">        red &quot;检测到没有安装小雅必备依赖 AList&quot;</span><br><span class="line">        green &quot;正在安装alist 请稍后&quot;</span><br><span class="line">        docker run -d --restart=unless-stopped -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=&quot;alist&quot; xhofe/alist:latest</span><br><span class="line">        sleep 3</span><br><span class="line">        docker exec -it alist ./alist admin set admin</span><br><span class="line">        echo &#x27;</span><br><span class="line">    AList已安装,现在你可以安装小雅了</span><br><span class="line">    用户: admin </span><br><span class="line">    密码: admin</span><br><span class="line">    &#x27;</span><br><span class="line">        green 浏览器访问:http://$&#123;host_ip&#125;:5244</span><br><span class="line">    else</span><br><span class="line"></span><br><span class="line">        rm -rf /etc/xiaoya/mytoken.txt &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">        rm -rf /etc/xiaoya/myopentoken.txt &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">        rm -rf /etc/xiaoya/temp_transfer_folder_id.txt &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">        cyan &#x27;</span><br><span class="line">        根据如下三个网址的提示完成token的填写</span><br><span class="line">        阿里云盘Token(32位):        https://alist.nn.ci/zh/guide/drivers/aliyundrive.html</span><br><span class="line">        阿里云盘OpenToken(335位):   https://alist.nn.ci/tool/aliyundrive/request.html</span><br><span class="line">        阿里云盘转存目录folder id:   https://www.aliyundrive.com/s/rP9gP3h9asE</span><br><span class="line">        &#x27;</span><br><span class="line">        </span><br><span class="line">        # 调用修改后的脚本</span><br><span class="line">        remove_docker_rmi &quot;http://docker.xiaoya.pro/update_new.sh&quot;</span><br><span class="line">        # 检查xiaoyaliu/alist 是否运行，如果运行了 则提示下面的信息，否则退出</span><br><span class="line">        if ! docker ps | grep -q &quot;xiaoyaliu/alist&quot;; then</span><br><span class="line">            echo &quot;Error: xiaoyaliu/alist Docker 容器未运行&quot;</span><br><span class="line">            return 1</span><br><span class="line">        fi</span><br><span class="line">        green &quot;正在安装小雅转存清理工具...&quot;</span><br><span class="line">        bash -c &quot;$(curl -sLk https://xiaoyahelper.ddsrem.com/aliyun_clear.sh | tail -n +2)&quot; -s 5</span><br><span class="line">        echo &#x27;</span><br><span class="line">    小雅docker已启动</span><br><span class="line">    webdav 信息如下</span><br><span class="line">    用户: guest </span><br><span class="line">    密码: guest_Api789</span><br><span class="line">    &#x27;</span><br><span class="line">        green 请您耐心等待xiaoya数据库更新完毕,5分钟后再访问</span><br><span class="line">        green 浏览器访问:http://$&#123;host_ip&#125;:5678</span><br><span class="line">        green &quot;已设置实时清理，只要产生了播放缓存一分钟内立即清理转存文件夹里的文件.&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防止小雅重复下载镜像</span></span><br><span class="line">remove_docker_rmi() &#123;</span><br><span class="line">    local script_url=&quot;$1&quot;</span><br><span class="line">    # 下载脚本内容</span><br><span class="line">    local script_content=$(curl -sSL &quot;$script_url&quot;)</span><br><span class="line">    if [[ -z &quot;$script_content&quot; ]]; then</span><br><span class="line">        echo &quot;Failed to download script from: $script_url&quot;</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">    # 移除所有含有 &quot;docker rmi&quot; 的行</span><br><span class="line">    local modified_content=$(echo &quot;$script_content&quot; | sed &#x27;/docker rmi/d&#x27;)</span><br><span class="line">    # 将修改后的内容保存到临时文件</span><br><span class="line">    local modified_script=&quot;/tmp/modified_script.sh&quot;</span><br><span class="line">    echo &quot;$modified_content&quot; &gt; &quot;$modified_script&quot;</span><br><span class="line">    # 使用 bash -c 执行修改后的脚本文件</span><br><span class="line">    bash -c &quot;bash $modified_script&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新阿里云盘Token</span></span><br><span class="line">update_aliyunpan_token()&#123;</span><br><span class="line">    local token_file=&quot;/etc/xiaoya/mytoken.txt&quot;</span><br><span class="line">    cyan &#x27;</span><br><span class="line">        根据如下网址的提示完成token的填写</span><br><span class="line">        阿里云盘Token(32位): https://alist.nn.ci/zh/guide/drivers/aliyundrive.html#%E5%88%B7%E6%96%B0%E4%BB%A4%E7%89%8C</span><br><span class="line">        </span><br><span class="line">        &#x27;</span><br><span class="line">    # 提示用户输入 token</span><br><span class="line">    read -p &quot;请输入一个 阿里云盘token(32位): &quot; token</span><br><span class="line"></span><br><span class="line">    if [[ -z &quot;$token&quot; ]]; then</span><br><span class="line">        echo &quot;输入的 token 为空，无法写入文件。&quot;</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 删除旧的 token 文件（如果存在）</span><br><span class="line">    if [[ -f &quot;$token_file&quot; ]]; then</span><br><span class="line">        sudo rm -rf &quot;$token_file&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 将 token 写入新的文件</span><br><span class="line">    sudo echo &quot;$token&quot; &gt; &quot;$token_file&quot;</span><br><span class="line">    green &quot;成功写入 token 到文件: $token_file&quot;</span><br><span class="line">    cat $token_file</span><br><span class="line">    red &quot;重启小雅docker容器之后 才会生效,请记得在1panel面板手动重启该容器&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新阿里云盘opentoken</span></span><br><span class="line">update_aliyunpan_opentoken()&#123;</span><br><span class="line">  local token_file=&quot;/etc/xiaoya/myopentoken.txt&quot;</span><br><span class="line">    cyan &#x27;</span><br><span class="line">        根据如下网址的提示完成opentoken的填写</span><br><span class="line">        阿里云盘OpenToken(335位): https://alist.nn.ci/tool/aliyundrive/request.html</span><br><span class="line">        &#x27;</span><br><span class="line">    # 提示用户输入 token</span><br><span class="line">    read -p &quot;请输入一个 阿里云盘OpenToken(335位): &quot; token</span><br><span class="line"></span><br><span class="line">    if [[ -z &quot;$token&quot; ]]; then</span><br><span class="line">        echo &quot;输入的 token 为空，无法写入文件。&quot;</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 删除旧的 token 文件（如果存在）</span><br><span class="line">    if [[ -f &quot;$token_file&quot; ]]; then</span><br><span class="line">        sudo rm -rf &quot;$token_file&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 将 token 写入新的文件</span><br><span class="line">    sudo echo &quot;$token&quot; &gt; &quot;$token_file&quot;</span><br><span class="line">    green &quot;成功写入 OpenToken 到文件: $token_file&quot;</span><br><span class="line">    cat $token_file</span><br><span class="line">    red &quot;重启小雅docker容器之后 才会生效,请记得在1panel面板手动重启该容器&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新小雅转存文件夹<span class="built_in">id</span></span></span><br><span class="line">update_aliyunpan_folder_id()&#123;</span><br><span class="line"> local token_file=&quot;/etc/xiaoya/temp_transfer_folder_id.txt&quot;</span><br><span class="line">    cyan &#x27;</span><br><span class="line">        根据如下网址的提示完成小雅转存文件夹ID的填写</span><br><span class="line">        阿里云盘小雅转存文件夹ID(40位): https://www.aliyundrive.com/s/rP9gP3h9asE</span><br><span class="line">        注意,首次使用 应该先转存该目录到自己的资源盘中</span><br><span class="line">        然后在自己的资源盘找到该转存目录的id</span><br><span class="line">        不要填写别人的文件夹id哦</span><br><span class="line">        &#x27;</span><br><span class="line">    # 提示用户输入 token</span><br><span class="line">    read -p &quot;请输入一个 阿里云盘小雅转存文件夹ID(40位): &quot; token</span><br><span class="line"></span><br><span class="line">    if [[ -z &quot;$token&quot; ]]; then</span><br><span class="line">        echo &quot;输入的 id 为空，无法写入文件。&quot;</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 删除旧的 token 文件（如果存在）</span><br><span class="line">    if [[ -f &quot;$token_file&quot; ]]; then</span><br><span class="line">        sudo rm -rf &quot;$token_file&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 将 token 写入新的文件</span><br><span class="line">    sudo echo &quot;$token&quot; &gt; &quot;$token_file&quot;</span><br><span class="line">    green &quot;成功写入 转存文件夹ID 到文件: $token_file&quot;</span><br><span class="line">    cat $token_file</span><br><span class="line">    red &quot;重启小雅docker容器之后 才会生效,请记得在1panel面板手动重启该容器&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装内网穿透</span></span><br><span class="line">install_cpolar() &#123;</span><br><span class="line">    local host_ip</span><br><span class="line">    host_ip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">    curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash</span><br><span class="line">    if command -v cpolar &amp;&gt;/dev/null; then</span><br><span class="line">        # 提示用户输入 token</span><br><span class="line">        green &quot;访问 https://dashboard.cpolar.com/auth  复制您自己的AuthToken&quot;</span><br><span class="line">        read -p &quot;请输入您的 AuthToken: &quot; token</span><br><span class="line">        # 执行 cpolar 命令并传入 token</span><br><span class="line">        cpolar authtoken &quot;$token&quot;</span><br><span class="line">        # 向系统添加服务</span><br><span class="line">        green &quot;正在向系统添加cpolar服务&quot;</span><br><span class="line">        sudo systemctl enable cpolar</span><br><span class="line">        # 启动服务</span><br><span class="line">        green &quot;正在启动cpolar服务&quot;</span><br><span class="line">        sudo systemctl start cpolar</span><br><span class="line">        # 查看状态</span><br><span class="line">        green &quot;cpolar服务状态如下&quot;</span><br><span class="line">        sudo systemctl status cpolar | tee /dev/tty</span><br><span class="line">        green 浏览器访问:http://$&#123;host_ip&#125;:9200/#/tunnels/list  创建隧道</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line">        red &quot;错误：cpolar 命令未找到，请先安装 cpolar。&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装盒子助手docker版</span></span><br><span class="line">install_wukongdaily_box() &#123;</span><br><span class="line">    sudo mkdir -p /mnt/tvhelper_data</span><br><span class="line">    sudo chmod 777 /mnt/tvhelper_data</span><br><span class="line">    docker run -d \</span><br><span class="line">        --restart unless-stopped \</span><br><span class="line">        --name tvhelper \</span><br><span class="line">        -p 2299:22 \</span><br><span class="line">        -p 2288:80 \</span><br><span class="line">        -v &quot;/mnt/tvhelper_data:/tvhelper/shells/data&quot; \</span><br><span class="line">        -e PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/lib/android-sdk/platform-tools \</span><br><span class="line">        wukongdaily/box:latest</span><br><span class="line">    if ! docker ps | grep -q &quot;wukongdaily/box&quot;; then</span><br><span class="line">        echo &quot;Error: 盒子助手docker版 未运行成功&quot;</span><br><span class="line">    else</span><br><span class="line">        local host_ip</span><br><span class="line">        host_ip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">        green &quot;盒子助手docker版已启动，可以通过 http://$&#123;host_ip&#125;:2288 验证是否安装成功&quot;</span><br><span class="line">        green &quot;还可以通过 ssh $&#123;host_ip&#125; -p 2299 连接到容器内 执行 ./tv.sh 使用该工具&quot;</span><br><span class="line">        green &quot;文档和教学视频：https://www.youtube.com/watch?v=xAk-3TxeXxQ \n  https://www.bilibili.com/video/BV1Rm411o78P&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装CasaOS</span></span><br><span class="line">install_casaos()&#123;</span><br><span class="line">    curl -fsSL https://get.casaos.io | sudo bash</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新自己</span></span><br><span class="line">update_scripts()&#123;</span><br><span class="line">    wget -O pi.sh $&#123;proxy&#125;https://raw.githubusercontent.com/wukongdaily/OrangePiShell/master/zero3/pi.sh &amp;&amp; chmod +x pi.sh</span><br><span class="line">	echo &quot;脚本已更新并保存在当前目录 pi.sh,现在将执行新脚本。&quot;</span><br><span class="line">	./pi.sh $&#123;proxy&#125;</span><br><span class="line">	exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show_menu() &#123;</span><br><span class="line">    clear</span><br><span class="line">    greenline &quot;————————————————————————————————————————————————————&quot;</span><br><span class="line">    echo &#x27;</span><br><span class="line">    ***********  DIY docker轻服务器  ***************</span><br><span class="line">    环境:orange pi zero 3 (Ubuntu/debian)</span><br><span class="line">    脚本作用:快速部署一个省电无感的小透明轻服务器</span><br><span class="line">            --- Made by wukong with YOU ---&#x27;</span><br><span class="line">    echo -e &quot;    https://github.com/wukongdaily/OrangePiShell&quot;</span><br><span class="line">    greenline &quot;————————————————————————————————————————————————————&quot;</span><br><span class="line">    echo &quot;请选择操作：&quot;</span><br><span class="line"></span><br><span class="line">    # 特殊处理的项数组</span><br><span class="line">    special_items=(&quot;&quot;)</span><br><span class="line">    for i in &quot;$&#123;!menu_options[@]&#125;&quot;; do</span><br><span class="line">        if [[ &quot; $&#123;special_items[*]&#125; &quot; =~ &quot; $&#123;menu_options[i]&#125; &quot; ]]; then</span><br><span class="line">            # 如果当前项在特殊处理项数组中，使用特殊颜色</span><br><span class="line">            highlight &quot;$((i + 1)). $&#123;menu_options[i]&#125;&quot;</span><br><span class="line">        else</span><br><span class="line">            # 否则，使用普通格式</span><br><span class="line">            echo &quot;$((i + 1)). $&#123;menu_options[i]&#125;&quot;</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle_choice() &#123;</span><br><span class="line">    local choice=$1</span><br><span class="line">    # 检查输入是否为空</span><br><span class="line">    if [[ -z $choice ]]; then</span><br><span class="line">        echo -e &quot;$&#123;RED&#125;输入不能为空，请重新选择。$&#123;NC&#125;&quot;</span><br><span class="line">        return</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 检查输入是否为数字</span><br><span class="line">    if ! [[ $choice =~ ^[0-9]+$ ]]; then</span><br><span class="line">        echo -e &quot;$&#123;RED&#125;请输入有效数字!$&#123;NC&#125;&quot;</span><br><span class="line">        return</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 检查数字是否在有效范围内</span><br><span class="line">    if [[ $choice -lt 1 ]] || [[ $choice -gt $&#123;#menu_options[@]&#125; ]]; then</span><br><span class="line">        echo -e &quot;$&#123;RED&#125;选项超出范围!$&#123;NC&#125;&quot;</span><br><span class="line">        echo -e &quot;$&#123;YELLOW&#125;请输入 1 到 $&#123;#menu_options[@]&#125; 之间的数字。$&#123;NC&#125;&quot;</span><br><span class="line">        return</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 执行命令</span><br><span class="line">    if [ -z &quot;$&#123;commands[$&#123;menu_options[$choice - 1]&#125;]&#125;&quot; ]; then</span><br><span class="line">        echo -e &quot;$&#123;RED&#125;无效选项，请重新选择。$&#123;NC&#125;&quot;</span><br><span class="line">        return</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    &quot;$&#123;commands[$&#123;menu_options[$choice - 1]&#125;]&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while true; do</span><br><span class="line">    show_menu</span><br><span class="line">    read -p &quot;请输入选项的序号(输入q退出): &quot; choice</span><br><span class="line">    if [[ $choice == &#x27;q&#x27; ]]; then</span><br><span class="line">        break</span><br><span class="line">    fi</span><br><span class="line">    handle_choice $choice</span><br><span class="line">    echo &quot;按任意键继续...&quot;</span><br><span class="line">    read -n 1 # 等待用户按键</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>代码随想录刷题日记</title>
    <url>/post/6bcb6b2a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Typora的快捷操作"><a href="#Typora的快捷操作" class="headerlink" title="Typora的快捷操作"></a>Typora的快捷操作</h1><p>记录下Typora的批量上传图片操作:</p>
<p><img src="https://s2.loli.net/2024/05/22/bLJXQFe6cmsCZRn.png" alt="image-20240522130957547"></p>
<h1 id="刷题日记"><a href="#刷题日记" class="headerlink" title="刷题日记"></a>刷题日记</h1><h2 id="特殊日期"><a href="#特殊日期" class="headerlink" title="特殊日期"></a>特殊日期</h2><p><a href="https://www.lanqiao.cn/problems/2408/learning/?page=1&first_category_id=1&second_category_id=3&tags=2023&difficulty=20">1.特殊日期 - 蓝桥云课 (lanqiao.cn)</a></p>
<p>求解每个数位的和：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n)&#123;</span><br><span class="line">    sum+=n%<span class="number">10</span>;</span><br><span class="line">    n/=<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2022</span> = <span class="number">2</span>+<span class="number">0</span>+<span class="number">2</span>+<span class="number">2</span> sum=<span class="number">6</span></span><br><span class="line">每个数位是老考点了.</span><br></pre></td></tr></table></figure>

<p>判断闰年:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span> || year%<span class="number">400</span>==<span class="number">0</span>)&#123;</span><br><span class="line">      day[<span class="number">2</span>]=<span class="number">29</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      day[<span class="number">2</span>]=<span class="number">28</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方便求解日期:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i,j,count,year,month,day[<span class="number">13</span>] = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这里面的:蓝桥杯真题:好数,判断每个奇数位上是奇数,偶数wei是偶数,就需要判断数位.</p>
<p>需要一个数组存储每个数位.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"> <span class="keyword">while</span>(n)&#123;</span><br><span class="line">   a.<span class="built_in">push_back</span>(n%<span class="number">10</span>);</span><br><span class="line">   n/=<span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="只要把每个做过的题目吸收了-就真的nb"><a href="#只要把每个做过的题目吸收了-就真的nb" class="headerlink" title="只要把每个做过的题目吸收了,就真的nb"></a>只要把每个做过的题目吸收了,就真的nb</h2><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="GCD和LCM"><a href="#GCD和LCM" class="headerlink" title="GCD和LCM"></a>GCD和LCM</h2><p><img src="https://s2.loli.net/2024/04/16/jZE2UJTbLX3SKhs.png" alt="image-20240416201114071"></p>
<p>互质判断:</p>
<p><img src="https://s2.loli.net/2024/04/16/qWQKME7nJOtf3hk.png" alt="image-20240416201246443"></p>
<p><img src="https://s2.loli.net/2024/04/16/JKW6M9uSUTbVict.png" alt="image-20240416213756996"></p>
<p>得出:gcd(a,b) &#x3D; gcd(a%b,b);</p>
<p>不断重复这个递归过程,复杂度为log2n</p>
<p>现在的人都是直接追求结果</p>
<p>我也是,直接背下来算了</p>
<p><img src="https://s2.loli.net/2024/04/16/HOgDj4UELBzurXJ.png" alt="image-20240416215013603"></p>
<p><img src="https://s2.loli.net/2024/04/16/uBMZCKeUxEJHy7L.png" alt="image-20240416215527632"></p>
<p>举个例子即可,在质因子中找到指数最小的,然后相乘,得gcd.</p>
<h3 id="宝石组合"><a href="#宝石组合" class="headerlink" title="宝石组合"></a>宝石组合</h3><p><a href="https://dashoj.com/d/lqbproblem/p/199">题目详情 - 宝石组合（编程题） - DashOJ</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">我是傻逼,有个电脑的事情,我非得整个平板\.</span><br></pre></td></tr></table></figure>

<h1 id="快速幂-乘法逆元"><a href="#快速幂-乘法逆元" class="headerlink" title="快速幂;乘法逆元"></a>快速幂;乘法逆元</h1><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>动图讲解单调栈:<a href="https://leetcode.cn/problems/next-greater-element-ii/solutions/1/dong-hua-jiang-jie-dan-diao-zhan-by-fuxu-4z2g/">503. 下一个更大元素 II - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度 - 力扣（LeetCode）</a></p>
<p>直接看视频</p>
<p><a href="https://www.bilibili.com/video/BV15y4y1o7Dw/?p=137&spm_id_from=pageDriver">单调栈，成环了可怎么办？LeetCode：503.下一个更大元素II_哔哩哔哩_bilibili</a></p>
<p>帮你找到这个元素,右边比他大或者小的元素 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> curTemp = temperatures[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() &amp;&amp; curTemp &gt; temperatures[stack.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> prevIndex = stack.<span class="built_in">top</span>();</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">                ans[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接类似于默写模板了其实,嘻嘻</p>
<p>这是力扣的每日温度!</p>
<h2 id="496-下一个最大元素I"><a href="#496-下一个最大元素I" class="headerlink" title="496.下一个最大元素I"></a><a href="https://leetcode.cn/problems/next-greater-element-i/">496.下一个最大元素I</a></h2><p><img src="https://s2.loli.net/2024/04/30/NQPDl7H1gG4ibJp.png" alt="image-20240430184135620"></p>
<p>c++代码解决,</p>
<h2 id="503-下一个更大元素-II-力扣（LeetCode）"><a href="#503-下一个更大元素-II-力扣（LeetCode）" class="headerlink" title="503. 下一个更大元素 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II - 力扣（LeetCode）</a></h2><p>这个主要是数组是循环的:</p>
<p><strong>1.一种实现方式是，把数组复制一份到数组末尾，这样虽然不是严格的循环数组，但是对于本题已经足够了，因为本题对数组最多遍历两次。</strong></p>
<p>如何维护这个循环数组是问题:</p>
<p>只看不干,等于白干,会忘的.</p>
<p>模拟循环数组:</p>
<p>实现那个循环队列相同的思路:<strong>进行取模操作</strong>:<code>int idx = i%nums.size()</code></p>
<p>单调栈模板代码:</p>
<p><img src="https://s2.loli.net/2024/04/30/1sGVkQbPq2J5uT7.png" alt="image-20240430203155940"></p>
<p>解决这个问题的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//数组循环搜索,还是直接写题吧,不纠结语言了.先使用C++.其实差不多的,思想一样,代码的改写交给GPT即可.</span></span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">			stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() * <span class="number">2</span>; i++) &#123;</span><br><span class="line">				<span class="type">int</span> idx = i % nums.<span class="built_in">size</span>();</span><br><span class="line">				<span class="type">int</span> cur = nums[idx]; <span class="comment">//cur是元素,idx是下标</span></span><br><span class="line">				<span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; cur &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">					<span class="type">int</span> preIdx = st.<span class="built_in">top</span>();<span class="comment">//之前push到stack的元素,就是要找到他下一个最大元素的那个元素.</span></span><br><span class="line">					st.<span class="built_in">pop</span>();</span><br><span class="line">					ans[preIdx] = cur;</span><br><span class="line">				&#125;</span><br><span class="line">				st.<span class="built_in">push</span>(idx);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>多看看力口的官方题解:<a href="https://leetcode.cn/problems/next-greater-element-ii/solutions/637573/xia-yi-ge-geng-da-yuan-su-ii-by-leetcode-bwam/">503. 下一个更大元素 II - 力扣（LeetCode）</a></p>
<p>写的还行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; nums[stk.<span class="built_in">top</span>()] &lt; nums[i % n]) &#123;</span><br><span class="line">                ret[stk.<span class="built_in">top</span>()] = nums[i % n];</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i % n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/next-greater-element-ii/solutions/637573/xia-yi-ge-geng-da-yuan-su-ii-by-leetcode-bwam/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水-力扣（LeetCode）"><a href="#42-接雨水-力扣（LeetCode）" class="headerlink" title="42. 接雨水 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/">42. 接雨水 - 力扣（LeetCode）</a></h2><p>暴力法解决</p>
<p>直接看代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">			<span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxLeft</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxRight</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="comment">//从左边开始找</span></span><br><span class="line">			maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">				maxLeft[i] = <span class="built_in">max</span>(maxLeft[i - <span class="number">1</span>], height[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//从后往前遍历</span></span><br><span class="line">			maxRight[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				maxRight[i] = <span class="built_in">max</span>(height[i], maxRight[i + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//经典时间换空间</span></span><br><span class="line">			<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">				<span class="type">int</span> h = <span class="built_in">min</span>(maxLeft[i], maxRight[i]) - height[i]; <span class="comment">//左边柱子和右边柱子最高高度取最小值,然后减去当前的高度</span></span><br><span class="line">				<span class="keyword">if</span> (h &gt; <span class="number">0</span>) sum += h;<span class="comment">//h是雨水高度</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sum;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="55-跳跃游戏-力扣（LeetCode）"><a href="#55-跳跃游戏-力扣（LeetCode）" class="headerlink" title="55. 跳跃游戏 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏 - 力扣（LeetCode）</a></h2><p><img src="https://s2.loli.net/2024/05/06/rtjoNhwg2dU5sXL.png" alt="image-20240506113613759"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// for (int i = 0; i &lt; nums.size(); i++) &#123;//这里的重点是,操作循环的变量是cover,这代表了,每次在自己的覆盖范围 里面循环</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) &#123;</span><br><span class="line">				cover = <span class="built_in">max</span>(i + nums[i], cover); <span class="comment">//我只要最大的覆盖范围</span></span><br><span class="line">				<span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;<span class="comment">//只能恰好等于的时候</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最重要的一集:<strong>使用cover操作变量,代表在自己的覆盖范围内循环</strong></p>
<h2 id="406-根据身高重建队列-力扣（LeetCode）"><a href="#406-根据身高重建队列-力扣（LeetCode）" class="headerlink" title="406. 根据身高重建队列 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列 - 力扣（LeetCode）</a></h2><p><img src="https://s2.loli.net/2024/05/09/gXQ9WM341jmznuf.png" alt="image-20240509185421846"></p>
<p>题解:<a href="https://www.programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html#%E6%80%9D%E8%B7%AF">0406.根据身高重建队列.html#思路</a></p>
<p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[<span class="number">0</span>] == B[<span class="number">0</span>]) &#123;</span><br><span class="line">				<span class="keyword">return</span> A[<span class="number">1</span>] &lt; B[<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> A[<span class="number">0</span>] &gt; B[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">			list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">			<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), <span class="built_in">cmp</span>());</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">				<span class="comment">//理解还是得模拟代码执行,自己懂怎么搞,才能写出来实际有效的代码</span></span><br><span class="line">				<span class="type">int</span> pos = people[i][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">auto</span> it = que.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (pos--) &#123;</span><br><span class="line">					it++;</span><br><span class="line">				&#125;</span><br><span class="line">				que.<span class="built_in">insert</span>(it, people[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.<code>static bool cmp(const vector&lt;int&gt; &amp;A, const vector&lt;int&gt; &amp;B)</code>前面记得带上<strong>static</strong></p>
<p>然后const和&amp;不要忘记了,定义比较的规则即可.是针对vector内部存储的元素定义的.</p>
<p><code>list&lt;vector&lt;int&gt;&gt; que;</code>链表实现,插入的时候时间复杂度比较小,相对于vector的插入来说,因为vector的插入是暴力扩展数组,导致时间复杂度十分的高啊.</p>
<p><img src="https://s2.loli.net/2024/05/09/8veTingA6f4kPE2.png" alt="image-20240509185924681"></p>
<p><img src="https://s2.loli.net/2024/05/09/gm9UVThQS2KBpD7.png" alt="vector原理"></p>
<p><img src="https://s2.loli.net/2024/05/09/pqJ5YIOMtfwakQo.png" alt="image-20240509185943770"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = que.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (pos--) &#123;</span><br><span class="line">					it++;</span><br><span class="line">				&#125;</span><br><span class="line">				que.<span class="built_in">insert</span>(it, people[i]);</span><br></pre></td></tr></table></figure>

<p>改成链表的格式,找到指向最开始的下标pos,然后直接原地插入:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());<span class="comment">//直接拷贝一份</span></span><br></pre></td></tr></table></figure>

<p>在提供的代码中，<code>return vector&lt;vector&lt;int&gt;&gt;(que.begin(), que.end());</code>这行代码的作用是将存储在链表 <code>que</code> 中的结果转换为一个二维向量，并将其作为函数的返回值。</p>
<p>解释这段代码的具体步骤如下：</p>
<ol>
<li><code>que.begin()</code> 返回指向链表 <code>que</code> 中第一个元素的迭代器。</li>
<li><code>que.end()</code> 返回指向链表 <code>que</code> 中末尾（最后一个元素的下一个位置）的迭代器。</li>
<li><code>vector&lt;vector&lt;int&gt;&gt;(que.begin(), que.end())</code> 这部分代码将链表 <code>que</code> 中的元素从开始到结束复制到一个新的二维向量中。</li>
</ol>
<p><strong>换句话说，这行代码的功能是将链表中的内容复制到一个新的二维向量中，并作为函数 <code>reconstructQueue</code> 的返回值。</strong></p>
<p>这样的操作是由于 <code>std::list</code> 不直接支持通过下标进行访问。通过将链表中的元素复制到向量中，可以更方便地对结果进行处理或输出。</p>
<p><strong>直接AI解释代码即可</strong></p>
<h2 id="435-无重叠区间-力扣（LeetCode）"><a href="#435-无重叠区间-力扣（LeetCode）" class="headerlink" title="435. 无重叠区间 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/submissions/533691956/">435. 无重叠区间 - 力扣（LeetCode）</a></h2><p>题解:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A[<span class="number">0</span>] &lt; B[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Add a check for empty intervals</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end&lt;=intervals[i][<span class="number">0</span>])&#123;<span class="comment">//不重叠</span></span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//大于的情况才算</span></span><br><span class="line">                end=<span class="built_in">min</span>(end,intervals[i][<span class="number">1</span>]);<span class="comment">//更新的必须是右边界</span></span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.具体两点:</p>
<p><img src="https://s2.loli.net/2024/05/21/KfwrOcksy7qHM43.png" alt="img"></p>
<p>end是区间的右点,首先让全部区间按照左边界或者右边界排序.</p>
<p>2.然后:</p>
<p><code>end=min(end,intervals[i][1]);//更新的必须是右边界</code>这里的min是因为可能有<img src="https://s2.loli.net/2024/05/21/j6ZW5K2dIArfQu1.jpg" alt="591288c5b40a217d42979201a6621eb"></p>
<p>大区间是第一个,然后套了小区间(第二个),所以取最小的右边界,判断是否重叠.</p>
<p>逻辑是</p>
<p><code>if(end&lt;=intervals[i][0])&#123;//不重叠                 end = intervals[i][1];             &#125;else&#123;//大于的情况才算                 end=min(end,intervals[i][1]);//更新的必须是右边界                 ans++;             &#125;</code></p>
<p>end代表前一个的右点,然后和第二个的左点比较,右大于左即可判断重叠:</p>
<p><img src="https://s2.loli.net/2024/05/21/vXGMeKF4OYJtcyS.png" alt="452.用最少数量的箭引爆气球"></p>
<h2 id="763-划分字母区间-力扣（LeetCode）"><a href="#763-划分字母区间-力扣（LeetCode）" class="headerlink" title="763. 划分字母区间 - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间 - 力扣（LeetCode）</a></h2><p>题解:</p>
<p><a href="https://www.programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
<p>图片:</p>
<p><img src="https://s2.loli.net/2024/05/22/grxtAObonG3vhI7.png" alt="763.划分字母区间"></p>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p><img src="https://s2.loli.net/2024/05/22/oruk5QSCLVObUcF.png" alt="image-20240306155549126"></p>
<p>KMP算法会在不匹配的时候,匹配到之前匹配过的字符串,这里最开始匹配,f和b匹配不上,就会去找之前的aab.</p>
<h4 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h4><p>能找到b的原因是:<strong>我的f前面的aa和b前面的aa是一样的,如此就需要找到String中max length的equal的前后缀子串,如此在遇到不匹配,就去查询,然后找到匹配的字符串.</strong></p>
<p> 前缀是:<img src="https://s2.loli.net/2024/05/22/ozw2UtKfjcyTd9I.png" alt="image-20240306160520097"></p>
<p>后缀是:<img src="https://s2.loli.net/2024/05/22/FXDiKRC7ML6BbYq.png" alt="image-20240306160503523"></p>
<h5 id="最长相等前后缀"><a href="#最长相等前后缀" class="headerlink" title="最长相等前后缀"></a>最长相等前后缀</h5><p>问题:不够专注.主要问题,想东想西,还是得规划.</p>
<p>还是得专注啊. </p>
<p><img src="https://s2.loli.net/2024/05/22/qrjmQXZC9zEtixU.png" alt="image-20240306212520455"></p>
<p>此处就是看aa,aa这种东西,在aabaa中,前缀是aa,后缀也是aa,那么相等的前后缀的长度即为2.</p>
<h1 id="蓝桥杯常见坑点"><a href="#蓝桥杯常见坑点" class="headerlink" title="蓝桥杯常见坑点"></a>蓝桥杯常见坑点</h1><p><img src="https://s2.loli.net/2024/05/22/HLnUyTNS5JmkYsX.webp" alt="img"></p>
<p><img src="https://s2.loli.net/2024/05/22/LCpgafyWGM8dO4l.webp" alt="img"></p>
<h1 id="常见STL容器学习"><a href="#常见STL容器学习" class="headerlink" title="常见STL容器学习"></a>常见STL容器学习</h1><p>算法基础模板:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 解题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t; <span class="comment">// 单测则注释</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列:"></a>优先队列:</h2><p><img src="https://s2.loli.net/2024/05/22/ZJeYzcDj9tsSkam.png" alt="image-20240313144259672"></p>
<h3 id="定义比较条件"><a href="#定义比较条件" class="headerlink" title="定义比较条件"></a>定义比较条件</h3><p>当你使用自己定义的结构体时,<strong>需要重载小于号,或者重载一下运算符</strong></p>
<p><strong><img src="https://s2.loli.net/2024/05/22/utIEMywT1Y3kOmx.png" alt="image-20240313144519216"></strong></p>
<p>比如这里的node,不然不知道如何比较的.</p>
<h3 id="使用的例子"><a href="#使用的例子" class="headerlink" title="使用的例子:"></a>使用的例子:</h3><p><code>cmp函数</code></p>
<p><img src="https://s2.loli.net/2024/05/22/CoHTPGY4bM9Ny3z.png" alt="image-20240313145013176"></p>
<p>具体使用</p>
<p><img src="https://s2.loli.net/2024/05/22/xoMvpVzL2gYIycD.png" alt="image-20240313144944303"></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作:"></a>基本操作:</h3><p><img src="https://s2.loli.net/2024/05/22/wCRjQWunpkF9Xla.png" alt="image-20240313144830270"></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.starrycoding.com/problem/58">小e的菜篮子 - StarryCoding | 踏出编程第一步</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// define priority_queue</span></span><br><span class="line">  priority_queue&lt;ll&gt; pq;</span><br><span class="line">  ll sum = <span class="number">0</span>;  <span class="comment">// the sum of the pq`s element;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> q;</span><br><span class="line">  cin &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">      ll x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      pq.<span class="built_in">push</span>(x);</span><br><span class="line">      sum += x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ll x = pq.<span class="built_in">top</span>();</span><br><span class="line">        sum -= x;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h2><p><img src="https://s2.loli.net/2024/05/22/iUXDFJmQV2a6ToZ.png" alt="image-20240313152045424"></p>
<p>底层红黑树,就是object差不多的,键值对.</p>
<p>里面是<strong>一棵树</strong></p>
<p><img src="https://s2.loli.net/2024/05/22/FTf8tYenMBIZb9V.png" alt="image-20240313152130218"></p>
<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p><img src="https://s2.loli.net/2024/05/22/OIc3hlSUqYGT9Wy.png" alt="image-20240313152325006"></p>
<h3 id="基本的操作"><a href="#基本的操作" class="headerlink" title="基本的操作"></a>基本的操作</h3><p><img src="https://s2.loli.net/2024/05/22/cDiRxnwS7O1QyUs.png" alt="image-20240313152525176"></p>
<h3 id="遍历map和例题"><a href="#遍历map和例题" class="headerlink" title="遍历map和例题"></a>遍历map和例题</h3><p><img src="https://s2.loli.net/2024/05/22/GJFWhXfNl4UyLzK.png" alt="image-20240313152755574"></p>
<p>mysql密码:20040317@Li</p>
<p>例题:<a href="https://www.starrycoding.com/problem/59">气球数量 - StarryCoding | 踏出编程第一步</a></p>
<h3 id="P59-气球数量"><a href="#P59-气球数量" class="headerlink" title="[P59] 气球数量"></a>[P59] 气球数量</h3><p>收藏本题</p>
<p>提交记录</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>空中有�<em>n</em>个气球，第�<em>i</em>个气球有一个颜色����<em>co<strong>l</strong>i</em>（用一个字符串表示）。</p>
<p>请你求出每种气球的个数，按照气球出现的顺序进行排序输出。</p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>第一行一个整数�<em>T</em>表示样例个数。(1≤�≤10)(1≤<em>T</em>≤10)</p>
<p>对于每个样例，第一行一个整数�<em>n</em>表示气球个数。(1≤� ��100)(1≤<em>n</em> <em>l**e</em>100)</p>
<p>接下来�<em>n</em>行，每行一个字符串表示����<em>co<strong>l</strong>i</em>。(1≤∣����∣≤50)(1≤∣<em>co<strong>l</strong>i</em>∣≤50)</p>
<p>字符串仅包含小写英文字母。</p>
<h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>对于每个样例，输出所有气球的种类和个数。</p>
<h4 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">red</span><br><span class="line">red</span><br><span class="line">blue</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line"><span class="selector-tag">b</span></span><br><span class="line">e</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<h4 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">red <span class="number">2</span></span><br><span class="line">blue <span class="number">1</span></span><br><span class="line"><span class="selector-tag">a</span> <span class="number">1</span></span><br><span class="line"><span class="selector-tag">b</span> <span class="number">1</span></span><br><span class="line">e <span class="number">2</span></span><br><span class="line">d <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>对字符串进行计数.但是map的key可以是字符串</p>
<p>解决代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  ll id;</span><br><span class="line">  ll num;</span><br><span class="line">  string col;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;u) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id &lt; u.id;</span><br><span class="line">  &#125;  <span class="comment">// 定义map中排序的规则</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map&lt;string, Node&gt; mp;</span><br><span class="line">  ll n;  <span class="comment">// 气球个数</span></span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    string col;</span><br><span class="line">    cin &gt;&gt; col;</span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">count</span>(col)) &#123;  <span class="comment">// 如果map中有这个颜色.</span></span><br><span class="line">      mp[col].num++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mp[col] = &#123;i, <span class="number">1</span>, col&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后让我输出的是:颜色和对应的数量.</span></span><br><span class="line">  vector&lt;Node&gt; vr;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : mp) &#123;</span><br><span class="line">    vr.<span class="built_in">push_back</span>(val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(vr.<span class="built_in">begin</span>(), vr.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[id, num, col] : vr) &#123;</span><br><span class="line">    cout &lt;&lt; col &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>代码:<strong>当自定义结构体的时候,重载小于号运算符</strong>,Set就是数学意义上的集合:</p>
<ol>
<li>没有重复元素:</li>
<li>Set里面的元素是有顺序的.</li>
<li>Set是树形结构.</li>
</ol>
<p>代码例子:</p>
<p>具体应用:</p>
<p><img src="https://s2.loli.net/2024/05/22/nrDq4FISfYuzQP1.png" alt="image-20240313203202267"></p>
<p>错误示例:</p>
<p><img src="https://s2.loli.net/2024/05/22/udSbjt8CanNLkf7.png" alt="image-20240313203325151"></p>
<p>TLE和RE的解释:<img src="https://s2.loli.net/2024/05/22/u9aGtOBLMWAX27T.png" alt="image-20240313203649092"></p>
<p>对数组去重:</p>
<p>还是那句话,先把视频看完先,能理解多少理解多少,别不想看就行.</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题:"></a>01背包问题:</h2><p><a href="https://www.starrycoding.com/problem/74">采药 - StarryCoding | 踏出编程第一步</a></p>
<p>动态规划问题:先定义dp数组的含义.</p>
<p><img src="https://s2.loli.net/2024/05/22/3PjzRNQA7XB8lx4.png" alt="image-20240312220217727"></p>
<p><img src="https://s2.loli.net/2024/05/22/dQag2XPvyqcFkWE.png" alt="image-20240312220549035"></p>
<p>这里的转移的意思是:<strong>dp(i)(j)这个变量能被其他的子问题给表示,比如上面的式子.</strong></p>
<p>就是能够被表示的问题,dp[i-1],[j]表示没有选第i个草药. </p>
<p>后面的就是代表选了,v[i]表示消耗的时间,W[j]表示增加的价值.</p>
<p><img src="https://s2.loli.net/2024/05/22/YgUxGuQrsy2HLAh.png" alt="image-20240312223746444"></p>
<p>就是类似于这样的计算.</p>
]]></content>
  </entry>
  <entry>
    <title>JavaSpring学习</title>
    <url>/post/8a81cf60.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一切都是为了实战"><a href="#一切都是为了实战" class="headerlink" title="一切都是为了实战"></a>一切都是为了实战</h1><p><img src="https://s2.loli.net/2024/03/25/xVqo9vkJBUAywDZ.png" alt="image-20240325132434599"></p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><p>java执行原理:</p>
<p>将高级编程语言翻译成机器语言:</p>
<p><img src="https://s2.loli.net/2024/05/14/wsut6aA1EMzfSTI.png" alt="image-20240514204420979"></p>
<p><img src="https://s2.loli.net/2024/05/14/UWiTXeZKnsuLCVa.png" alt="image-20240514204910463"></p>
<p><img src="https://s2.loli.net/2024/05/14/pBjyOKLlno4Mvxf.png" alt="image-20240514204942356"></p>
<p>大概执行过程.</p>
<p><img src="https://s2.loli.net/2024/05/14/NirayEVDM71oHS8.png" alt="image-20240514205041388"></p>
<p>进程的块就是页，内存的块就是框。学长现在真给我点明白了</p>
<p>老板给进程画大饼，进程想的空间是：“耶！”（页），实则去内存一看是个诓（页框），两者记在小本本（页表），一项一项叫表项。</p>
<p>还是人多力量大啊</p>
<p>反正哪一行都不容易,明天速通机器学习.</p>
<h1 id="javaSpring"><a href="#javaSpring" class="headerlink" title="javaSpring"></a>javaSpring</h1><h2 id="POJO是啥"><a href="#POJO是啥" class="headerlink" title="POJO是啥?"></a>POJO是啥?</h2><p>POJO是“Plain Old Java Object”的缩写，意为“普通的旧Java对象”，也称为简单Java对象。它是指自包含、独立、轻量级的Java类，不继承或实现特定框架或接口，也没有任何特殊限制或要求。POJO类的设计目标是实现基本的Java对象模型，并且可以在任何Java环境中使用，而不依赖于特定的框架或平台。</p>
<p>POJO类通常具有以下特点：</p>
<ul>
<li>符合Java语言的基本语法和约定。</li>
<li>不需要继承特定的基类或实现特定的接口。</li>
<li>通常包含私有字段（成员变量）、公开的getter和setter方法（属性访问器）以及其他常规的Java方法。</li>
<li>可以被序列化为XML、JSON等格式，或者用于持久化到数据库中。</li>
<li>可以用于任何Java开发环境，不依赖于特定的框架、库或平台。</li>
</ul>
<p>POJO类的设计原则是简单、清晰、可重用和可测试性，没有复杂的继承关系或依赖关系，易于理解和维护。POJO类常用于构建业务逻辑、数据传输对象（DTO）、数据访问对象（DAO）等领域对象。它们通常用于解耦和分离关注点，使代码模块化和可测试，提高代码的可读性、可维护性和可扩展性。</p>
<p>总而言之，POJO是一种简单、轻量级、无依赖的Java类，遵循基本的Java语言约定，并且不依赖于特定的框架或平台。它们被广泛应用于各种Java开发项目中，以实现可读性好、可维护性高的代码。</p>
<h2 id="MVC-框架是啥"><a href="#MVC-框架是啥" class="headerlink" title="MVC 框架是啥?"></a>MVC 框架是啥?</h2><p>MVC（Model-View-Controller）是一种软件设计模式，用于将应用程序的逻辑、数据和用户界面分离。它将应用程序分为三个组件：模型（Model）、视图（View）和控制器（Controller），每个组件专注于不同的责任。</p>
<ul>
<li><p>模型（Model）：模型代表应用程序的数据和业务逻辑。它负责处理数据的读取、存储、验证和操作，以及实现应用程序的核心功能。模型不依赖于视图或控制器，它提供接口供其他组件访问和操作数据。</p>
</li>
<li><p>视图（View）：视图是模型的可视化表现。它负责用户界面的展示，呈现数据给用户，以及接收用户的输入。视图根据模型的状态进行更新，并将用户的操作传递给控制器进行处理。视图通常是被动的，即它只负责展示数据，不处理业务逻辑。</p>
</li>
<li><p>控制器（Controller）：控制器是模型和视图之间的中间人。它接收来自视图的用户输入，并根据输入更新模型的状态，或者根据模型的状态更新视图。控制器处理用户的请求，协调模型和视图之间的交互，并确保数据的一致性和正确性。</p>
</li>
</ul>
<p>MVC框架通过将应用程序的不同部分分别放置在模型、视图和控制器中，实现了应用程序的分层和解耦。这种分离使得应用程序的开发和维护更加容易，提供了更好的可测试性和可扩展性。通过MVC框架，开发人员可以更好地组织代码、提高代码的重用性，并且更好地应对需求变化。</p>
<p>总而言之，MVC框架是一种软件设计模式，用于将应用程序的逻辑、数据和用户界面分离，以实现代码的模块化、可维护性和可扩展性。它通过模型、视图和控制器的角色划分，提供了一种结构化的开发方式，使得应用程序更易于开发、测试和维护。</p>
<p><strong>举个例子,后端是不是负责模型和控制器?<br>前端负责视图view?</strong></p>
<p>是的，通常情况下，后端负责模型和控制器，前端负责视图。</p>
<p>举个例子，假设我们正在开发一个简单的博客应用程序：</p>
<ul>
<li><p>后端负责模型和控制器：后端开发人员会负责博客应用程序的数据存储和业务逻辑。他们会设计和实现博客文章的数据模型（例如文章的标题、内容、作者等），并处理与数据相关的操作，比如创建、读取、更新和删除文章。控制器层会接受来自前端的请求，处理用户的输入和操作，并调用适当的模型方法来执行业务逻辑。</p>
</li>
<li><p>前端负责视图：前端开发人员会负责博客应用程序的用户界面设计和用户交互。他们会设计和实现博客页面的布局、样式和交互效果，以提供用户友好的界面。前端会根据用户的操作和需求，向后端发送请求，获取博客数据，并将数据呈现给用户。</p>
</li>
</ul>
<p>在这个例子中，后端负责设计和维护博客数据的模型，以及处理博客相关的业务逻辑。同时，控制器负责接收来自前端的请求，执行相应的操作，并将结果返回给前端。前端负责设计、开发和维护博客应用程序的用户界面，负责呈现数据给用户，并将用户的操作发送给后端。</p>
<p>通过MVC的结构，前端和后端之间的工作可以相对独立，并通过定义好的接口进行通信。这种分工和协作方式可以提高开发效率、代码的可维护性，并且便于对前后端进行扩展和适应变化。</p>
<p><strong>model是不是就是service这种开发接口?</strong></p>
<p>不完全正确。在MVC架构中，模型（Model）通常是指应用程序的数据模型和业务逻辑的组合，它不仅仅是一个”Service”接口。</p>
<p>模型（Model）包含了处理数据存取、验证、处理和业务逻辑的组件，而这些组件可以包括服务（Service）类、实体类（Entity）或数据访问对象（DAO）、业务逻辑组件（Business Logic Component）等。</p>
<ul>
<li><p>服务（Service）类：服务类通常是模型的一部分，用于提供业务逻辑的实现。它们封装了对数据的处理和操作，并且可能调用其他模型组件（如数据访问对象）来完成一些具体的任务。</p>
</li>
<li><p>实体类（Entity）：实体类是模型中的数据对象，代表了应用程序中的核心数据结构。它可以是数据库中的表，也可以是应用程序中的某个业务实体。实体类通常包含属性（字段）和相关的方法，用于操作和访问这些属性。</p>
</li>
<li><p>数据访问对象（DAO）：DAO是用于访问数据存储（如数据库）的组件。它封装了对数据库的操作，提供数据的读取、存储、更新等方法。DAO通常负责处理数据库连接、执行SQL语句，并将查询结果转换为模型中的实体对象。</p>
</li>
</ul>
<p>除了服务、实体和DAO之外，模型还可以包括其他的组件，如业务逻辑组件、数据传输对象（DTO）、工具类等。这些组件共同组成了模型层，用于处理应用程序的数据和业务逻辑。</p>
<p>总结来说，模型包括了在MVC架构中处理数据和业务逻辑的组件。其中服务类（Service）是其中一种常见的模块，但模型不仅限于服务类。模型可以包括实体类（Entity）、数据访问对象（DAO）、业务逻辑组件等，以及其他与数据和业务逻辑有关的组件。</p>
<h2 id="Bean是啥"><a href="#Bean是啥" class="headerlink" title="Bean是啥?"></a>Bean是啥?</h2><p>在Spring框架中，Bean是指由Spring容器实例化、管理和组装的对象。它是Spring中最基本的组件，可以理解为在应用程序中被Spring容器管理的对象实例。</p>
<p>Spring的IoC（控制反转）容器负责实例化、配置和管理这些Bean对象。通过IoC容器，开发人员可以将对象的创建、依赖注入和生命周期管理交给Spring框架来处理，从而减轻了开发人员的负担，提高了应用程序的灵活性和可维护性。</p>
<p>在Spring中，Bean具有以下特点：</p>
<ol>
<li><p>实例化：Spring容器根据配置信息或注解来实例化Bean对象。可以使用传统的XML配置方式，也可以使用基于注解的方式。</p>
</li>
<li><p>配置：Spring容器通过依赖注入（Dependency Injection）来配置Bean的依赖关系和属性。开发人员可以在配置文件或注解中定义Bean的属性值，以及其他Bean之间的依赖关系。</p>
</li>
<li><p>生命周期管理：Spring容器负责管理Bean的生命周期，包括创建、初始化和销毁。开发人员可以通过实现特定的接口或使用注解来控制Bean的初始化和销毁过程。</p>
</li>
<li><p>单例或多例：Spring的Bean可以配置为单例（Singleton）模式或多例（Prototype）模式。单例模式表示容器中只有一个Bean实例，多例模式表示每次获取Bean时都会创建一个新的实例。</p>
</li>
<li><p>AOP增强：Spring容器可以通过AOP（面向切面编程）为Bean提供额外的功能，比如事务管理、日志记录等。通过AOP，开发人员可以将与核心业务逻辑无关的横切关注点统一管理。</p>
</li>
</ol>
<p>Spring的Bean概念是Spring框架的核心之一。它使得开发人员可以通过IoC容器管理对象的生命周期和依赖关系，从而提供了灵活、可扩展的开发方式。通过使用Spring的Bean，开发人员可以实现解耦、提高系统的可测试性和可维护性。</p>
<h2 id="苍穹外卖项目"><a href="#苍穹外卖项目" class="headerlink" title="苍穹外卖项目"></a>苍穹外卖项目</h2><h3 id="软件开发整体介绍"><a href="#软件开发整体介绍" class="headerlink" title="软件开发整体介绍"></a>软件开发整体介绍</h3><h4 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h4><p>需求规格说明书:</p>
<p><img src="https://s2.loli.net/2024/03/25/Z83YplPi49kEtoa.png" alt="image-20240325123447048"></p>
<p>产品原型:通过静态网页的形式展示:</p>
<p><img src="https://s2.loli.net/2024/03/25/qtAGWZS5r8efRUD.png" alt="image-20240325123515349"></p>
<p>UI设计:</p>
<p><img src="https://s2.loli.net/2024/03/25/4Npxjb8J31Uif9k.png" alt="image-20240325124057523"></p>
<p>数据库设计:</p>
<p><img src="https://s2.loli.net/2024/03/25/ZTBRiJ4FstA2UQp.png" alt="image-20240325124145350"></p>
<p>接口设计:</p>
<p><img src="https://s2.loli.net/2024/03/25/azNJDU59MTGFQZ6.png" alt="image-20240325124200495"></p>
<p>上述进行完就是这些了:</p>
<p><img src="https://s2.loli.net/2024/03/25/7mfyPWVTeNx2Apl.png" alt="image-20240325124316779"></p>
<p><img src="https://s2.loli.net/2024/03/25/y7IkXaJh2PWSNrQ.png" alt="image-20240325124415144"></p>
<h4 id="角色分工"><a href="#角色分工" class="headerlink" title="角色分工"></a>角色分工</h4><p><img src="https://s2.loli.net/2024/03/25/wVR1yquHQKk834e.png" alt="image-20240325124501062"></p>
<h4 id="环境分配"><a href="#环境分配" class="headerlink" title="环境分配"></a>环境分配</h4><p><img src="https://s2.loli.net/2024/03/25/7zFAyHnwqWhsMuJ.png" alt="image-20240325125052319"></p>
<p>开发-&gt;测试-&gt;生产.</p>
<h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><h4 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构:"></a>功能架构:</h4><p><img src="https://s2.loli.net/2024/03/25/qWixoKEhHk4DUsz.png" alt="image-20240325125342661"></p>
<h4 id="产品原型"><a href="#产品原型" class="headerlink" title="产品原型:"></a>产品原型:</h4><p><img src="https://s2.loli.net/2024/03/25/5aUt8RxMjw6XFhL.png" alt="image-20240325125659157"></p>
<p><img src="https://s2.loli.net/2024/03/25/waiboq1eX9cJ2fC.png" alt="image-20240325125727296"></p>
<p>展示效果的模型就是产品原型.</p>
<p><img src="https://s2.loli.net/2024/03/25/kuVn2BWv3JhHXMr.png" alt="image-20240325130043869"></p>
<p>先学着,耐住寂寞才能变强,不然图书馆为什么那么多人.</p>
<p>通过产品原型就能理解业务如何实现:</p>
<p><img src="https://s2.loli.net/2024/03/25/ZFnOrR3Gv9gwodU.png" alt="image-20240325130329943"></p>
<p><img src="https://s2.loli.net/2024/03/25/vsHV4uJq2elf1o7.png" alt="image-20240325130347033"></p>
<p>nb的产品原型右边都是有这些说明文字的.</p>
<p>技术选型:</p>
<p>WebSocket:实现项目中的催单和来单提醒.</p>
<p><img src="https://s2.loli.net/2024/03/25/kQq1piJNt8szrDm.png" alt="image-20240325133242923"></p>
<h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><p>经典前后端分离:</p>
<p><img src="https://s2.loli.net/2024/03/25/VhvXQLApHTxBZer.png" alt="image-20240325134043649"></p>
<p>专业术语:</p>
<p>data transfer object和value object.</p>
<p><img src="https://s2.loli.net/2024/03/25/xU7r9H4gkMO32hC.png" alt="image-20240325195449249"></p>
<p>在软件开发中，<strong>POJO</strong> 是 “Plain Old Java Object” 的缩写，指的是简单的普通Java对象，它不继承特定类或实现特定接口，也不依赖特定框架。POJO 是对 JavaBean 的一种扩展概念，用来表示普通的Java对象，它通常用于承载数据、传输数据或封装业务逻辑。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors, getters, setters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	最喜欢controller的一集</p>
<p><img src="https://s2.loli.net/2024/03/25/8f6p9WdcGSz1LE4.png" alt="image-20240325204735328"></p>
<h3 id="Java基础-1"><a href="#Java基础-1" class="headerlink" title="Java基础"></a>Java基础</h3><h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式:"></a>单例设计模式:</h4><p><img src="https://s2.loli.net/2024/03/25/Vb182s3UmBtOjri.png" alt="image-20240325205749805"></p>
<p>代码示例:</p>
<p><img src="https://s2.loli.net/2024/03/25/kmyAspPWNhJF3Yx.png" alt="image-20240325210603909"></p>
<p>类变量是属于类自己持有的:</p>
<p>定义方法就是:private static A a &#x3D; new A();类变量a只会有一个.</p>
<p>打印地址,获取到的是同一个对象:<img src="https://s2.loli.net/2024/03/25/fPYO4yg1d6RzB5a.png" alt="image-20240325210755523"></p>
<p>单例设计模式的好处:</p>
<p>​	例子:runTime类(<code>代表你程序的运行环境</code>):</p>
<p><img src="https://s2.loli.net/2024/03/25/y3JLC8uF2DbhkpH.png" alt="image-20240325210934092"></p>
<p>​	final修饰变量必须赋初始值，并且不能被修改</p>
<p><img src="https://s2.loli.net/2024/03/25/BZAJfxnEwXli4M8.png" alt="image-20240325211110910"></p>
<p><img src="https://s2.loli.net/2024/03/25/17rCRH3VIhc95qQ.png" alt="image-20240325211149011"></p>
<p>扩展:<code>懒汉式的单例对象</code></p>
<p><img src="https://s2.loli.net/2024/03/25/62RwFut4OQdh1zq.png" alt="image-20240325211248547"></p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p><img src="https://s2.loli.net/2024/03/25/xyXBZu7K1mhopSF.png" alt="image-20240325211544308"></p>
<p>匿名的意思就是不用给这个类起名字.可以直接把这个类传入当参数.</p>
<p><img src="https://s2.loli.net/2024/03/25/k1S56oL9dxw8zg2.png" alt="image-20240325211739239"></p>
<p>使用java开发桌面程序的时候:<img src="https://s2.loli.net/2024/03/25/VGBkcxt1P7eZIvy.png" alt="image-20240325212124780"></p>
<p><strong>这里监听事件就需要匿名内部类了.一般都是为了满足别人定义好的API的要求.</strong></p>
<p><code>最终的核心目的是简化代码. </code></p>
<p>和js的箭头函数差不多:<img src="https://s2.loli.net/2024/03/25/Lh7r6cPMFnwqjWQ.png" alt="image-20240325212722802"></p>
<p>相信我:看视频就是最快的,倍速!</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射:"></a>反射:</h4><p>反射是:加载类,然后允许以编程的方式解刨类中的各种成分(成员变量,方法,构造器等等).</p>
<p>比如IDEA会自动提示对象的方法和属性,这就是反射的应用:</p>
<p><img src="https://s2.loli.net/2024/03/25/kzQGn1qwoysEFil.png" alt="image-20240325213301130"></p>
<p><img src="https://s2.loli.net/2024/03/25/WY5hprnbyi9PDmf.png" alt="image-20240325213402175"></p>
<p>代码示例:</p>
<p><img src="C:/Users/13205/AppData/Roaming/Typora/typora-user-images/image-20240325213623682.png" alt="image-20240325213623682"></p>
<p>反射的作用:</p>
<p><img src="https://s2.loli.net/2024/03/26/ZoagFd4EimuU5JK.png" alt="image-20240326095458759"></p>
<p><strong>框架就是一大堆Java代码</strong>:</p>
<p><img src="https://s2.loli.net/2024/03/26/YhDmlO8XfkatS96.png" alt="image-20240326095649352"></p>
<p>具体实现:”</p>
<p><img src="https://s2.loli.net/2024/03/26/aHI5bKdhTE6XvjG.png" alt="image-20240326100030579"></p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解:"></a>注解:</h4><p>注解的本质就是接口,里面没有属性,只有抽象方法.</p>
<p>注解可以实现标注,也就是提供信息罢了.</p>
<p>主要目的还是<code>实现框架,告诉编译器:IDEA和框架代码,这个函数是干啥的,然后框架识别到这些,直接采取对应的措施,都是人家定义好的,直接用就行了.</code></p>
<p>使用注解实现带有注解:<strong>MyTest的方法才能启动</strong></p>
<p><img src="https://s2.loli.net/2024/03/26/F1bvxlOHWsAQatD.png" alt="image-20240326201052643"></p>
<h4 id="DTO-VO-Entity"><a href="#DTO-VO-Entity" class="headerlink" title="DTO,VO,Entity:"></a>DTO,VO,Entity:</h4><p>在Java中，DTO（Data Transfer Object）、VO（Value Object）和Entity（实体类）是常见的概念，用于在不同层之间传递数据或表示某个领域的实体对象。下面是一个简单的示例来说明它们之间的区别和用法：</p>
<h5 id="Entity（实体类）："><a href="#Entity（实体类）：" class="headerlink" title="Entity（实体类）："></a>Entity（实体类）：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;products&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>Product</code> 是一个实体类，用于表示数据库中产品表的结构。通常，实体类与数据库表字段直接映射。</p>
<h5 id="DTO（Data-Transfer-Object）："><a href="#DTO（Data-Transfer-Object）：" class="headerlink" title="DTO（Data Transfer Object）："></a>DTO（Data Transfer Object）：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DTO通常用于在不同层之间传递数据，在前后端交互或服务之间数据传输中发挥作用。在这个示例中，<code>ProductDTO</code> 是一个用于表示产品数据的传输对象，通常用于在服务层和控制器层之间传递数据。</p>
<h5 id="VO（Value-Object）："><a href="#VO（Value-Object）：" class="headerlink" title="VO（Value Object）："></a>VO（Value Object）：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductVO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VO一般用于表示视图层的对象，将后端数据展示给前端。在这个示例中，<code>ProductVO</code> 是一个用于表示产品信息展示的值对象，通常在前端页面展示产品信息时使用。</p>
<p>总结：</p>
<ul>
<li>Entity 表示数据库中的实体，与数据库表字段直接映射。</li>
<li>DTO 负责不同层之间的数据传输，可以包含部分或全部实体类的信息。</li>
<li>VO 主要用于表示视图层需要的数据对象，包含展示所需的数据。</li>
</ul>
<h3 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h3><p>修改数据库的地址和用户名和密码:</p>
<p>在application_dev.xml中修改即可.</p>
<p>全局异常处理类:</p>
<p><img src="https://s2.loli.net/2024/03/25/Pcq8gtjVweIDEu5.png" alt="image-20240325222110444"></p>
<p>通过代码跟踪的方式,确实能认识到许多java的程序执行和全局常量类和全局工具类的使用.</p>
<p>Result类:</p>
<p><img src="https://s2.loli.net/2024/03/25/NzTSWwkUhiR5Gbc.png" alt="image-20240325223400281"></p>
<p>IDEA调试还是太方便了,傻逼VSCODE</p>
<p><img src="https://s2.loli.net/2024/03/25/mvtzknSygpe9N8W.png" alt="image-20240325223429273"></p>
<p>这些常用的属性统一封装成spingBoot中的配置属性类:</p>
<p><img src="https://s2.loli.net/2024/03/25/H9lXyLd8GRheEPu.png" alt="image-20240325223554982"></p>
<p>具体就是加了一个注解:<img src="https://s2.loli.net/2024/03/25/eaznqf6WBLxCuXR.png" alt="image-20240325223620356"></p>
<p>加入这个<code>@ConfigurationProperties(prefix = &quot;sky.jwt&quot;)</code></p>
<p>就可以从sky.jwt这个文件导入属性了.</p>
<p>可以通过<strong>断点调试</strong>跟踪<strong>后端程序的执行过程</strong>.</p>
<p>可以直接查看内存中变量的值,jetbrain家的调试还是太方便了.</p>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p><img src="https://s2.loli.net/2024/03/26/ws5eMUt2cK98ZRv.png" alt="image-20240326204901070"></p>
<p>答案:NGinx反向代理.</p>
<p><img src="https://s2.loli.net/2024/03/26/4Uj5QJatNryLYTm.png" alt="image-20240326210702868"></p>
<p>1.能够在集群方式运行的后端中,对服务器的状态进行监控,然后决定把请求转发给谁.</p>
<p>2.保证服务安全:一般来说后端的服务都是部署在公司内网的,内网不能由前端直接访问,而是通过nginx来配置让前端访问nginx这个服务器,相当于nginx中间层进行管理.</p>
<p>nginx教学:<img src="https://s2.loli.net/2024/03/26/vzNE5rcZBI9gyom.png" alt="image-20240326211147020"></p>
<p>会<strong>自动对替换的静态路径后面添加上动态路径</strong>,上面红色的<code>/api/</code>就是被替换的,看图就行</p>
<p>反正都是转发请求(负载均衡和反向代理).</p>
<p><img src="https://s2.loli.net/2024/03/26/zIFeX8KVnkOYwlj.png" alt="image-20240326212235582"></p>
<p>upstream代表命名一个服务器组.</p>
<p><img src="https://s2.loli.net/2024/03/26/4ydJEYM1z7m9SZN.png" alt="image-20240326213005946"></p>
<p>类似于这个:</p>
<p><img src="https://s2.loli.net/2024/03/26/Mqo2cIJLle5SWws.png" alt="image-20240326213932204"></p>
<h4 id="Nginx配置-简单"><a href="#Nginx配置-简单" class="headerlink" title="Nginx配置(简单)"></a>Nginx配置(简单)</h4><p>答案:就是按照人家这个配置就行,照抄,别想太多:</p>
<p><img src="https://s2.loli.net/2024/04/07/6LqBSgp4iAz8bIP.png" alt="image-20240407205857620"></p>
<p>前后的斜杠都要加…</p>
<p>最终代码:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> mime.types; <span class="comment"># 包含mime.types文件，用于定义文件类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream; <span class="comment"># 默认文件类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;  # 定义日志格式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;  # 访问日志路径和格式</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>; <span class="comment"># 开启文件发送</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;  # 开启TCP_NOPUSH</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;  # 保持连接超时时间为0</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>; <span class="comment"># 保持连接超时时间为65秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;  # 开启gzip压缩</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">map</span> <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span><br><span class="line">        <span class="attribute">default</span> upgrade; <span class="comment"># 默认值为upgrade</span></span><br><span class="line">        &#x27;&#x27; close; <span class="comment"># 如果$http_upgrade为空，则值为close</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> webservers &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span> weight=<span class="number">90</span> ; <span class="comment"># 定义服务器地址和权重</span></span><br><span class="line">        <span class="comment">#server 127.0.0.1:8088 weight=10 ;  # 定义服务器地址和权重</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 监听端口80</span></span><br><span class="line">        <span class="attribute">server_name</span> localhost; <span class="comment"># 服务器名称为localhost</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;  # 字符编码为koi8-r</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;  # 访问日志路径和格式</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> html/sky; <span class="comment"># 根目录为html/sky</span></span><br><span class="line">            <span class="attribute">index</span> index.html index.htm; <span class="comment"># 默认首页文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;  # 错误页面重定向</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html; <span class="comment"># 错误页面重定向</span></span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span> html; <span class="comment"># 根目录为html</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向代理,处理管理端发送的请求</span></span><br><span class="line">        <span class="section">location</span> /api/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://localhost:8080/admin/;</span><br><span class="line">            <span class="comment">#proxy_pass   http://webservers/admin/;</span></span><br><span class="line">            <span class="comment"># 反向代理到http://webservers/admin/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向代理,处理用户端发送的请求</span></span><br><span class="line">        <span class="section">location</span> /user/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://webservers/user/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># WebSocket</span></span><br><span class="line">        <span class="section">location</span> /ws/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://webservers/ws/;</span><br><span class="line">            <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>; <span class="comment"># 使用HTTP/1.1协议</span></span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">3600s</span>; <span class="comment"># 代理读取超时时间为3600秒</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>; <span class="comment"># 设置Upgrade请求头</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;<span class="variable">$connection_upgrade</span>&quot;</span>; <span class="comment"># 设置Connection请求头</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前后的斜杠不能忘啊</p>
<p><code>location /api/</code></p>
<p><code>proxy_pass http://localhost:8080/admin/;</code></p>
<p>不能写成这个:</p>
<p><code>location /api</code></p>
<p><code>proxy_pass http://localhost:8080/admin</code></p>
<p>上面这个是错的,具体原因:</p>
<p><img src="https://s2.loli.net/2024/04/07/NqoHjXTfDYUAEe3.png" alt="image-20240407210048160"></p>
<h4 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h4><p>hash密码存储到数据库.(MD5加密)</p>
<p><img src="https://s2.loli.net/2024/03/26/NQKUcsq2RbwY1xX.png" alt="image-20240326220037226"></p>
<h4 id="导入接口文档"><a href="#导入接口文档" class="headerlink" title="导入接口文档:"></a>导入接口文档:</h4><p>前后端分离的开发流程:</p>
<p><img src="https://s2.loli.net/2024/03/26/Exkn3Do62YGyWJA.png" alt="image-20240326222212529"></p>
<p>直接使用APIFOX导入Yapi的json格式的接口即可.</p>
<h4 id="使用Swagger"><a href="#使用Swagger" class="headerlink" title="使用Swagger:"></a>使用Swagger:</h4><p>自动生成接口文档和进行接口测试.</p>
<p><img src="https://s2.loli.net/2024/03/26/NHfMwiKO3Wjmez6.png" alt="image-20240326223212193"></p>
<p><strong>最重要的代码</strong></p>
<p><img src="https://s2.loli.net/2024/03/26/jM2HBFbpNUgKCI5.png" alt="image-20240326223414397"></p>
<p>设置静态资源映射:</p>
<p><img src="https://s2.loli.net/2024/03/26/keAolqyGNZJ4tni.png" alt="image-20240326223314547"></p>
<p>不设置静态资源映射就找不到网页.</p>
<p>yapi:<code>apifox</code>是接口设计阶段使用的</p>
<p>swagger是后端接口测试使用的,两者并不冲突.</p>
<p><img src="https://s2.loli.net/2024/03/27/PzacVD8kujBHnwS.png" alt="image-20240327122208454"></p>
<h3 id="员工管理-商家管理"><a href="#员工管理-商家管理" class="headerlink" title="员工管理,商家管理"></a>员工管理,商家管理</h3><p>先开发:分类管理.</p>
<p>英语还是没有那么热衷,语言就是多听,多说,多看就行了.</p>
<p>代码也是语言!!.</p>
<h4 id="1-员工端"><a href="#1-员工端" class="headerlink" title="1.员工端"></a>1.员工端<img src="https://s2.loli.net/2024/03/27/6yNM8SseVFfc2nh.png" alt="image-20240327131809202"></h4><p>单表的增删改查.</p>
<p><img src="https://s2.loli.net/2024/03/27/lGQLhdUjIvexXWA.png" alt="image-20240327131904462"></p>
<p>基本都是上面的流程.</p>
<p>通过对产品原型的分析,确定代码如何写:</p>
<p><img src="https://s2.loli.net/2024/03/27/IVnrmSpHXlxW3sk.png" alt="image-20240327132558039"></p>
<p><img src="https://s2.loli.net/2024/03/27/F71isHpNJbw5jTU.png" alt="image-20240327132323866"></p>
<p>使用前缀来对用户端和管理端的请求进行分离.</p>
<p><img src="https://s2.loli.net/2024/03/27/3iZ6vLnGBTNtcmq.png" alt="image-20240327132636273"></p>
<p><strong>终于到代码了!</strong></p>
<h5 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h5><p><img src="https://s2.loli.net/2024/03/27/ivgBHx8PJ3YMq5o.png" alt="image-20240327135823086"></p>
<p>还得是ai,提供的效率真的nb</p>
<p>1.controller先调用服务的方法:</p>
<p><img src="https://s2.loli.net/2024/03/27/cy3bWXfA4T2eJEd.png" alt="image-20240327145310042"></p>
<p>然后在service中写实际的保存逻辑.</p>
<p><img src="https://s2.loli.net/2024/03/27/yurKFovaweIpkgT.png" alt="image-20240327145352288"></p>
<p>最后在mapper中实现具体的逻辑:</p>
<p><img src="https://s2.loli.net/2024/03/27/knMVSPp1cJe2sb5.png" alt="image-20240327145521213"></p>
<p>Java中的token校验:</p>
<p><img src="https://s2.loli.net/2024/03/27/v5UxoRV6srG7mX2.png" alt="image-20240327200153409"></p>
<p>按照这里的配置项进行的令牌获取:</p>
<p><img src="https://s2.loli.net/2024/03/27/ZPe6AkgEuycxfrR.png" alt="image-20240327201137461"></p>
<p>所以请求头:里面也要附带上这个参数:</p>
<p><img src="https://s2.loli.net/2024/03/27/mc3YdB1lReGnv7N.png" alt="image-20240327201216969"></p>
<p>代码存在的问题:</p>
<p><img src="https://s2.loli.net/2024/03/27/KH1m3sqyubDeAIE.png" alt="image-20240327203033092"></p>
<p>就是ID和数据库在用户名重名的时候抛出了异常.这都是我自己要学习的,但是首先保证学校课程的学习吧.</p>
<p>首先保证学分绩.</p>
<p>异常处理:</p>
<p>通过spilt函数,将空格放进去,然后根据空格把字符串搞成字符串数组.</p>
<p>此时的用户名就是第三个,下标去取就是split[2],然后直接拼接字符串即可.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ar = <span class="string">&quot;i love you&quot;</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">ar.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">(<span class="number">3</span>) [<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;you&#x27;</span>]<span class="comment">//java和js其实差不多.</span></span><br></pre></td></tr></table></figure>

<p>在全局的异常处理类中,直接重载异常处理器:</p>
<p><img src="https://s2.loli.net/2024/03/27/SqBfO8Zb6mCHLcw.png" alt="image-20240327211309247"></p>
<p>以后写笔记,只看代码开发视频.</p>
<p>动态获取当前登录员工的id:</p>
<p><img src="https://s2.loli.net/2024/03/27/8J4tkqY1Ul2rWwf.png" alt="image-20240327211506131"></p>
<p><img src="https://s2.loli.net/2024/03/27/lcWEOki2M9sCGHz.png" alt="image-20240327212035245"></p>
<p>因为创建的时候使用的:</p>
<p><img src="https://s2.loli.net/2024/03/27/7cCvOymgjaQLGxZ.png" alt="image-20240327212050930"></p>
<p>这里这个常量的值为:<img src="https://s2.loli.net/2024/03/27/tHehOwYSmJDlMTc.png" alt="image-20240327212113491"></p>
<p>其实这个map就是<code>&#123;empId:实际用户的id&#125;</code></p>
<p>然后到时候直接解码出来这个claims键值对即可.</p>
<p><img src="https://s2.loli.net/2024/03/27/PZ8c9yhAKLwkEWj.png" alt="image-20240327212414455"></p>
<p>引出<code>threadLocal</code></p>
<p>在java的Spring框架中,客户端发起的每一次请求,都对应单独一个线程.</p>
<p>这里是分别在jwt拦截器,service,contraller分别进行了id的打印.</p>
<p><img src="https://s2.loli.net/2024/03/27/JrH3agXlUQ1Nh2p.png" alt="image-20240327212902630"></p>
<p>使用ThreadLocal即可共享同一份线程的数据.</p>
<p>使用封装好的工具类:</p>
<p><img src="https://s2.loli.net/2024/03/27/7URAvCTtzxjoIqc.png" alt="image-20240327213243347"></p>
<h5 id="员工分页查询"><a href="#员工分页查询" class="headerlink" title="员工分页查询"></a>员工分页查询</h5><p><img src="https://s2.loli.net/2024/03/28/cLpeG1vMFTUwth3.png" alt="image-20240328192128553"></p>
<p>总共85个项目:</p>
<p>Query参数,通过浏览器的地址栏:<code>?方式</code>传递数据.</p>
<p>接口设计:<img src="https://s2.loli.net/2024/03/28/TVUAuo3PfGXQLDc.png" alt="image-20240328192112205"></p>
<p>代码:</p>
<p>根据请求参数设计DTO(数据传输对象,传递前端发过来的数据.) </p>
<p><img src="https://s2.loli.net/2024/03/28/XLy3IPeHEpo4hbv.png" alt="image-20240328192338435"></p>
<p><img src="https://s2.loli.net/2024/03/28/MC31pOdtqbYeVyD.png" alt="image-20240328192550093"></p>
<p>如果是query类型的参数,直接通过:</p>
<p><img src="https://s2.loli.net/2024/03/28/TZK5cLyHzFQxnBA.png" alt="image-20240328192808807"></p>
<p>声明就可以得到query了.不用<code>@RequestBody</code></p>
<p>插件自动化进行sql语句的拼接:<img src="https://s2.loli.net/2024/03/28/E7HYnMl9bzOrokK.png" alt="image-20240328194853244"></p>
<p>相当于动态参数Limit:getPage和getPageSize.</p>
<p><img src="https://s2.loli.net/2024/03/28/c2RGNtOkzTv54fM.png" alt="image-20240328195046539"></p>
<p>最终完成版本:</p>
<p><img src="https://s2.loli.net/2024/03/28/AmzgQY169kopWnX.png" alt="image-20240328203253769"></p>
<p>其实还是插件的作用,这里的mapper是这样写的,还得学习mybatis.</p>
<p><img src="https://s2.loli.net/2024/03/28/HzTYqSMaVy4l7Lg.png" alt="image-20240328203343544"></p>
<p>这段代码是一个 MyBatis 的 SQL 查询语句，用于在数据库表 <code>sky_take_out.employee</code> 中根据条件查询员工信息，并按照创建时间倒序排列。</p>
<ul>
<li><code>&lt;select&gt;</code> 标签定义了一个查询语句，该语句对应的结果类型为 <code>com.sky.entity.Employee</code>。</li>
<li><code>select * from sky_take_out.employee</code>：这部分是 SQL 查询语句的主体，用于选择所有员工信息。</li>
<li><code>&lt;where&gt;</code> 标签标识了条件语句的开始。</li>
<li><code>&lt;if&gt;</code> 标签用于根据条件判断是否添加特定的查询条件。在这里，如果传入的 <code>name</code> 参数不为 <code>null</code> 且不为空字符串，则添加一个按照名字模糊查询的条件。<ul>
<li><code>and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)</code>：这部分是条件语句，表示如果 <code>name</code> 参数不为空，则添加一个条件，通过 <code>like</code> 进行模糊匹配查询，查询名字中包含传入参数 <code>name</code> 的员工信息。</li>
</ul>
</li>
<li><code>&lt;/where&gt;</code> 标签标识了条件语句的结束。</li>
<li><code>order by create_time desc</code>：这部分表示根据 <code>create_time</code> 字段进行倒序排列，即最新创建的记录排在前面。</li>
</ul>
<p>看下插件的源码:</p>
<p><img src="https://s2.loli.net/2024/03/28/X95gsjrRIKq7Vkn.png" alt="image-20240328203612435"></p>
<p>这里设置这个pageHelper主要是查询分页,总体的数据量和分页查询几条数据</p>
<p><img src="https://s2.loli.net/2024/03/28/lNVaXW1ibqdvsG3.png" alt="image-20240328203716675"></p>
<p>然后在这个ThreadLocal中存入了配置的设置.</p>
<h6 id="日期问题"><a href="#日期问题" class="headerlink" title="日期问题:"></a>日期问题:</h6><p>​	因为日期返回给前端存在问题,所以出现了日期是这样的:<img src="https://s2.loli.net/2024/03/28/WL91hJACMUD8lpv.png" alt="image-20240328214645719"></p>
<p>返回给前端的日期数据是数组.</p>
<p><img src="https://s2.loli.net/2024/03/28/xvfLlFunh1JHbBj.png" alt="image-20240328214806930"></p>
<p>具体就是直接加入扩展的格式化处理即可.</p>
<p>如何给全局加入这个消息转换器?</p>
<p><code>直接继承这个配置父类即可</code><img src="https://s2.loli.net/2024/03/28/chbuVryD3fHkeoL.png" alt="image-20240328215032515"></p>
<p><img src="https://s2.loli.net/2024/03/28/ygmTvkcbrsAnHWU.png" alt="image-20240328215712011"></p>
<p>这里面的JacksonObjectMapper就是对象转换器,看下代码:</p>
<p><img src="https://s2.loli.net/2024/03/28/xPFAsXQ8DeufZ1c.png" alt="image-20240328220005393"></p>
<p>主要是注册一个partten,然后进行时间的转换.</p>
<p>调试代码就能看见确实加入了:<img src="https://s2.loli.net/2024/03/28/DlhKnmR94LU6wdE.png" alt="image-20240328220110446"></p>
<p>加入之后,根据那个日期格式化的模式,就可以使用Spring mvc的自动转换进行日期格式化了.</p>
<h5 id="员工禁用和启用"><a href="#员工禁用和启用" class="headerlink" title="员工禁用和启用:"></a>员工禁用和启用:</h5><p><img src="https://s2.loli.net/2024/03/29/71xoOWgCABUkKDu.png" alt="image-20240329150050936"></p>
<p>基本查询的时候才需要泛型,前端传过来的参数,如果是query,直接使用函数参数接收即可,如果是路径参数,使用注解接收..</p>
<p><img src="https://s2.loli.net/2024/03/29/KQwAYy2lu9zUshE.png" alt="image-20240329150755638"></p>
<p>这种中括号的东西就是路径参数..</p>
<p>一般是这样的逻辑:controller调用service接口,然后再实现这个接口的方法.</p>
<p>最终在Mapper里面去实现对数据库的操作.</p>
<p><img src="https://s2.loli.net/2024/03/29/tUT48iJ7uAVP95I.png" alt="image-20240329151452542"></p>
<p>在Mapper中调用动态SQL:</p>
<p><img src="https://s2.loli.net/2024/03/29/A7pUiqjOQwNH13S.png" alt="image-20240329152019617"></p>
<p>弹幕还是有点用的,没有安装扩展MybatisX就会看不到.</p>
<h3 id="分类管理模块"><a href="#分类管理模块" class="headerlink" title="分类管理模块"></a>分类管理模块</h3><p>具体为:删除时:需要判断是否删除菜品分类下的所有菜品.</p>
<p>简单的判断,还是访问数据库:</p>
<p><img src="https://s2.loli.net/2024/04/08/EBAr15CzpWynL8m.png" alt="image-20240408123730456"></p>
<p>​	公共的字段,重复创建了.</p>
<p>当数据表发生了变化,这些东西都要跟着去改.</p>
<p><img src="C:/Users/13205/AppData/Roaming/Typora/typora-user-images/image-20240408123921187.png" alt="image-20240408123921187"></p>
<p>定义注解,然后注册一个拦截器,使用拦截器把对这些公共字段赋值操作给统一起来.</p>
<p><img src="https://s2.loli.net/2024/04/08/9xdjOF8u6la3WvB.png" alt="image-20240408130753612"></p>
<p><strong>切入点</strong>:<code>说白了就是对哪些类的哪些方法进行拦截.</code></p>
<p>这里拦截规则问chatGPT即可.</p>
<p>前面表达式是锁定了map包下的所有类,然后后面的是锁定有AutoFIll这个注解. </p>
<p><strong>通知</strong>:<code>对代码进行增强的部分.</code></p>
<p><strong>链接点</strong>:<code>通过这个链接点可以获取别的程序得到的参数,然后直接就可以使用这个参数结果</code></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><img src="https://s2.loli.net/2024/04/09/qt5igG6heQ89FxJ.png" alt="image-20240409094223298"></p>
<p>使用阿里云的文件上传服务,然后直接使用这个注解,就会到这里自动查找</p>
<p><img src="https://s2.loli.net/2024/04/09/P3kuvVGfhjbLqDX.png" alt="image-20240409094329080"></p>
<p>这就是注解的作用</p>
<p>这里的配置还是使用引用的方式:<img src="https://s2.loli.net/2024/04/09/HEQaXNyZFoswTLY.png" alt="image-20240409094755581"></p>
<p>然后具体的配置项就是在配置的注解那里.</p>
<p><img src="https://s2.loli.net/2024/04/09/ntOvum7BsLMTFez.png" alt="image-20240409094823696"></p>
<h3 id="苍穹外卖中注解的作用"><a href="#苍穹外卖中注解的作用" class="headerlink" title="苍穹外卖中注解的作用:"></a>苍穹外卖中注解的作用:</h3><p>这四个注解在Java中通常用于不同的用途：</p>
<ol>
<li><code>@Data</code>: <code>@Data</code>注解是Lombok库提供的一个注解，它会自动为类生成一些通用的方法，例如<code>toString()</code>、<code>equals()</code>、<code>hashCode()</code>和<code>getter</code>、<code>setter</code>方法。通过在类上添加<code>@Data</code>注解，可以减少代码量，提高代码的可读性和简洁性。</li>
<li><code>@Builder</code>: <code>@Builder</code>注解同样来自于Lombok库，它可以帮助我们创建Builder模式的构造器。Builder模式可以让我们以一种更加流畅和易读的方式构建对象，尤其在对象拥有多个属性且部分属性是可选的情况下，使用Builder模式可以提高代码的可读性和灵活性。</li>
<li><code>@NoArgsConstructor</code>: <code>@NoArgsConstructor</code>注解同样是Lombok库提供的，它会为类生成一个无参的构造方法。在某些情况下，比如使用反射创建对象或者通过无参构造方法初始化对象时，会需要这样一个无参构造方法。</li>
<li><code>@AllArgsConstructor</code>: <code>@AllArgsConstructor</code>注解也来自于Lombok库，它会为类生成一个包含所有字段的构造方法。这个构造方法可以用于快速地创建对象，并且可以方便地在测试中初始化对象。</li>
</ol>
<p>Spring注解:</p>
<p>这段代码是一个Spring Boot中的控制器类（Controller），主要用于处理与员工（Employee）相关的HTTP请求。下面解释每个注解的作用： </p>
<ol>
<li><code>@RestController</code>：这个注解是Spring框架提供的，它将该类标记为一个RESTful风格的控制器，意味着该控制器中的方法会以JSON格式返回数据，而不是视图。相比于<code>@Controller</code>注解，<code>@RestController</code>注解省略了在每个方法上添加<code>@ResponseBody</code>的步骤，因此更为简洁方便。</li>
<li><code>@RequestMapping(&quot;/admin/employee&quot;)</code>：这个注解指定了处理HTTP请求的URL路径。在这个示例中，所有处理员工相关请求的方法的URL都以”&#x2F;admin&#x2F;employee”开头。通过这种方式，可以将相同类型的请求映射到同一个控制器中进行处理。</li>
<li><code>@Slf4j</code>：这是Lombok库提供的一个注解，用于自动生成日志对象。使用<code>@Slf4j</code>注解后，可以直接使用<code>log</code>对象进行日志记录，无需手动创建。</li>
<li><code>@Autowired</code>：这个注解是Spring框架提供的，用于自动装配（注入）依赖。在这个示例中，通过<code>@Autowired</code>注解，Spring会自动将<code>EmployeeService</code>和<code>JwtProperties</code>的实例注入到<code>EmployeeController</code>中，无需手动创建实例。</li>
<li><code>@PostMapping(&quot;/login&quot;)</code>和<code>@PostMapping(&quot;/logout&quot;)</code>：这是处理POST请求的方法。<code>@PostMapping</code>注解指定了处理POST请求的URL路径。在这个示例中，<code>login()</code>方法处理”&#x2F;admin&#x2F;employee&#x2F;login”路径的POST请求，而<code>logout()</code>方法处理”&#x2F;admin&#x2F;employee&#x2F;logout”路径的POST请求。</li>
<li><code>@RequestBody</code>：这个注解用于将HTTP请求的body部分转换为Java对象。在<code>login()</code>方法中，<code>@RequestBody</code>注解将HTTP请求中的JSON数据转换为<code>EmployeeLoginDTO</code>对象。</li>
<li><code>@ResponseBody</code>：虽然代码中没有显式使用<code>@ResponseBody</code>注解，但是由于<code>@RestController</code>注解的存在，所有返回的对象都会被自动转换为JSON格式并返回给客户端。</li>
</ol>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h1 id="部署服创后端项目"><a href="#部署服创后端项目" class="headerlink" title="部署服创后端项目"></a>部署服创后端项目</h1><h2 id="1-安装nodejs"><a href="#1-安装nodejs" class="headerlink" title="1.安装nodejs"></a>1.安装nodejs</h2><p><a href="https://github.com/nodesource/distributions">nodesource&#x2F;distributions: NodeSource Node.js Binary Distributions (github.com)</a></p>
<h2 id="2-安装mongodb"><a href="#2-安装mongodb" class="headerlink" title="2.安装mongodb"></a>2.安装mongodb</h2><p><a href="https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/#std-label-install-mdb-community-ubuntu">Install MongoDB Community Edition on Ubuntu — MongoDB Manual</a></p>
<p>因为要使用副本集模式来使用prisma,则使用下面的教程即可</p>
<p>最好的安装教程就是官方文档</p>
<p><a href="https://www.mongodb.com/docs/manual/tutorial/convert-standalone-to-replica-set/">Convert a Standalone mongod to a Replica Set — MongoDB Manual</a></p>
<h2 id="3-安装redis"><a href="#3-安装redis" class="headerlink" title="3.安装redis"></a>3.安装redis</h2><p>要在 Linux 上安装 Redis，你可以按照以下步骤操作：</p>
<h3 id="方法一：使用包管理器安装（适用于基于-apt-的系统，如-Ubuntu）"><a href="#方法一：使用包管理器安装（适用于基于-apt-的系统，如-Ubuntu）" class="headerlink" title="方法一：使用包管理器安装（适用于基于 apt 的系统，如 Ubuntu）"></a>方法一：使用包管理器安装（适用于基于 apt 的系统，如 Ubuntu）</h3><ol>
<li><p><strong>更新包管理器缓存</strong>：<br>运行以下命令来确保你的包管理器的缓存已经更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装 Redis</strong>：<br>运行以下命令来安装 Redis：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动 Redis</strong>：<br>在安装完成后，Redis 将会自动启动。你可以通过以下命令来检查 Redis 的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status redis</span><br></pre></td></tr></table></figure>
<p>如果它没有自动启动，你可以使用以下命令手动启动 Redis：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start redis</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">redis-cli ping</span><br></pre></td></tr></table></figure>
<p>如果服务器正在运行，它将返回 <code>PONG</code>。</p>
</li>
</ol>
<p>然后安装yolo的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install flask</span><br><span class="line"></span><br><span class="line">pip install -r requirement.txt</span><br><span class="line"></span><br><span class="line">pip i ultralytics</span><br><span class="line"></span><br><span class="line">检测是否能够当服务器,先能安装torch</span><br></pre></td></tr></table></figure>

<h1 id="数据的流式获取-chatGPT"><a href="#数据的流式获取-chatGPT" class="headerlink" title="数据的流式获取(chatGPT)"></a>数据的流式获取(chatGPT)</h1><p><img src="https://s2.loli.net/2024/04/15/eE3HBnIJhl7WoaR.png" alt="image-20240415110644859"></p>
<p>这里的响应头是先发送过去,然后代码就执行完了,这个await是在等待响应头发送过去</p>
<p>下面的await是在等待服务器返回数据,等全部返回才把数据给你.</p>
<p>错误示范,不能等响应体全部完成.</p>
<p>正确示范:<img src="C:/Users/13205/AppData/Roaming/Typora/typora-user-images/image-20240415110822108.png" alt="image-20240415110822108"></p>
<p>此时的value是一个三个字符的数据,还需要decoder.</p>
<p>直接借助浏览器的API即可:</p>
<p><img src="https://s2.loli.net/2024/04/15/L4ZOjgRcq3pmV9D.png" alt="image-20240415110956847"></p>
<p>当我需要这个功能的时候,就需要学习对应的文档和知识了.</p>
<h1 id="Linux系统下切换到root用户的三种方法"><a href="#Linux系统下切换到root用户的三种方法" class="headerlink" title="Linux系统下切换到root用户的三种方法"></a>Linux系统下切换到root用户的三种方法</h1><ol>
<li>使用sudo命令<br>执行sudo命令后，输入当前管理员用户的密码，就可以短暂获得超级用户的权限。例如：<br>$ sudo echo ‘Hello, world!’<br>输入当前管理员用户的密码后，系统将执行指定的命令（在这个例子中是echo ‘Hello, world!’）。需要注意的是，使用sudo获得的权限是暂时的，默认情况下5分钟后root权限就失效了。</li>
<li>使用sudo -i命令<br>执行sudo -i命令后，输入当前管理员用户的密码，可以直接进入root用户。例如：<br>$ sudo -i<br>输入当前管理员用户的密码后，系统将切换到root用户，并打开一个新的终端会话。这个命令类似于执行su root命令，但是不需要手动输入root用户的密码。</li>
<li>使用su命令<br>如果想要一直使用root权限，可以通过su命令切换到root用户。首先，需要设置root用户的密码。例如：<br>$ sudo passwd root<br>按照提示输入新的root密码。设置完成后，就可以自由地切换到root用户了。例如：<br>$ su<br>输入root用户的密码后，系统将切换到root用户。如果想回到普通用户权限，直接执行exit命令即可。<br>需要注意的是，以上三种方法都需要当前管理员用户的权限。此外，作为超级用户，需要格外小心操作，以免对系统造成不必要的损害。在完成必要的操作后，应该及时退出root用户，恢复到普通用户身份。</li>
</ol>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="终端模式进入"><a href="#终端模式进入" class="headerlink" title="终端模式进入:"></a>终端模式进入:</h2><p><img src="https://s2.loli.net/2024/05/22/w134VQX8sujqyKT.png" alt="image-20240522152903960"></p>
<p>直接就是bash模式即可</p>
<h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名:"></a>配置别名:</h2><p><img src="https://s2.loli.net/2024/04/28/mYa1zSLNyij2BRv.png" alt="image-20240428213446959"></p>
<p>直接在这个文件内改即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_aliases </span><br></pre></td></tr></table></figure>

<p>然后这个文件是官方推荐的,非耦合:</p>
<p><img src="https://s2.loli.net/2024/04/28/4h6QZfR7CtbiH5n.png" alt="image-20240428213534852"></p>
<p>大概就是这样:</p>
<p>直接整就行了</p>
<p>目前我的~&#x2F;.bash_aliases 文件内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(root㉿DavidLi)-[/mnt/c/Users/13205]</span><br><span class="line">└─# cat ~/.bash_aliases</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">alias dps=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span><br><span class="line">alias dis=&#x27;docker images&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Source global definitions</span></span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">┌──(root㉿DavidLi)-[/mnt/c/Users/13205]</span><br><span class="line">└─# vim ~/.bash_aliases</span><br></pre></td></tr></table></figure>



<h2 id="docker部署wire-guerd"><a href="#docker部署wire-guerd" class="headerlink" title="docker部署wire-guerd"></a>docker部署wire-guerd</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdocker run -d \</span><br><span class="line">  --name=wg-easy \</span><br><span class="line">  -e WG_HOST=123.123.123.123 (🚨这里输入服务器的公网IP) \</span><br><span class="line">  -e PASSWORD=passwd123 (🚨这里输入你的密码) \</span><br><span class="line">  -e WG_DEFAULT_ADDRESS=10.0.8.x （🚨默认IP地址）\</span><br><span class="line">  -e WG_DEFAULT_DNS=114.114.114.114 （🚨默认DNS）\</span><br><span class="line">  -e WG_ALLOWED_IPS=10.0.8.0/24 （🚨允许连接的IP段）\</span><br><span class="line">  -e WG_PERSISTENT_KEEPALIVE=25 （🚨重连间隔）\</span><br><span class="line">  -v ~/.wg-easy:/etc/wireguard \</span><br><span class="line">  -p 51820:51820/udp \</span><br><span class="line">  -p 51821:51821/tcp \</span><br><span class="line">  --cap-add=NET_ADMIN \</span><br><span class="line">  --cap-add=SYS_MODULE \</span><br><span class="line">  --sysctl=&quot;net.ipv4.conf.all.src_valid_mark=1&quot; \</span><br><span class="line">  --sysctl=&quot;net.ipv4.ip_forward=1&quot; \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  weejewel/wg-easy</span><br></pre></td></tr></table></figure>

<p>直接使用本地端口映射docker端口即可.</p>
<h2 id="docker部署mysql"><a href="#docker部署mysql" class="headerlink" title="docker部署mysql"></a>docker部署mysql</h2><p><img src="https://s2.loli.net/2024/04/17/MvHOlsRQKXdpAES.png" alt="image-20240417201010040">zhiji</p>
<p>直接部署mysql到linux.</p>
<p>类似于下载下来一个绿色的免安装版本的软件</p>
<p>就是直接在docker环境里面把那些东西都配置好了.</p>
<p><img src="https://s2.loli.net/2024/04/17/HNWxnm32r7zAX9I.png" alt="image-20240417201322752"></p>
<p>在集群部署上面非常有优势</p>
<p>镜像下载一次可以多次启动.<img src="https://s2.loli.net/2024/04/17/bTJEdYVeoQqGwah.png" alt="image-20240417201507835"></p>
<p>最强大的一集.</p>
<h3 id="命令解读"><a href="#命令解读" class="headerlink" title="命令解读:"></a>命令解读:</h3><p>端口映射,这是我想了解的:</p>
<p>把mysql容器的端口映射到服务器里面的端口</p>
<p><img src="https://s2.loli.net/2024/04/17/9Bzqwe8YJDg7WUC.png" alt="image-20240417214023905"></p>
<p>docker会帮助我们把请求转发到这个容器里面.<code>前面的端口 -p 3307:3306</code></p>
<p>前面的<code>3307</code>是宿主机端口(服务器端口)</p>
<p><img src="https://s2.loli.net/2024/04/17/aJMCNZWEpIt64yz.png" alt="image-20240417213820666"></p>
<p>启动镜像<code>docker start opengauss</code></p>
<p>查看正在运行的镜像:<code>docker ps</code></p>
<p>就能直观的看见端口的映射了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">羡慕了,唉,只是我挑选的位置和没有努力罢了.</span><br><span class="line"></span><br><span class="line">写不出来好看的样式?</span><br><span class="line"></span><br><span class="line">只是没有了解罢了.</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2024/04/17/gxiR4p35Knz2YUP.png" alt="image-20240417214205206"></p>
<h2 id="docker基础-基本命令"><a href="#docker基础-基本命令" class="headerlink" title="docker基础(基本命令)"></a>docker基础(基本命令)</h2><p><img src="https://s2.loli.net/2024/04/17/XlpKZ3MExHtNSdn.png" alt="image-20240417222526794"></p>
<p>docker run 是创建并运行容器.</p>
<p>docker ps是process state这个意思.</p>
<p>基本的进入容器内部(把md打开在vscode就可以借助ai去写笔记了但是没有图片上传)</p>
<p><code>docker exec -it &lt;container_name&gt; sh</code></p>
<p>解释:<code>docker exec -it &lt;container_name&gt; sh</code> 是一个用于在 Docker 容器内部执行命令的 Docker CLI 命令。</p>
<p>解释如下：</p>
<ul>
<li><code>docker exec</code>：这是 Docker 命令行工具用于在运行中的容器内部执行命令的子命令。</li>
<li><code>-it</code>：这是两个选项的组合。<code>-i</code> 表示在容器内部保持标准输入流（stdin）打开，<code>-t</code> 表示分配一个伪终端（tty）。这使得我们可以与容器交互式地执行命令，类似于在本地终端中执行命令。</li>
<li><code>&lt;container_name&gt;</code>：这是要执行命令的目标容器的名称或容器ID。指定容器的名称或ID将使命令在该容器内部执行。</li>
<li><code>sh</code>：这是要在容器内部执行的命令，此处是 <code>sh</code>，表示在容器内部运行 bash shell。您可以替换为其他需要在容器内执行的命令。</li>
</ul>
<p>总结起来，<code>docker exec -it &lt;container_name&gt; sh</code> 命令的作用是在指定的 Docker 容器内部启动一个交互式的终端 shell （bash），可以在该终端中运行命令，与容器进行交互，查看容器内部环境，进行调试等操作。</p>
<h3 id="拉取nginx的镜像"><a href="#拉取nginx的镜像" class="headerlink" title="拉取nginx的镜像:"></a>拉取nginx的镜像:</h3><p><a href="http://nginx.org/en/docs/beginners_guide.html#conf_structure">新手指南 — Beginner’s Guide (nginx.org)</a></p>
<p>nginx的新手指南,多看多学.(看官方文档绝对是学习最快的)</p>
<p><code>前提是你看的懂</code></p>
<p>调试使用:不停的打印日志:</p>
<p><img src="https://s2.loli.net/2024/04/17/Q2wAy9rzGDtxdp4.png" alt="image-20240417231425517"></p>
<p>使用bash进入:<code>docker exec -it nginx bash</code></p>
<p><img src="https://s2.loli.net/2024/04/17/tsO2PGQ3wLh9dDS.png" alt="image-20240417232052806"></p>
<p>配置别名:<img src="https://s2.loli.net/2024/04/17/GcJsfgrPYznqF8V.png" alt="image-20240417235634253"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># some more ls aliases</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> dis=<span class="string">&#x27;docker images&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后执行保存文件</p>
<p>然后<code>source ~/.bashrc</code>应用.</p>
<h2 id="docker数据卷"><a href="#docker数据卷" class="headerlink" title="docker数据卷"></a>docker数据卷</h2><p>volume:</p>
<p><img src="https://s2.loli.net/2024/04/18/b65XEvzDyqM7n9m.png" alt="image-20240418192534276"></p>
<p>你改这_data在容器就会同步更改</p>
<p>数据都会同步,目的是不在容器里面改文件</p>
<p>v-bind双向绑定,修改就直接那个啥,同步</p>
<p>当容器已经创建了,就没法挂载了.</p>
<p><img src="https://s2.loli.net/2024/04/18/fvBpNMdIOJRTwGX.png" alt="image-20240418194641711"></p>
<p><img src="https://s2.loli.net/2024/04/18/Kh1CVkjHNlz2gIJ.png" alt="image-20240418194854877"></p>
<p>直接在这看就行了,复制命令还是快</p>
<p>binlog mysql主从复制用的</p>
<p>当挂载在volume的时候,是固定的这种目录下</p>
<p>使用相对路径就直接识别为本地目录了:</p>
<h3 id="本地目录数据卷"><a href="#本地目录数据卷" class="headerlink" title="本地目录数据卷"></a>本地目录数据卷</h3><p><img src="C:/Users/13205/AppData/Roaming/Typora/typora-user-images/image-20240418204115907.png" alt="image-20240418204115907"></p>
<h2 id="docker部署java项目"><a href="#docker部署java项目" class="headerlink" title="docker部署java项目:"></a>docker部署java项目:</h2><p><img src="https://s2.loli.net/2024/04/28/h3TaZ6uG59FJSOC.png" alt="image-20240428184607709"></p>
<p><img src="https://s2.loli.net/2024/04/28/imMx7rfOGyKwDVF.png" alt="image-20240428184551592"></p>
<p><img src="https://s2.loli.net/2024/04/28/ntGs7wpxTbMNvFf.png" alt="image-20240428185029146"></p>
<p><img src="https://s2.loli.net/2024/04/28/J9N8My3rf5B72we.png" alt="image-20240428192711587"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t docker-demo .</span><br></pre></td></tr></table></figure>

<h2 id="容器网络通信"><a href="#容器网络通信" class="headerlink" title="容器网络通信"></a>容器网络通信</h2><p><img src="https://s2.loli.net/2024/04/28/CGO1VjXNPinS5sH.png" alt="image-20240428193259955"></p>
<p>具有相同的网关.Gateway</p>
<p>说明容器可以相互通信</p>
<p>前16位是不能动得,前两端不能动</p>
<p><img src="https://s2.loli.net/2024/04/28/oI8zG4DXyFOZc61.png" alt="image-20240428194004317"></p>
<p>“172.17.0.4”,前面的<code>172.17</code>不能动,但是后面的:<strong>.0.4</strong>会自增</p>
<p><img src="https://s2.loli.net/2024/04/28/gRtzqNXaCSJbTc3.png" alt="image-20240428194204400"></p>
<p>直接在容器内部ping另外的容器:</p>
<p><img src="https://s2.loli.net/2024/04/28/MU8xjPYXzLSTKlp.png" alt="image-20240428194314474"></p>
<p>但是这个ip是docker自己分配的,所以,当容器重启的时候,ip会改变,如何做到固定的容器通信?</p>
<p><strong>自定义网络</strong></p>
<p><img src="https://s2.loli.net/2024/04/28/eWQH5jryMKBNCZs.png" alt="image-20240428194435767"></p>
<p>创建一个新的网络:<code>heima</code>,然后让容器加入这个网络</p>
<p><img src="https://s2.loli.net/2024/04/28/cgiWZfPIkuapUCM.png" alt="image-20240428194851753"></p>
<p><img src="https://s2.loli.net/2024/04/28/Lim6TAdP8cIjkhr.png" alt="image-20240428194911771"></p>
<p>启动的时候就加入网络:</p>
<p><img src="https://s2.loli.net/2024/04/28/2mekVuKMfL47T8s.png" alt="image-20240428195012622"></p>
<p><img src="https://s2.loli.net/2024/04/28/i2UrDHA3SLEPsFo.png" alt="image-20240428195708052"></p>
<p>先创建网络:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create heima</span><br></pre></td></tr></table></figure>

<p>在直接加入网络:</p>
<p><code>docker network connect heima alist</code></p>
<p><code>docker network connect heima dd</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">└─# docker network connect --help</span><br><span class="line"></span><br><span class="line">Usage:  docker network connect [OPTIONS] NETWORK CONTAINER</span><br><span class="line"></span><br><span class="line">Connect a container to a network</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --alias strings           Add network-scoped alias for the container</span><br><span class="line">      --driver-opt strings      driver options for the network</span><br><span class="line">      --ip string               IPv4 address (e.g., &quot;172.30.100.104&quot;)</span><br><span class="line">      --ip6 string              IPv6 address (e.g., &quot;2001:db8::33&quot;)</span><br><span class="line">      --link list               Add link to another container</span><br><span class="line">      --link-local-ip strings   Add a link-local address for the container</span><br></pre></td></tr></table></figure>

<h2 id="使用docker批量部署容器"><a href="#使用docker批量部署容器" class="headerlink" title="使用docker批量部署容器:"></a>使用docker批量部署容器:</h2><h2 id="3-3-DockerCompose"><a href="#3-3-DockerCompose" class="headerlink" title="3.3.DockerCompose"></a>3.3.DockerCompose</h2><p>大家可以看到，我们部署一个简单的java项目，其中包含3个容器：</p>
<ul>
<li>MySQL</li>
<li>Nginx</li>
<li>Java项目</li>
</ul>
<p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了。</p>
<p>而Docker Compose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p>
<h3 id="3-3-1-基本语法"><a href="#3-3-1-基本语法" class="headerlink" title="3.3.1.基本语法"></a>3.3.1.基本语法</h3><p>docker-compose.yml文件的基本语法可以参考官方文档：</p>
<p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p>
<p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数非常相似。</p>
<p>举例来说，用docker run部署MySQL的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network hmall</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure>

<p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure>

<p>对比如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>docker run 参数</strong></th>
<th align="left"><strong>docker compose 指令</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">–name</td>
<td align="left">container_name</td>
<td align="left">容器名称</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">ports</td>
<td align="left">端口映射</td>
</tr>
<tr>
<td align="left">-e</td>
<td align="left">environment</td>
<td align="left">环境变量</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">volumes</td>
<td align="left">数据卷配置</td>
</tr>
<tr>
<td align="left">–network</td>
<td align="left">networks</td>
<td align="left">网络</td>
</tr>
</tbody></table>
<p>明白了其中的对应关系，相信编写<code>docker-compose</code>文件应该难不倒大家。</p>
<p>黑马商城部署文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">  <span class="attr">hmall:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hmall</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hm-net</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">hm-net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hmall</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以部署项目了。常见的命令：</p>
<p><a href="https://docs.docker.com/compose/reference/">https://docs.docker.com/compose/reference/</a></p>
<p>基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure>

<p>其中，OPTIONS和COMMAND都是可选参数，比较常见的有：</p>
<table>
<thead>
<tr>
<th align="left"><strong>类型</strong></th>
<th align="left"><strong>参数或指令</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Options</td>
<td align="left">-f</td>
<td align="left">指定compose文件的路径和名称</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Commands</td>
<td align="left">up</td>
<td align="left">创建并启动所有service容器</td>
</tr>
<tr>
<td align="left">down</td>
<td align="left">停止并移除所有容器、网络</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ps</td>
<td align="left">列出所有启动的容器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">logs</td>
<td align="left">查看指定容器的日志</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">stop</td>
<td align="left">停止容器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">start</td>
<td align="left">启动容器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">restart</td>
<td align="left">重启容器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">top</td>
<td align="left">查看运行的进程</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">exec</td>
<td align="left">在指定的运行中容器中执行命令</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>教学演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除hmall镜像</span></span><br><span class="line">docker rmi hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动所有, -d 参数是后台启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY hm-service.jar /app.jar                                           0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root-hmall                                           0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network hmall    Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container hmall  Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER           REPOSITORY          TAG                 IMAGE ID            SIZE</span><br><span class="line">hmall               root-hmall          latest              32eebee16acd        362MB</span><br><span class="line">mysql               mysql               latest              3218b38490ce        516MB</span><br><span class="line">nginx               nginx               latest              605c77e624dd        141MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">NAME                IMAGE               COMMAND                  SERVICE             CREATED             STATUS              PORTS</span><br><span class="line">hmall               root-hmall          <span class="string">&quot;java -jar /app.jar&quot;</span>     hmall               54 seconds ago      Up 52 seconds       0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp</span><br><span class="line">mysql               mysql               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   mysql               54 seconds ago      Up 53 seconds       0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp</span><br><span class="line">nginx               nginx               <span class="string">&quot;/docker-entrypoint.…&quot;</span>   nginx               54 seconds ago      Up 52 seconds       80/tcp, 0.0.0.0:18080-18081-&gt;18080-18081/tcp, :::18080-18081-&gt;18080-18081/tcp</span><br></pre></td></tr></table></figure>

<p>打开浏览器，访问：http:&#x2F;&#x2F;${你的虚拟机ip}:8080</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><a href="https://www.bilibili.com/read/cv27497248/?jump_opus=1">计算机网络视频问题回答 - 哔哩哔哩 (bilibili.com)</a></p>
<h1 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h1><h2 id="项目起步"><a href="#项目起步" class="headerlink" title="项目起步"></a>项目起步</h2><h3 id="使用session实现登录"><a href="#使用session实现登录" class="headerlink" title="使用session实现登录"></a>使用session实现登录</h3><p><img src="https://s2.loli.net/2024/04/21/cjFv1feQxB8suT9.png" alt="image-20240421211018548"></p>
<h3 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证:"></a>登录验证:</h3><p><img src="https://s2.loli.net/2024/04/22/CgLREZhN7lzJ6ye.png" alt="image-20240422115117043"></p>
<p>经典存储到ThreadLocal里面</p>
<h3 id="存储验证码到Redis"><a href="#存储验证码到Redis" class="headerlink" title="存储验证码到Redis"></a>存储验证码到Redis</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br></pre></td></tr></table></figure>



<p>这段代码是在Java中使用Spring框架进行依赖注入的一个例子。</p>
<p><code>@Resource</code> 是Java的一个注解，用于在没有明确指定bean名称的情况下，按名称或类型自动装配bean。在这个例子中，它告诉Spring框架自动注入一个类型为<code>StringRedisTemplate</code>的bean到<code>stringRedisTemplate</code>字段。</p>
<p><code>StringRedisTemplate</code> 是Spring Data Redis模块的一部分，它是一个帮助类，用于简化Redis数据访问的操作。它提供了一系列的方法来执行Redis命令，包括对字符串、哈希、列表、集合等数据类型的操作。</p>
<p><code>private</code> 关键字表示这个字段只能在当前类中访问。</p>
<p>总的来说，这段代码的意思是：在当前类中创建一个私有字段<code>stringRedisTemplate</code>，并请求Spring框架自动注入一个类型为<code>StringRedisTemplate</code>的bean。</p>
<h2 id="Redis使用"><a href="#Redis使用" class="headerlink" title="Redis使用:"></a>Redis使用:</h2><p><img src="https://s2.loli.net/2024/04/23/vmxH7oJ5wKiAVSY.png" alt="image-20240423225711169"></p>
<p>也是一块内存空间</p>
<p>Redis的读写速度非常快,一般是ms级别,而且数据库中也存在缓存</p>
<p>CPU中三级缓存</p>
<p>如果请求不大的话,暂时用不到缓存了:</p>
<p><img src="https://s2.loli.net/2024/04/23/heEGDCi78qMr1Qs.png" alt="image-20240423230128101"></p>
<p><a href="https://blog.csdn.net/weixin_61341342/article/details/133840026">【Redis】Java Spring操作redis-CSDN博客</a></p>
<p>常量类的使用:</p>
<p><a href="https://blog.csdn.net/jh1141233305/article/details/121171142">Intellij IDEA 保存时自动格式化代码_idea代码自动格式化-CSDN博客</a></p>
<p><img src="https://s2.loli.net/2024/04/23/PbE3m42Kri1SgMX.png" alt="image-20240423230506160"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConstants</span> &#123;</span><br><span class="line">    <span class="comment">//经典常量类,然后避免硬编码,确实是一个好的编程习惯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_CODE_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:code:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_CODE_TTL</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_USER_KEY</span> <span class="operator">=</span> <span class="string">&quot;login:token:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOGIN_USER_TTL</span> <span class="operator">=</span> <span class="number">36000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">CACHE_NULL_TTL</span> <span class="operator">=</span> <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">CACHE_SHOP_TTL</span> <span class="operator">=</span> <span class="number">30L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CACHE_SHOP_KEY</span> <span class="operator">=</span> <span class="string">&quot;cache:shop:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_SHOP_KEY</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">LOCK_SHOP_TTL</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECKILL_STOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;seckill:stock:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BLOG_LIKED_KEY</span> <span class="operator">=</span> <span class="string">&quot;blog:liked:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FEED_KEY</span> <span class="operator">=</span> <span class="string">&quot;feed:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHOP_GEO_KEY</span> <span class="operator">=</span> <span class="string">&quot;shop:geo:&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_SIGN_KEY</span> <span class="operator">=</span> <span class="string">&quot;sign:&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="短信缓存登录"><a href="#短信缓存登录" class="headerlink" title="短信缓存登录"></a>短信缓存登录</h3><p>当用户不断访问我这个接口,我就刷新有效期,放到拦截器实现</p>
<p><img src="https://s2.loli.net/2024/04/26/3jPoXAqRKrsaIB1.png" alt="image-20240426144115927"></p>
<p>逻辑具体实现 </p>
<p>StringRedisTemplete要求的字段类型都是string ,而此时转过来的是long id类型,所以,必须转换成String.</p>
<p>最终存储到数据库中的样子:</p>
<p><img src="https://s2.loli.net/2024/04/26/ybgjPsdx9AqUQB6.png" alt="image-20240426215715641"></p>
<p>最终的逻辑流程图:</p>
<p><img src="https://s2.loli.net/2024/04/26/XvsuqY1HGObULER.png" alt="image-20240426221151505"></p>
<p>这里的key一个选择phone作为key</p>
<p>一个选择随机生成的字符串为token.</p>
<p><img src="https://s2.loli.net/2024/04/26/WB6a75zMNO1oVXF.png" alt="image-20240426221249669"></p>
<p>比如<code>对象结构</code>就可以使用hash结构存储,嘻嘻&#x2F;</p>
<p>存储粒度的意思就是,一个是<img src="https://s2.loli.net/2024/04/26/LeCRsrSON31UJhK.png" alt="image-20240426221433325"></p>
<p>一个是这么多:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手机号码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码，加密存储</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 昵称，默认是随机字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户头像</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">icon</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信息存储的密度就是存储粒度,直接存少一点,把颗粒度降低一些.</p>
<h3 id="解决状态登录刷新"><a href="#解决状态登录刷新" class="headerlink" title="解决状态登录刷新"></a>解决状态登录刷新</h3><p>在原有的逻辑基础上</p>
<p>抽象出来一个新的拦截器,然后在这个拦截器上面做用户token的刷新.</p>
<p><img src="https://s2.loli.net/2024/04/26/SRPtvUchTqW4ayg.png" alt="image-20240426223538869"></p>
<h3 id="商户信息添加缓存"><a href="#商户信息添加缓存" class="headerlink" title="商户信息添加缓存:"></a>商户信息添加缓存:</h3><p>先在java代码里面找contraller </p>
<p>具体的查询逻辑:</p>
<p><img src="https://s2.loli.net/2024/04/26/spvEhJfY14gu3l6.png" alt="image-20240426225656041"></p>
<p><img src="https://s2.loli.net/2024/04/26/xM4vjkDQy6CP38S.png" alt="image-20240426225754485"></p>
<p>controller负责调用service的代码,具体的业务流程放到shopService里面</p>
<p>思路:先查缓存,缓存没有再查sql.<img src="https://s2.loli.net/2024/04/26/Zw6XAQdVeghfm4K.png" alt="image-20240426230527530"></p>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>ctrl+e </p>
<p>alt shift r</p>
<p>double shift</p>
<p>alt insert</p>
<p>.var</p>
<p>.sout</p>
<p>alt enter </p>
<h1 id="任务考核"><a href="#任务考核" class="headerlink" title="任务考核"></a>任务考核</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2><p>针对你的问题，我将分别进行详细解答：</p>
<p><strong>1.</strong> <em><strong>*接口的优化方式有哪些（具体说说，用代码写出来）*</strong></em></p>
<p><strong>2.</strong> <em><strong>*在修改语句（update）中根据字段行修改，是行锁还是表锁，为什么？在设计表的时候哪些细节？（写出sql语句）*</strong></em></p>
<p><strong>3.</strong> <em><strong>*设计消息表（类似qq消息，设计表结构，写出相应sql语句）*</strong></em></p>
<p><em><strong>*在期末之前，作为你们的考核*</strong></em></p>
<p><a href="https://cloud.tencent.com/developer/article/1850835">三分钟入门 InnoDB 存储引擎中的表锁和行锁-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a href="https://mikechen.cc/5018.html">MySQL悲观锁与乐观锁、行锁与表锁、共享锁 – mikechen</a></p>
<p>[什么是行锁或表锁 - Google 搜索](<a href="https://www.google.com/search?q=">https://www.google.com/search?q=</a> 什么是行锁或表锁&amp;sca_esv&#x3D;6a2cd9fc01b49543&amp;sca_upv&#x3D;1&amp;sxsrf&#x3D;ACQVn0-5SJnthgE6iVMSH5llUZ0CKpxV-w%3A1713881521508&amp;ei&#x3D;scEnZoPsHdiB2roP5YmOkAM&amp;ved&#x3D;0ahUKEwjDiJqawtiFAxXYgFYBHeWEAzIQ4dUDCBA&amp;uact&#x3D;5&amp;oq&#x3D; 什么是行锁或表锁&amp;gs_lp&#x3D;Egxnd3Mtd2l6LXNlcnAiGQrku4DkuYjmmK_ooYzplIHmiJbooajplIFIAFAAWABwAHgBkAEAmAEAoAEAqgEAuAEDyAEA-AEC-AEBmAIAoAIAmAMAkgcAoAcA&amp;sclient&#x3D;gws-wiz-serp)</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">好的，我会逐个回答您的问题，并提供相应的代码示例。</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 接口的优化方式</span><br><span class="line">接口优化通常关注几个主要方面：减少网络调用的次数和量、缓存机制的使用、并发处理、以及数据库查询优化等。</span><br><span class="line"></span><br><span class="line">示例代码：使用缓存来优化API</span><br><span class="line">以 Python Flask 应用为例，使用 Redis 缓存来减少数据库查询：</span><br><span class="line"></span><br><span class="line">python</span><br><span class="line">Copy code</span><br><span class="line">from flask import Flask, request</span><br><span class="line">import redis</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">app = Flask(<span class="strong">__name__</span>)</span><br><span class="line">cache = redis.Redis(host=&#x27;localhost&#x27;, port=6379, db=0)</span><br><span class="line"></span><br><span class="line">def get<span class="emphasis">_user_</span>from<span class="emphasis">_db(user_</span>id):</span><br><span class="line"><span class="code">    # 模拟数据库查询</span></span><br><span class="line"><span class="code">    return &#123;&quot;id&quot;: user_id, &quot;name&quot;: &quot;John Doe&quot;&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">@app.route(&#x27;/user/<span class="language-xml"><span class="tag">&lt;<span class="name">int:user_id</span>&gt;</span></span>&#x27;)</span><br><span class="line">def get<span class="emphasis">_user(user_</span>id):</span><br><span class="line"><span class="code">    user = cache.get(f&quot;user:&#123;user_id&#125;&quot;)</span></span><br><span class="line"><span class="code">    if not user:</span></span><br><span class="line"><span class="code">        user = get_user_from_db(user_id)</span></span><br><span class="line"><span class="code">        cache.setex(f&quot;user:&#123;user_id&#125;&quot;, 3600, json.dumps(user))  # 缓存1小时</span></span><br><span class="line"><span class="code">    else:</span></span><br><span class="line"><span class="code">        user = json.loads(user)</span></span><br><span class="line"><span class="code">    return user</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">if <span class="strong">__name__</span> == &#x27;<span class="strong">__main__</span>&#x27;:</span><br><span class="line"><span class="code">    app.run(debug=True)</span></span><br><span class="line"><span class="code">2. 修改语句中的锁定行为</span></span><br><span class="line"><span class="code">在 SQL 数据库中，是否使用行锁或表锁取决于数据库的类型以及其事务隔离级别。在 InnoDB 这样的行级锁定存储引擎中，UPDATE 语句通常使用行锁，因为它只锁定那些实际将被修改的记录。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">示例 SQL：优化表的设计，增加索引</span><br><span class="line">sql</span><br><span class="line">Copy code</span><br><span class="line">CREATE TABLE users (</span><br><span class="line"><span class="code">    id INT AUTO_INCREMENT PRIMARY KEY,</span></span><br><span class="line"><span class="code">    username VARCHAR(50),</span></span><br><span class="line"><span class="code">    email VARCHAR(50),</span></span><br><span class="line"><span class="code">    status TINYINT DEFAULT 1,</span></span><br><span class="line"><span class="code">    INDEX status_index (status)</span></span><br><span class="line"><span class="code">);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">-- 使用索引进行更新，可以更快地定位到具体的行</span><br><span class="line">UPDATE users SET status = 0 WHERE id = 123;</span><br><span class="line">这个例子中，给 status 字段添加索引可以帮助数据库更快地找到需要更新的行，尤其是在涉及到大量数据的查询中。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 设计消息表</span><br><span class="line">针对类似 QQ 的消息系统，我们需要考虑消息的发送方、接收方、内容、时间戳等信息。</span><br><span class="line"></span><br><span class="line">示例 SQL：创建消息表</span><br><span class="line">sql</span><br><span class="line">Copy code</span><br><span class="line">CREATE TABLE messages (</span><br><span class="line"><span class="code">    id BIGINT AUTO_INCREMENT PRIMARY KEY,</span></span><br><span class="line"><span class="code">    sender_id BIGINT NOT NULL,</span></span><br><span class="line"><span class="code">    receiver_id BIGINT NOT NULL,</span></span><br><span class="line"><span class="code">    message_text TEXT,</span></span><br><span class="line"><span class="code">    sent_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span></span><br><span class="line"><span class="code">    read_time TIMESTAMP NULL,</span></span><br><span class="line"><span class="code">    INDEX sender_index (sender_id),</span></span><br><span class="line"><span class="code">    INDEX receiver_index (receiver_id)</span></span><br><span class="line"><span class="code">);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">-- 外键示例，假设已经有一个users表</span><br><span class="line">ALTER TABLE messages</span><br><span class="line">ADD CONSTRAINT fk<span class="emphasis">_messages_</span>sender</span><br><span class="line">FOREIGN KEY (sender<span class="emphasis">_id) REFERENCES users(id),</span></span><br><span class="line"><span class="emphasis">ADD CONSTRAINT fk_</span>messages<span class="emphasis">_receiver</span></span><br><span class="line"><span class="emphasis">FOREIGN KEY (receiver_</span>id) REFERENCES users(id);</span><br><span class="line">这里，messages 表具备基本的字段，如发送者ID (sender<span class="emphasis">_id)、接收者ID (receiver_</span>id)、消息内容 (message<span class="emphasis">_text)、发送时间 (sent_</span>time) 和读取时间 (read<span class="emphasis">_time)。此外，添加了发送者和接收者的索引以优化查询性能，如果需要，还可以设置外键约束确保数据的完整性。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">以上就是对您的三个问题的回答和相应的代码示例。希望这些回答和代码能符合您的期望。如果您有任何其他问题或需要进一步的解释，请随时告诉我！</span></span><br></pre></td></tr></table></figure>



<h3 id="1-接口的优化方式"><a href="#1-接口的优化方式" class="headerlink" title="1. 接口的优化方式"></a>1. 接口的优化方式</h3><p>接口优化主要关注于提高响应速度和减少资源消耗，以下是一些常见的优化方法：</p>
<ul>
<li><p><strong>缓存机制</strong>：对于不频繁更改的数据，使用缓存来减少数据库访问次数。常用的缓存策略包括内存缓存（如 Redis）和应用级缓存。</p>
</li>
<li><p><strong>异步处理</strong>：对于耗时操作（如发送邮件、处理大量数据等），可以采用异步处理方式，提高接口的响应速度。</p>
</li>
<li><p><strong>减少数据传输量</strong>：通过压缩数据或减少不必要的数据传输，例如使用 gzip 压缩响应体，或精简返回的数据结构。</p>
</li>
<li><p><strong>接口分页</strong>：对于大量数据的查询，使用分页技术，减少单次请求处理的数据量。</p>
</li>
<li><p><strong>负载均衡</strong>：使用负载均衡技术分散请求到多个服务器，以平衡系统负载。</p>
</li>
<li><p><strong>数据库优化</strong>：包括合理设计索引、优化查询语句、使用合适的事务隔离级别等。</p>
</li>
<li><p><strong>限流与熔断</strong>：通过限流防止接口被过度调用，熔断则在下游服务不可用时保护系统。</p>
</li>
</ul>
<h3 id="2-修改语句的锁选择与数据库表设计细节"><a href="#2-修改语句的锁选择与数据库表设计细节" class="headerlink" title="2. 修改语句的锁选择与数据库表设计细节"></a>2. 修改语句的锁选择与数据库表设计细节</h3><ul>
<li><p><strong>锁的选择（行锁还是表锁）</strong>：</p>
<ul>
<li><strong>行锁</strong>：适用于访问量大但单次访问涉及数据量小的情况。行锁可以减少锁竞争，提高并发性。</li>
<li><strong>表锁</strong>：适用于单次访问涉及大量数据或全表操作的场景。表锁简单但会显著影响并发性。</li>
</ul>
</li>
<li><p><strong>设计表时的数据库细节</strong>：</p>
<ul>
<li><strong>合理使用索引</strong>：索引可以加快查询速度，但应避免过度索引，因为索引会增加写操作的成本。</li>
<li><strong>规范数据类型</strong>：选择合适的数据类型可以减少存储空间并提高处理速度。</li>
<li><strong>避免冗余</strong>：减少数据冗余可以提高数据一致性，但在某些情况下适当的冗余可以提高查询性能。</li>
<li><strong>使用外键与约束</strong>：确保数据完整性和一致性。</li>
<li><strong>考虑分区和分表</strong>：对于非常大的表，可以考虑分区或分表来提高性能。</li>
</ul>
</li>
</ul>
<h3 id="3-设计消息表"><a href="#3-设计消息表" class="headerlink" title="3. 设计消息表"></a>3. 设计消息表</h3><p>设计一个消息表通常需要考虑以下字段：</p>
<ul>
<li><strong>ID</strong>：唯一标识符，通常为主键。</li>
<li><strong>SenderID</strong>：发送者的唯一标识符。</li>
<li><strong>ReceiverID</strong>：接收者的唯一标识符。</li>
<li><strong>MessageContent</strong>：消息内容。</li>
<li><strong>Timestamp</strong>：消息发送的时间戳。</li>
<li><strong>Status</strong>：消息状态（如已读、未读）。</li>
<li><strong>MessageType</strong>：消息类型（如文本、图片）。</li>
</ul>
<p>示例 SQL 创建消息表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Messages (</span><br><span class="line">    MessageID <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    SenderID <span class="type">INT</span>,</span><br><span class="line">    ReceiverID <span class="type">INT</span>,</span><br><span class="line">    MessageContent TEXT,</span><br><span class="line">    <span class="type">Timestamp</span> DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    Status ENUM(<span class="string">&#x27;unread&#x27;</span>, <span class="string">&#x27;read&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;unread&#x27;</span>,</span><br><span class="line">    MessageType ENUM(<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;image&#x27;</span>, <span class="string">&#x27;video&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Messages</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_SenderID <span class="keyword">FOREIGN</span> KEY (SenderID) <span class="keyword">REFERENCES</span> Users(UserID),</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> FK_ReceiverID <span class="keyword">FOREIGN</span> KEY (ReceiverID) <span class="keyword">REFERENCES</span> Users(UserID);</span><br></pre></td></tr></table></figure>

<p>这个表结构设计旨在保证基本的消息传递功能，同时包括外键约束以确保参照完整性。</p>
<p>以上就是对你问题的详细解答，如果你有更</p>
<p>具体的场景或需要进一步的解析，请告诉我。</p>
<h1 id="实现二维码登录"><a href="#实现二维码登录" class="headerlink" title="实现二维码登录"></a>实现二维码登录</h1><h2 id="代码使用NODE"><a href="#代码使用NODE" class="headerlink" title="代码使用NODE"></a>代码使用NODE</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">学到的</span><br><span class="line"><span class="comment">// const qr = require(&quot;qrcode&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const generateQRCode = async (text, filePath) =&gt; &#123;</span></span><br><span class="line"><span class="comment">// 	try &#123;</span></span><br><span class="line"><span class="comment">// 		await qr.toFile(filePath, text);</span></span><br><span class="line"><span class="comment">// 		console.log(&quot;QR code generated successfully!&quot;);</span></span><br><span class="line"><span class="comment">// 	&#125; catch (error) &#123;</span></span><br><span class="line"><span class="comment">// 		console.error(&quot;Failed to generate QR code:&quot;, error);</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const text = &quot;Hello, world!&quot;;</span></span><br><span class="line"><span class="comment">// const filePath = &quot;./QRCODE/QRCode.png&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generateQRCode(text, filePath);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const uuid = require(&quot;uuid&quot;);</span></span><br><span class="line"><span class="comment">// let id = uuid.v4();</span></span><br><span class="line"><span class="comment">// console.log(&quot;In index.js id::: &quot;, id);</span></span><br><span class="line"><span class="comment">// 生成唯一的标识符.</span></span><br><span class="line"><span class="comment">// dd1fae6f-5d03-453a-a3ef-702b61a1b586</span></span><br><span class="line"><span class="comment">// e3b5929b-3f7a-4ba7-a196-221a38d32336</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取本机IPV4地址</span></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getIPv4</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> interfaces = os.<span class="title function_">networkInterfaces</span>();</span><br><span class="line">	<span class="comment">// console.log(&quot;In tests.js interfaces::: &quot;, interfaces);</span></span><br><span class="line">	<span class="keyword">let</span> ipv4Address = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> devName <span class="keyword">in</span> interfaces) &#123;</span><br><span class="line">		<span class="comment">// console.log(&quot;In tests.js devName::: &quot;, devName);</span></span><br><span class="line">		<span class="keyword">const</span> iface = interfaces[devName];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iface.<span class="property">length</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">const</span> alias = iface[i];</span><br><span class="line">			<span class="comment">// console.log(&quot;In tests.js alias::: &quot;, alias);</span></span><br><span class="line">			<span class="keyword">if</span> (</span><br><span class="line">				alias.<span class="property">family</span> === <span class="string">&quot;IPv4&quot;</span> &amp;&amp;</span><br><span class="line">				alias.<span class="property">address</span> !== <span class="string">&quot;127.0.0.1&quot;</span> &amp;&amp;</span><br><span class="line">				!alias.<span class="property">internal</span></span><br><span class="line">			) &#123;</span><br><span class="line">				ipv4Address = alias.<span class="property">address</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipv4Address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;本机的IPv4地址是:&quot;</span>, <span class="title function_">getIPv4</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后端示例代码</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>); <span class="comment">// 引入Express框架</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">QRCode</span> = <span class="built_in">require</span>(<span class="string">&quot;qrcode&quot;</span>); <span class="comment">// 引入生成二维码的库</span></span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">&quot;uuid&quot;</span>); <span class="comment">// 引入生成唯一标识符的库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>(); <span class="comment">// 创建Express应用实例</span></span><br><span class="line"><span class="keyword">const</span> loginDb = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 创建临时登录数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成二维码</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/qrcode&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> loginId = uuid.<span class="title function_">v4</span>(); <span class="comment">// 生成唯一的登录ID</span></span><br><span class="line">	loginDb.<span class="title function_">set</span>(loginId, &#123; <span class="attr">userId</span>: <span class="string">&quot;example_user&quot;</span>, <span class="attr">status</span>: <span class="string">&quot;pending&quot;</span> &#125;); <span class="comment">// 将登录ID和用户信息存入临时登录数据库</span></span><br><span class="line"></span><br><span class="line">	<span class="title class_">QRCode</span>.<span class="title function_">toDataURL</span>(<span class="string">`http://localhost:3000/login/<span class="subst">$&#123;loginId&#125;</span>`</span>, <span class="function">(<span class="params">err, url</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">//生成Base64格式的二维码,保存的信息是: http://localhost:3000/login/$&#123;loginId&#125;</span></span><br><span class="line">		<span class="keyword">if</span> (err) <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(err.<span class="property">message</span>); <span class="comment">// 如果生成二维码出错，返回500错误</span></span><br><span class="line">		res.<span class="title function_">json</span>(&#123; <span class="attr">qrcodeUrl</span>: url, loginId &#125;); <span class="comment">// 返回包含二维码URL和登录ID的JSON数据</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫码登录</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/login/:loginId&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> loginId = req.<span class="property">params</span>.<span class="property">loginId</span>; <span class="comment">// 获取登录ID</span></span><br><span class="line">	<span class="keyword">const</span> loginData = loginDb.<span class="title function_">get</span>(loginId); <span class="comment">// 从临时登录数据库中获取登录信息</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!loginData) &#123;</span><br><span class="line">		<span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">send</span>(<span class="string">&quot;Invalid login ID&quot;</span>); <span class="comment">// 如果登录ID无效，返回404错误</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	loginData.<span class="property">status</span> = <span class="string">&quot;scanned&quot;</span>; <span class="comment">// 更新登录状态为已扫码</span></span><br><span class="line">	loginDb.<span class="title function_">set</span>(loginId, loginData); <span class="comment">// 更新临时登录数据库中的登录信息</span></span><br><span class="line">	res.<span class="title function_">send</span>(<span class="string">&quot;Login successful&quot;</span>); <span class="comment">// 返回登录成功消息</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询登录状态</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/poll/:loginId&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> loginId = req.<span class="property">params</span>.<span class="property">loginId</span>; <span class="comment">// 获取登录ID</span></span><br><span class="line">	<span class="keyword">const</span> loginData = loginDb.<span class="title function_">get</span>(loginId); <span class="comment">// 从临时登录数据库中获取登录信息</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!loginData) &#123;</span><br><span class="line">		<span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">send</span>(<span class="string">&quot;Invalid login ID&quot;</span>); <span class="comment">// 如果登录ID无效，返回404错误</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res.<span class="title function_">json</span>(loginData); <span class="comment">// 返回包含登录信息的JSON数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Server started on port 3000&quot;</span>); <span class="comment">// 启动服务器，监听3000端口</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="生成唯一标识符-nodejs"><a href="#生成唯一标识符-nodejs" class="headerlink" title="生成唯一标识符(nodejs)"></a>生成唯一标识符(nodejs)</h2><p><img src="https://s2.loli.net/2024/04/22/AbSRHlrEwgY1GBs.png" alt="image-20240422111250433"></p>
<p><img src="https://s2.loli.net/2024/04/22/zh6blU4dwRog7Fn.png" alt="image-20240422111304579"></p>
<p><code>展示二维码的页面，如何在二维码被扫码后，自动触发登录跳转。 其实简单理解就是网页展示二维码之后，在后端存一个标记，然后不间断查看标记状态，而二维码是个网址，这个网址被访问后经过一系列检验登录，会修改标记状态。当展示二维码页面查看到标记更新后，就执行后面流程。</code></p>
<p><img src="https://s2.loli.net/2024/04/22/eDgYdE8PwhiMOF5.png" alt="image-20240422105048404"></p>
<p>等待扫描,扫描了但是没点登录,登录点击,完成逻辑.</p>
<p>客户端不断轮询,询问服务端,我的二维码有没有变</p>
<p><img src="https://s2.loli.net/2024/04/22/7nkGm9XPFKRiO4H.png" alt="image-20240422105216160"></p>
<p>临时token,验证用户身份,使用一次失效.</p>
<p>流程:<img src="https://s2.loli.net/2024/04/22/xJ4kYmor8G39Pu2.png" alt="image-20240422105348693"></p>
<p><img src="https://s2.loli.net/2024/04/22/fPq3CgQARNsFc6a.png" alt="image-20240422105642060"></p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>作为消息队列,充当大量请求的缓冲层.</p>
<p><img src="https://s2.loli.net/2024/04/26/5Ar8qJLKlB4sFQU.png" alt="image-20240426132253043"></p>
<p>每次提出新需求就开始修改之前的代码.</p>
<p>面向修改关闭</p>
<p>面向扩展开放</p>
<p>不知道的先学着,后面随着知识面的扩展,回过头看,就知道怎么学了,就看得懂了 </p>
<p>看视频确实轻松啊,知识也能学到,写一写笔记就行了.</p>
<p><img src="https://s2.loli.net/2024/04/26/jPNK8keD9ZfVhOX.png" alt="image-20240426134449603"></p>
<p>性能太差,各种服务累积执行,此时支付服务在等待,在等待CPU</p>
<p><img src="https://s2.loli.net/2024/04/26/2lOXmfxAerFZ6Dk.png" alt="image-20240426135034967"></p>
<p>把除了支付的那些服务全部变成异步调用,使用MessageQueue(消息队列)</p>
<p><img src="https://s2.loli.net/2024/04/26/iUSFRaEoZn49swM.png" alt="image-20240426135131079"></p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用:"></a>异步调用:</h3><p><img src="https://s2.loli.net/2024/04/26/YGhLMd6f2DBFT7y.png" alt="image-20240426142207198"></p>
<p><img src="https://s2.loli.net/2024/04/26/JOsYbFdVPx7Ktr6.png" alt="image-20240426142311309"></p>
<p>严格同步的保持原本代码,</p>
<p>但是<code>业务关联度</code>低的服务就直接发送消息到Broker,然后进行进程之间的解耦.</p>
<p>我的主进程<strong>支付服务</strong>直接发送完毕消息就继续执行我接下来的逻辑,然后其他三个接收到消息,就执行他们的逻辑,</p>
<p>运行相关的代码.</p>
<p><img src="https://s2.loli.net/2024/04/26/TezbQuo8hHYdvt3.png" alt="image-20240426142810861"></p>
<p>当流量突增,把这些数据的执行函数信号抽象成一条消息,然后缓存到消息队列里面,当我接受到消息,触发对应的逻辑,然后我再处理,起到流量整形的作用.拿不到对方进程的结果</p>
<p><img src="https://s2.loli.net/2024/04/26/e5dLXtQFlpOHIC4.png" alt="image-20240426143034150"></p>
<p><code>Broker:代理人,经纪人</code></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>根据您提供的 <code>employees</code> 数据库结构和常见的业务需求，我们可以为不同的用户角色设计合适的权限。在这个例子中，我们将定义三种角色：</p>
<ol>
<li><strong>薪资管理人员</strong>：能够访问 <code>salary</code> 表进行查看、更新和插入操作，还能查看 <code>employee</code> 表的信息。</li>
<li><strong>部门管理人员</strong>：能够管理部门信息、部门员工和部门经理的信息。</li>
<li><strong>HR管理人员</strong>：能够进行员工信息的全面管理，包括新增、修改和删除。</li>
</ol>
<h3 id="步骤-1-创建角色和用户"><a href="#步骤-1-创建角色和用户" class="headerlink" title="步骤 1: 创建角色和用户"></a>步骤 1: 创建角色和用户</h3><h4 id="创建薪资管理人员的角色和用户"><a href="#创建薪资管理人员的角色和用户" class="headerlink" title="创建薪资管理人员的角色和用户"></a>创建薪资管理人员的角色和用户</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE role_salary_manager NOLOGIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> <span class="keyword">TABLE</span> employees.salary <span class="keyword">TO</span> role_salary_manager;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">TABLE</span> employees.employee <span class="keyword">TO</span> role_salary_manager;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> salary_manager1 <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> salary_manager2 <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋予角色给用户</span></span><br><span class="line"><span class="keyword">GRANT</span> role_salary_manager <span class="keyword">TO</span> salary_manager1, salary_manager2;</span><br></pre></td></tr></table></figure>

<h4 id="创建部门管理人员的角色和用户"><a href="#创建部门管理人员的角色和用户" class="headerlink" title="创建部门管理人员的角色和用户"></a>创建部门管理人员的角色和用户</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE role_department_manager NOLOGIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">INSERT</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">TABLE</span> employees.department <span class="keyword">TO</span> role_department_manager;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">INSERT</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">TABLE</span> employees.department_employee <span class="keyword">TO</span> role_department_manager;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">INSERT</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">TABLE</span> employees.department_manager <span class="keyword">TO</span> role_department_manager;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> dept_manager <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋予角色给用户</span></span><br><span class="line"><span class="keyword">GRANT</span> role_department_manager <span class="keyword">TO</span> dept_manager;</span><br></pre></td></tr></table></figure>

<h4 id="创建HR管理人员的角色和用户"><a href="#创建HR管理人员的角色和用户" class="headerlink" title="创建HR管理人员的角色和用户"></a>创建HR管理人员的角色和用户</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建角色</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE role_hr_manager <span class="keyword">with</span> password &quot;tang@123&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> TABLES <span class="keyword">IN</span> SCHEMA employees <span class="keyword">TO</span> role_hr_manager;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE, <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">ALL</span> SEQUENCES <span class="keyword">IN</span> SCHEMA employees <span class="keyword">TO</span> role_hr_manager;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> hr_manager <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;tang@123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 赋予角色给用户</span></span><br><span class="line"><span class="keyword">GRANT</span> role_hr_manager <span class="keyword">TO</span> hr_manager;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-2-测试权限"><a href="#步骤-2-测试权限" class="headerlink" title="步骤 2: 测试权限"></a>步骤 2: 测试权限</h3><p>测试这些用户是否能正确执行它们应有的权限，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 测试薪资管理人员</span></span><br><span class="line"><span class="comment">-- 使用 salary_manager1 登录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.salary;</span><br><span class="line"><span class="keyword">UPDATE</span> employees.salary <span class="keyword">SET</span> amount <span class="operator">=</span> <span class="number">100000</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试部门管理人员</span></span><br><span class="line"><span class="comment">-- 使用 dept_manager 登录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.department;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees.department (dept_name) <span class="keyword">VALUES</span> (<span class="string">&#x27;New Dept&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试HR管理人员</span></span><br><span class="line"><span class="comment">-- 使用 hr_manager 登录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.employee;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees.employee <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">10010</span>;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-3-验证和调整"><a href="#步骤-3-验证和调整" class="headerlink" title="步骤 3: 验证和调整"></a>步骤 3: 验证和调整</h3><p>确保每个角色的权限符合组织的安全政策和业务需求。通过日常操作中的反馈和审计日志来调整权限配置。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这样的权限设置可以确保数据库的操作按照预定的业务逻辑进行，同时也能有效地分离职责，增加数据的安全性。通过详细的角色和权限设计，可以使数据库的管理更为规范和高效。</p>
<h1 id="WireGuard"><a href="#WireGuard" class="headerlink" title="WireGuard"></a>WireGuard</h1><p>是一种VPN技术,可以直接通过具有公网ip的服务器,实现内网穿透</p>
<p><img src="https://s2.loli.net/2024/04/28/61WwY9qnCaJhNe5.png" alt="image-20240428155455529"></p>
<p>早知道早早学docker了</p>
<p>让这些设备相互认为处于同一个内网.</p>
<p>是不区分服务端和客户端的,而是直接:<img src="C:/Users/13205/AppData/Roaming/Typora/typora-user-images/image-20240428160322287.png" alt="image-20240428160322287"></p>
<p>直接使用腾讯云的:</p>
<p><img src="https://s2.loli.net/2024/04/28/um3Gjv5hsNPzU7Q.png" alt="image-20240428160607129"></p>
<p><img src="https://s2.loli.net/2024/04/28/6SqL2eMPkyQZJjA.png" alt="image-20240428160620805"></p>
<p>在防火墙中只打开了部分的端口:</p>
<p><img src="https://s2.loli.net/2024/04/28/kVJCz6eKajEUQhN.png" alt="image-20240428160720535"></p>
]]></content>
  </entry>
  <entry>
    <title>链接校园网的JS脚本</title>
    <url>/post/566092e4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> fetch &#125; <span class="keyword">from</span> <span class="string">&quot;node-fetch&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> os <span class="keyword">from</span> <span class="string">&quot;os&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">URL</span> =</span><br><span class="line">	<span class="string">&quot;http://10.0.1.5:801/eportal/portal/login?callback=dr1003&amp;login_method=1&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">My</span>_account = <span class="string">&quot;your_account&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">My</span>_password = <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> address_last =</span><br><span class="line">	<span class="string">&quot;&amp;wlan_user_ipv6=&amp;wlan_user_mac=000000000000&amp;wlan_ac_ip=10.32.255.10&amp;wlan_ac_name=HJ-BRAS-ME60-01&amp;jsVersion=4.2&amp;terminal_type=1&amp;lang=zh-cn&amp;v=10063&amp;lang=zh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">WifiConnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> networkInterfaces = os.<span class="title function_">networkInterfaces</span>();</span><br><span class="line">		<span class="keyword">const</span> ip = networkInterfaces[<span class="string">&quot;wlan0&quot;</span>][<span class="number">0</span>].<span class="property">address</span>; <span class="comment">// Assuming &#x27;wlan0&#x27; is the interface for your local IP</span></span><br><span class="line">		<span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(</span><br><span class="line">			<span class="variable constant_">URL</span> +</span><br><span class="line">				<span class="string">`&amp;user_account=,0,<span class="subst">$&#123;My_account&#125;</span>&amp;user_password=<span class="subst">$&#123;My_password&#125;</span>&amp;wlan_user_ip=<span class="subst">$&#123;ip&#125;</span><span class="subst">$&#123;address_last&#125;</span>`</span></span><br><span class="line">		);</span><br><span class="line">		<span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应数据:&quot;</span>);</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">		<span class="keyword">if</span> (data) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;正在连接校园网&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请稍等...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag = <span class="title class_">WifiConnect</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体教程:	<a href="https://blog.csdn.net/m0_74349077/article/details/136997319">链接校园网的JS脚本</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/post/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="项目起步"><a href="#项目起步" class="headerlink" title="项目起步"></a>项目起步</h1><h2 id="elementUI主题色替换"><a href="#elementUI主题色替换" class="headerlink" title="elementUI主题色替换"></a>elementUI主题色替换</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath, <span class="variable constant_">URL</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;node:url&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-auto-import/vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span></span><br><span class="line"><span class="comment">// 导入对应包</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-element-plus/vite&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title class_">Components</span>(&#123;</span><br><span class="line">      <span class="attr">resolvers</span>: [</span><br><span class="line">          <span class="comment">//1.配置element-plus采用sass的样式配色系统</span></span><br><span class="line">          <span class="title class_">ElementPlusResolver</span>(&#123;<span class="attr">importStyle</span>: <span class="string">&#x27;sass&#x27;</span>&#125;)</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 按需定制主题配置</span></span><br><span class="line">    <span class="title class_">ElementPlus</span>(&#123;</span><br><span class="line">      <span class="attr">useSource</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="title function_">fileURLToPath</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./src&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">scss</span>: &#123;</span><br><span class="line">        <span class="comment">// 2.自动导入定制化样式文件进行样式默认覆盖</span></span><br><span class="line">        <span class="attr">additionalData</span>: <span class="string">`</span></span><br><span class="line"><span class="string">          @use &quot;@/styles/element/index.scss&quot; as *;</span></span><br><span class="line"><span class="string">          @use &quot;@/styles/var.scss&quot; as *;</span></span><br><span class="line"><span class="string">        `</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>重要</strong>:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625220544633.png" alt="image-20230625220544633"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625220614280.png" alt="image-20230625220614280"></p>
<h2 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625205639670.png" alt="image-20230625205639670"></p>
<p>放到<code>utils文件夹</code>,全局工具文件夹</p>
<p>测试该文件:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625205721774.png" alt="image-20230625205721774"></p>
<p>然后这个axios返回<strong>promise对象</strong></p>
<p>直接使用即可</p>
<h3 id="如果要配置多个实例"><a href="#如果要配置多个实例" class="headerlink" title="如果要配置多个实例"></a>如果要配置多个实例</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625210401771.png" alt="image-20230625210401771"></p>
<h2 id="pinia封装"><a href="#pinia封装" class="headerlink" title="pinia封装"></a>pinia封装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> store = <span class="title function_">useCounterStore</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; list &#125; = <span class="title function_">storeToRefs</span>(store);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; count, doubleCount &#125; = <span class="title function_">storeToRefs</span>(store);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; increment &#125; = store;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">change</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">​    store.$patch(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="comment">//只会存在不是计算属性和方法的东西</span></span><br><span class="line"></span><br><span class="line">​      <span class="comment">//也就是只放响应式数据</span></span><br><span class="line"></span><br><span class="line">​      state.<span class="property">count</span> += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听数据的变化</span></span><br><span class="line"></span><br><span class="line">  store.$subscribe(<span class="function">(<span class="params">args, state</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args&quot;</span>, args);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">​    store.<span class="title function_">loadList</span>();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625211313581.png" alt="image-20230625211313581"></p>
<p><strong>一级路由,就是主路由,最先渲染的路由</strong></p>
<p><code>二级路由</code>是<code>一级路由</code>的<code>子路由</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625212438382.png" alt="image-20230625212438382"></p>
<p>就是默认直接渲染,直接看代码</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625212849088.png" alt="image-20230625212849088"></p>
<h3 id="每一级路由都需要RouterView"><a href="#每一级路由都需要RouterView" class="headerlink" title="每一级路由都需要RouterView"></a>每一级路由都需要RouterView</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625213017659.png" alt="image-20230625213017659"></p>
<h2 id="配置初始化CSS"><a href="#配置初始化CSS" class="headerlink" title="配置初始化CSS"></a>配置初始化CSS</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625213738911.png" alt="image-20230625213738911"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625213716503.png" alt="image-20230625213716503"></p>
<h3 id="提供错误提醒的插件"><a href="#提供错误提醒的插件" class="headerlink" title="提供错误提醒的插件"></a>提供错误提醒的插件</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625213703751.png" alt="image-20230625213703751"></p>
<h3 id="scss的自动导入"><a href="#scss的自动导入" class="headerlink" title="scss的自动导入"></a>scss的自动导入</h3><p><code>手动导入</code><strong>太麻烦</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625214914598.png" alt="image-20230625214914598"></p>
<p>首先放到一个文件里面</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625215832941.png" alt="image-20230625215832941"></p>
<p>然后把这个文件放到vite.config.js里面即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625215901757.png" alt="image-20230625215901757"></p>
<h1 id="LayOut-布局"><a href="#LayOut-布局" class="headerlink" title="LayOut:布局"></a>LayOut:布局</h1><ol>
<li>拿到ui设计稿之后,先把页面拆分成几个大的模块</li>
<li><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625221126730.png" alt="image-20230625221126730"></li>
</ol>
<h2 id="就近维护原则"><a href="#就近维护原则" class="headerlink" title="就近维护原则"></a>就近维护原则</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625221319163.png" alt="image-20230625221319163"></p>
<p>在layout目录中新建compoents这个目录</p>
<p>在里面放入三个布局<code>组件</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625225841441.png" alt="image-20230625225841441"></p>
<h2 id="悬停显示内容的下拉框"><a href="#悬停显示内容的下拉框" class="headerlink" title="悬停显示内容的下拉框"></a>悬停显示内容的下拉框</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div class=&quot;dropdown&quot;&gt;</span><br><span class="line">            &lt;button class=&quot;dropbtn&quot;&gt;下拉菜单&lt;/button&gt;</span><br><span class="line">            &lt;div class=&quot;dropdown-content&quot;&gt;</span><br><span class="line">                &lt;a href=&quot;#&quot;&gt;链接 1&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;#&quot;&gt;链接 2&lt;/a&gt;</span><br><span class="line">                &lt;a href=&quot;#&quot;&gt;链接 3&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">/* 容器 &lt;div&gt; - 需要定位下拉内容 */</span><br><span class="line">.dropdown &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    display: inline-block;</span><br><span class="line"></span><br><span class="line">    /* 下拉按钮 */</span><br><span class="line">    .dropbtn &#123;</span><br><span class="line">        background-color: #4CAF50;</span><br><span class="line">        color: white;</span><br><span class="line">        padding: 16px;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">        border: none;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        /* 在整个dropdown这个容器的悬停时显示下拉菜单 */</span><br><span class="line"></span><br><span class="line">        .dropdown-content &#123;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 显示下拉内容时更改下拉按钮的背景颜色 */</span><br><span class="line"></span><br><span class="line">        .dropbtn &#123;</span><br><span class="line">            background-color: #3e8e41;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//悬停的内容默认是隐藏的</span><br><span class="line">    .dropdown-content &#123;</span><br><span class="line">        display: none;</span><br><span class="line">        position: absolute;</span><br><span class="line">        background-color: #f1f1f1;</span><br><span class="line">        min-width: 160px;</span><br><span class="line">        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);</span><br><span class="line">        z-index: 1;</span><br><span class="line"></span><br><span class="line">        a &#123;</span><br><span class="line">            color: black;</span><br><span class="line">            padding: 12px 16px;</span><br><span class="line">            text-decoration: none;</span><br><span class="line">            display: block;</span><br><span class="line"></span><br><span class="line">            &amp;:hover &#123;</span><br><span class="line">                background-color: #ddd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h2 id="导入字体图标"><a href="#导入字体图标" class="headerlink" title="导入字体图标"></a>导入字体图标</h2><p><code>在index.html中放入这个link</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625225909879.png" alt="image-20230625225909879"></p>
<p>然后直接使用此类格式<code>&lt;i class=&quot;iconfont icon-user&quot;&gt;&lt;/i&gt;</code></p>
<p>导入图标即可</p>
<h2 id="实现吸顶导航"><a href="#实现吸顶导航" class="headerlink" title="实现吸顶导航"></a>实现吸顶导航</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625233205925.png" alt="image-20230625233205925"></p>
<p><strong>关键样式</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230625233438983.png" alt="image-20230625233438983"></p>
<p>高度本来是top:0</p>
<p>现在还往上走了自己高度的1倍.</p>
<p>而且<code>opacity : 0;</code></p>
<p><code>结论</code></p>
<p>如果我想让其显示,添加<code>.show类名即可</code></p>
<h3 id="VUEUSE插件"><a href="#VUEUSE插件" class="headerlink" title="VUEUSE插件"></a>VUEUSE插件</h3><p><a href="http://www.vueusejs.com/guide/best-practice.html">最佳实践 | VueUse中文文档 (vueusejs.com)</a></p>
<p><a href="http://www.vueusejs.com/core/useScroll/">useScroll | VueUse中文文档 (vueusejs.com)</a></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627151618041.png" alt="image-20230627151618041"></p>
<p>使用这个插件,得到window的滚动位置和状态</p>
<p><strong>然后在滚动到相应位置的时候,让吸顶导航出现</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627153747595.png" alt="image-20230627153747595"></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627160743658.png" alt="image-20230627160743658"></p>
<p>得到<code>window</code>的滚动距离</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627160913620.png" alt="image-20230627160913620"></p>
<p>直接放入即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627160953911.png" alt="image-20230627160953911"></p>
<p>实时变化的高度</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627161005853.png" alt="image-20230627161005853"></p>
<h3 id="动态控制类名"><a href="#动态控制类名" class="headerlink" title="动态控制类名"></a>动态控制类名</h3><p>为了控制vue中的动态类名,将<code>class属性动态绑定::class=&quot;&#123;show : y&gt;78&#125;&quot;</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627161324808.png" alt="image-20230627161324808"></p>
<p>这行代码的意思是,<strong>show</strong>这个类名是否存在,取决于y是否&gt;78,或者<strong>true or false</strong></p>
<p>也就是前面是类名,后面是条件.</p>
<h5 id="数组形式"><a href="#数组形式" class="headerlink" title="数组形式:"></a>数组形式:</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627161515092.png" alt="image-20230627161515092"></p>
<h2 id="Pinia管理数据"><a href="#Pinia管理数据" class="headerlink" title="Pinia管理数据"></a>Pinia管理数据</h2><p>吸顶导航和原本的导航使用同一份数据</p>
<p>可以使用pinia仓库统一管理</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627162151416.png" alt="image-20230627162151416"></p>
<p>不然一次性发送两次请求耗费资源.</p>
<p>使用pinia存储数据,然后下发到LayOut父组件</p>
<p>**选择Layout父组件触发,然后由父组件分发数据 **</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627162550961.png" alt="image-20230627162550961"></p>
<p>此处因为都是<code>组合式API</code>,所以<strong>复制粘贴</strong>即可</p>
<p>体现出来使用同一体系代码的好处了,直接复制即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627162809690.png" alt="image-20230627162809690"></p>
<p>在父组件<strong>LayOut组件</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627163643720.png" alt="image-20230627163643720"></p>
<p>触发获取数据的函数</p>
<p><strong>在子组件中</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627163831966.png" alt="image-20230627163831966"></p>
<p>直接导入仓库,然后获取仓库实例</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627163851315.png" alt="image-20230627163851315"></p>
<p>直接访问仓库里的数据即可</p>
<h4 id="回顾总结"><a href="#回顾总结" class="headerlink" title="回顾总结"></a>回顾总结</h4><p>为什么优化?</p>
<ol>
<li>两次请求<code>优化成</code><strong>一次请求</strong></li>
<li>使用pinia统一管理数据比较方便</li>
<li><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627164123960.png" alt="image-20230627164123960"></li>
<li>把获取数据的函数放到父组件<strong>layout去触发</strong></li>
<li>然后把数据放到子组件使用</li>
</ol>
<h1 id="HOME组件"><a href="#HOME组件" class="headerlink" title="HOME组件"></a>HOME组件</h1><p>首先在写页面的时候,还是要抄一抄的,写的好就要copy</p>
<p>主要是拆分结构,拆分组件</p>
<h2 id="学习思路"><a href="#学习思路" class="headerlink" title="学习思路"></a>学习思路</h2><ol>
<li><p>学习设计的思路,先在views里面放入想让路由渲染的组件,然后分级</p>
</li>
<li><p>一级组件就是直接渲染的,二级就是一级的children</p>
</li>
<li><p>就近维护原则,直接创建Home文件夹,然后在里面创建index.vue</p>
</li>
<li><p>然后在Home文件夹里面创建components文件夹,然后在里面创建子组件</p>
</li>
<li><p>方便维护,就近维护原则</p>
</li>
</ol>
<h2 id="整体结构拆分"><a href="#整体结构拆分" class="headerlink" title="整体结构拆分"></a>整体结构拆分</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627180719758.png" alt="image-20230627180719758"></p>
<h3 id="就近维护原则-1"><a href="#就近维护原则-1" class="headerlink" title="就近维护原则"></a>就近维护原则</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627180845583.png" alt="image-20230627180845583"></p>
<p>在Home里面直接创建组件文件夹</p>
<p>然后创建五个子组件,分别编写相对应的逻辑</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627181200053.png" alt="image-20230627181200053"></p>
<h3 id="分类组件"><a href="#分类组件" class="headerlink" title="分类组件"></a>分类组件</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627181107418.png" alt="image-20230627181107418"></p>
<p><strong>还是category的数据,一样的使用,也就是后端返回的一份数据,前端都能拿来直接使用</strong></p>
<p><code>组件内容:</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627185447161.png" alt="image-20230627185447161"></p>
<p>显示效果:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627185511092.png" alt="image-20230627185511092"></p>
<h4 id="当列表渲染的时候"><a href="#当列表渲染的时候" class="headerlink" title="当列表渲染的时候"></a>当列表渲染的时候</h4><p>想快速渲染多个HTML元素,直接<code>v-for,然后item in 9</code>这就是<strong>渲染九个元素</strong></p>
<p>:key直接使用<code>item即可</code></p>
<p>然后</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627185721810.png" alt="image-20230627185721810"></p>
<p>像这样渲染5个元素即可</p>
<p>弹窗:layer设置的样式::</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627185806046.png" alt="image-20230627185806046"></p>
<p>典中典之狠狠的嵌套</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627185838913.png" alt="image-20230627185838913"></p>
<p><strong>这就是sass</strong></p>
<h4 id="关键样式"><a href="#关键样式" class="headerlink" title="关键样式"></a>关键样式</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627190152885.png" alt="image-20230627190152885"></p>
<h4 id="v-for的渲染范围"><a href="#v-for的渲染范围" class="headerlink" title="v-for的渲染范围"></a>v-for的渲染范围</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627193555790.png" alt="image-20230627193555790"></p>
<p>此处可以继续写item.children,说明v-for的作用范围是这个元素的所有子元素</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627193707377.png" alt="image-20230627193707377"></p>
<p>只要数组的前面两项:<code>调用slice方法即可</code></p>
<p>从0-2即可,然后v-for的第二级元素<code>i</code></p>
<p>根据模板语法,一个个替换即可,替换img的src属性记得使用动态绑定:<code>v-bind</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627194006541.png" alt="image-20230627194006541"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>还是将一个大模块拆分成一个个小组件,然后小组件一个个实现</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627180719758.png" alt="image-20230627180719758"></p>
<p>如图,拆分模块</p>
<p>最后后端返回的数据也是比较重要的,一堆数组就可以了,哈哈,狠狠的数组嵌套</p>
<p>然后最后在前端直接使用pinia统一管理即可.</p>
<h3 id="轮播图组件"><a href="#轮播图组件" class="headerlink" title="轮播图组件"></a>轮播图组件</h3><p>基本实现思路如图</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627195313637.png" alt="image-20230627195313637"></p>
<p>准备模板::</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;home-banner&quot;&gt;</span><br><span class="line">		&lt;el-carousel height=&quot;500px&quot;&gt;</span><br><span class="line">			&lt;el-carousel-item</span><br><span class="line">				v-for=&quot;item in 4&quot;</span><br><span class="line">				:key=&quot;item&quot;&gt;</span><br><span class="line">				&lt;img</span><br><span class="line">					src=&quot;http://yjy-xiaotuxian-dev.oss-cn-beijing.aliyuncs.com/picture/2021-04-15/6d202d8e-bb47-4f92-9523-f32ab65754f4.jpg&quot;</span><br><span class="line">					alt=&quot;&quot; /&gt;</span><br><span class="line">			&lt;/el-carousel-item&gt;</span><br><span class="line">		&lt;/el-carousel&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">	.home-banner &#123;</span><br><span class="line">		width: 1240px;</span><br><span class="line">		height: 500px;</span><br><span class="line">		position: absolute;</span><br><span class="line">		left: 0;</span><br><span class="line">		top: 0;</span><br><span class="line">		z-index: 98;</span><br><span class="line"></span><br><span class="line">		img &#123;</span><br><span class="line">			width: 100%;</span><br><span class="line">			height: 500px;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>还是直接使用ElementUI实现即可</p>
<p><a href="https://element-plus.org/zh-CN/component/carousel.html">Carousel 走马灯 | Element Plus (element-plus.org)</a></p>
<p><strong>接口文档</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627200252522.png" alt="image-20230627200252522"></p>
<p><strong>在apis这个文件夹封装好接口,模块化管理</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627200419766.png" alt="image-20230627200419766"></p>
<p>典中典之封装<code>async</code>和<code>await</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627200547254.png" alt="image-20230627200547254"></p>
<p>最后记得在组件挂载时调用函数</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627200620880.png" alt="image-20230627200620880"></p>
<h4 id="默认导出和按需导出的区别"><a href="#默认导出和按需导出的区别" class="headerlink" title="默认导出和按需导出的区别"></a>默认导出和按需导出的区别</h4><p><code>export</code>和<code>export default</code>的区别</p>
<p><strong>默认导入</strong></p>
<p>export default:默认导出</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627200755406.png" alt="image-20230627200755406"></p>
<p><strong>按需导入</strong></p>
<p>export:按需导出</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627200818351.png" alt="image-20230627200818351"></p>
<p>最终代码:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627201325390.png" alt="image-20230627201325390"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; getBannerAPI &#125; from &quot;@/apis/home&quot;;</span><br><span class="line">import &#123; onMounted, ref &#125; from &quot;vue&quot;;</span><br><span class="line">//为了渲染数据,先准备响应式对象</span><br><span class="line">const bannerList = ref([]);</span><br><span class="line">const getBanner = async () =&gt; &#123;</span><br><span class="line">	const res = await getBannerAPI();</span><br><span class="line">	console.log(&quot;res::: &quot;, res);</span><br><span class="line">	bannerList.value = res.result;//ai写的代码,出错了都不知道,妈的</span><br><span class="line">&#125;;</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">	getBanner();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>纪念一次被ai坑了的经历,<strong>根源是没有打印bannerList的value内容</strong>,打印下就知道数据的依赖是谁了.</p>
<h3 id="面板组件封装"><a href="#面板组件封装" class="headerlink" title="面板组件封装"></a>面板组件封装</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627233436758.png" alt="image-20230627233436758"></p>
<p><em>组件封装解决复用结构问题,<em>本质是**一份组件,根据<code>传值</code>的不同,页面内渲染不同数据</em></em></p>
<h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627233625194.png" alt="image-20230627233625194"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627233748189.png" alt="image-20230627233748189"></p>
<p><strong>简单的部分抽象成<code>prop</code>传入即可</strong></p>
<p>复杂的模板:<code>图片和列表等</code>,抽象成插槽传入即可</p>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>作为组件的属性,传入的</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627234229958.png" alt="image-20230627234229958"></p>
<p>直接替换即可<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627234252848.png" alt="image-20230627234252848"></p>
<p>在父组件使用该子组件的时候:</p>
<p>如图,<code>props</code>是直接放到子组件的属性里面</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627234822143.png" alt="image-20230627234822143"></p>
<h4 id="slots-插槽"><a href="#slots-插槽" class="headerlink" title="slots:插槽"></a>slots:插槽</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627234604975.png" alt="image-20230627234604975"></p>
<p>直接默认插槽就行了</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627234953783.png" alt="image-20230627234953783"></p>
<p><code>插槽</code>在父组件使用子组件的时候放到子组件标签的内部</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627235212599.png" alt="image-20230627235212599"></p>
<p>先不要管要变的地方,用不变的数据,把这个整体的结构和样式先搭建起来</p>
<p>然后抽象简单的地方:<strong>比如1个数组,一个js字符串之类的东西,使用props</strong></p>
<p>抽象复杂的地方,<code>使用插槽slots即可</code>,子组件是插槽的出口</p>
<h3 id="新鲜好物组件"><a href="#新鲜好物组件" class="headerlink" title="新鲜好物组件"></a>新鲜好物组件</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629152436393.png" alt="image-20230629152436393"></p>
<p>其实就是准备之前的通用组件</p>
<p>然后把主标题和副标题,<strong>也就是定制内容</strong>通过props传入,</p>
<p>在父组件的<code>插槽</code>里面<strong>渲染想渲染的内容即可</strong>,主要是从<strong>后端拿到想要的数据</strong></p>
<p>在<code>Home.js</code>这个<strong>API文件</strong>放入下列代码</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629152649723.png" alt="image-20230629152649723"></p>
<h4 id="在script位置放入获取数据的代码"><a href="#在script位置放入获取数据的代码" class="headerlink" title="在script位置放入获取数据的代码"></a>在script位置放入获取数据的代码</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629153243458.png" alt="image-20230629153243458"></p>
<h4 id="模板内容-也就是插槽位置要渲染的"><a href="#模板内容-也就是插槽位置要渲染的" class="headerlink" title="模板内容,也就是插槽位置要渲染的"></a>模板内容,也就是插槽位置要渲染的</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629153058673.png" alt="image-20230629153058673"></p>
<p>直接复用组件即可</p>
<h4 id="样式部分"><a href="#样式部分" class="headerlink" title="样式部分:"></a>样式部分:</h4><p><code>text-overflow: ellipsis;</code> 是一个 CSS 属性，用于在文本溢出容器时显示省略号 (…) 来表示被截断的文本内容。</p>
<p>当容器的宽度不足以容纳完整的文本内容时，可以使用 <code>text-overflow: ellipsis;</code> 属性来截断文本并在末尾显示省略号。这通常用于在限定宽度的容器内显示长文本，以防止文本溢出容器并丢失可见内容。</p>
<p>注意，<code>text-overflow: ellipsis;</code> 属性必须与以下的 CSS 属性一同使用，以有效地显示省略号：</p>
<ul>
<li><code>white-space: nowrap;</code> 用于防止文本换行。</li>
<li><code>overflow: hidden;</code> 用于隐藏溢出容器的文本内容。</li>
</ul>
<p>当这些条件同时满足时，文本将在容器的末尾被截断，并以省略号 (…) 表示截断的部分。</p>
<p>需要注意的是，<code>text-overflow: ellipsis;</code> 属性只能应用于块级元素和行内块级元素，而且仅在使用 <code>overflow: hidden;</code> 和 <code>white-space: nowrap;</code> 属性时才会生效。</p>
<h4 id="总体样式代码-sass"><a href="#总体样式代码-sass" class="headerlink" title="总体样式代码,sass"></a>总体样式代码,sass</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scoped lang=&#x27;scss&#x27;&gt;</span><br><span class="line">.goods-list &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  height: 406px;</span><br><span class="line"></span><br><span class="line">  li &#123;</span><br><span class="line">    width: 306px;</span><br><span class="line">    height: 406px;</span><br><span class="line"></span><br><span class="line">    background: #f0f9f4;</span><br><span class="line">    transition: all .5s;</span><br><span class="line"></span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">      transform: translate3d(0, -3px, 0);</span><br><span class="line">      box-shadow: 0 3px 8px rgb(0 0 0 / 20%);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    img &#123;</span><br><span class="line">      width: 306px;</span><br><span class="line">      height: 306px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p &#123;</span><br><span class="line">      font-size: 22px;</span><br><span class="line">      padding-top: 12px;</span><br><span class="line">      text-align: center;</span><br><span class="line">      text-overflow: ellipsis;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      white-space: nowrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .price &#123;</span><br><span class="line">      color: $priceColor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="图片懒加载实现"><a href="#图片懒加载实现" class="headerlink" title="图片懒加载实现"></a>图片懒加载实现</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629161318957.png" alt="image-20230629161318957"></p>
<p><strong>只要你给图片的src属性绑定了url,浏览器就会自动发送网络请求,这是默认行为!!</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629161508611.png" alt="image-20230629161508611"></p>
<h4 id="定义全局指令"><a href="#定义全局指令" class="headerlink" title="定义全局指令"></a>定义全局指令</h4><p>::语法如图</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629163254838.png" alt="image-20230629163254838"></p>
<p><code>binding</code>对象如图:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629170321947.png" alt="image-20230629170321947"></p>
<p>打印结果如图</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629163422397.png" alt="image-20230629163422397"></p>
<h4 id="判断图片进入视口"><a href="#判断图片进入视口" class="headerlink" title="判断图片进入视口"></a>判断图片进入视口</h4><p><a href="http://www.vueusejs.com/">VueUse中文文档 | VueUse中文文档 (vueusejs.com)</a></p>
<p><a href="http://www.vueusejs.com/core/useIntersectionObserver/">useIntersectionObserver | VueUse中文文档 (vueusejs.com)</a></p>
<p><code>响应式监听目标元素的可见性。</code>也就是判断目标元素是否进入视口区域</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;target&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useIntersectionObserver &#125; <span class="keyword">from</span> <span class="string">&#x27;@vueuse/core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> targetIsVisible = <span class="title function_">ref</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; stop &#125; = <span class="title function_">useIntersectionObserver</span>(</span><br><span class="line">      target,</span><br><span class="line">      <span class="function">(<span class="params">[&#123; isIntersecting &#125;], observerElement</span>) =&gt;</span> &#123;</span><br><span class="line">        targetIsVisible.<span class="property">value</span> = isIntersecting</span><br><span class="line">      &#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      target,</span><br><span class="line">      targetIsVisible,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629164230671.png" alt="image-20230629164230671"></p>
<p>el就是target,目标元素,监听的元素</p>
<p>后面参数的<code>isIntersecting</code>就是<strong>看元素在不在视口范围内</strong>,在就是<strong>true</strong></p>
<h4 id="核心步骤代码"><a href="#核心步骤代码" class="headerlink" title="核心步骤代码:"></a>核心步骤代码:</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629165132346.png" alt="image-20230629165132346"></p>
<h3 id="懒加载优化"><a href="#懒加载优化" class="headerlink" title="懒加载优化"></a>懒加载优化</h3><h4 id="逻辑书写内容不合理"><a href="#逻辑书写内容不合理" class="headerlink" title="逻辑书写内容不合理"></a>逻辑书写内容不合理</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629171410077.png" alt="image-20230629171410077"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629171549822.png" alt="image-20230629171549822"></p>
<p>把上述的文件逻辑写成一个插件,然后把该插件绑定到<code>app</code>这个主要应用程序上.</p>
<p>在指令文件夹中,新建<code>index.js</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629172114322.png" alt="image-20230629172114322"></p>
<p>在<strong>main.js内部</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629172728330.png" alt="image-20230629172728330"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629172735545.png" alt="image-20230629172735545"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629172745075.png" alt="image-20230629172745075"></p>
<p><strong>因为<code>main.js就是在做一些初始化的操作</code>,但是之前的写法把懒加载的复杂度放到了main.js里面,此时就是模块化,方便后期维护</strong></p>
<h4 id="重复监听浪费内存"><a href="#重复监听浪费内存" class="headerlink" title="重复监听浪费内存"></a>重复监听浪费内存</h4><ol>
<li>虽然图片已经加载完毕了,但是这个地方的监听函数还会继续执行</li>
<li><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629173202185.png" alt="image-20230629173202185"></li>
</ol>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629173046763.png" alt="image-20230629173046763"></p>
<p>此函数<code>useIntersectionObserver</code>会返回一个stop函数,用来停止监听,直接放到<strong>src属性被赋值的后面即可</strong></p>
<h3 id="产品列表组件"><a href="#产品列表组件" class="headerlink" title="产品列表组件"></a>产品列表组件</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629174457386.png" alt="image-20230629174457386"></p>
<p>常规的列表渲染就是</p>
<ol>
<li>先准备静态的模板,写好样式.</li>
<li>然后根据后端返回的数据去渲染真正的模板.<code>使用v-for</code></li>
<li><code>v-img-lazy</code>懒加载指令</li>
</ol>
<h4 id="快速生成JSDOC注释"><a href="#快速生成JSDOC注释" class="headerlink" title="快速生成JSDOC注释"></a>快速生成JSDOC注释</h4><p><a href="https://www.cnblogs.com/jiujiubashiyi/p/17312039.html">基于VS Code的JSDoc的使用指南 - 当时明月在曾照彩云归 - 博客园 (cnblogs.com)</a></p>
<h4 id="获取数据渲染模板"><a href="#获取数据渲染模板" class="headerlink" title="获取数据渲染模板:"></a>获取数据渲染模板:</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629180612887.png" alt="image-20230629180612887"></p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629180635648.png" alt="image-20230629180635648"></p>
<h4 id="图片懒加载改造"><a href="#图片懒加载改造" class="headerlink" title="图片懒加载改造"></a>图片懒加载改造</h4><p><strong>看img标签</strong>,但是这个是<strong>错误的</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629182429236.png" alt="image-20230629182429236"></p>
<p>自己定义的指令,也就是标签属性的一部分,不用<code>写v-bind动态绑定了</code>,因为后面的url自动导入到函数执行的参数去了</p>
<p>指令也是在执行函数罢了.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629182634879.png" alt="image-20230629182634879"></p>
<h3 id="封装GoodsItem组件"><a href="#封装GoodsItem组件" class="headerlink" title="封装GoodsItem组件"></a>封装GoodsItem组件</h3><p>在业务中需要用到同样的模块,就要考虑封装</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629214100558.png" alt="image-20230629214100558"></p>
<h4 id="如何封装"><a href="#如何封装" class="headerlink" title="如何封装?"></a>如何封装?</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629214219663.png" alt="image-20230629214219663"></p>
<h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629214329264.png" alt="image-20230629214329264"></p>
<p>分屏幕,左侧是<strong>源代码</strong>,右侧是<code>要封装的组件</code>然后直接看着封装即可,最主要的是<strong>数据的传递!!!</strong></p>
<h4 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629215305357.png" alt="image-20230629215305357"></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629215223350.png" alt="image-20230629215223350"></p>
<h1 id="CateGory组件路由"><a href="#CateGory组件路由" class="headerlink" title="CateGory组件路由"></a>CateGory组件路由</h1><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>在路由中加上占位符<code>:id</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629220622987.png" alt="image-20230629220622987"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629220617151.png" alt="image-20230629220617151"></p>
<p>实现在导航的组件中点击按钮跳到对应组件</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629221009735.png" alt="image-20230629221009735"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629220749137.png" alt="image-20230629220749137"></p>
<p>在另一个组件<code>NAV</code>组件也是一样,直接动态绑定to的值即可,也就是传递<strong>item.id</strong></p>
<h2 id="面包屑导航渲染"><a href="#面包屑导航渲染" class="headerlink" title="面包屑导航渲染"></a>面包屑导航渲染</h2><p><strong>典中典前端解决不了交给后端解决,就是调接口获取数据,哈哈哈.</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629221655393.png" alt="image-20230629221655393"></p>
<p>四步走,准备组件,封装接口,获取数据,渲染</p>
<p>组件代码</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629221855852.png" alt="image-20230629221855852"></p>
<p>基本就是使用ELEment的组件然后传入分隔符的样式</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629221952933.png" alt="image-20230629221952933"></p>
<p><code>:to=&#123;path:&quot;/&quot;&#125;</code>传入这样的属性:代表<strong>这个item是可以被点击的,然后代表路由</strong>,也就是导航到<code>/</code></p>
<p>封装接口</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629222149169.png" alt="image-20230629222149169"></p>
<p>在<code>apis文件夹</code>新建文件</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629222306068.png" alt="image-20230629222306068"></p>
<p>返回的响应,说明result对应<code>object</code><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629222359793.png" alt="image-20230629222359793"></p>
<p>获取数据</p>
<p>思路就是根据路径对应的id去请求后端的接口,然后后端根据id数据查询数据库.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629222551745.png" alt="image-20230629222551745"></p>
<p>因为上面是<code>:id</code>这个参数就被传到params里面了.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230629224439215.png" alt="image-20230629224439215"></p>
<p>基本如图所示,反正就是搞好组件,然后封装接口</p>
<h2 id="VUE-ROUTER"><a href="#VUE-ROUTER" class="headerlink" title="VUE-ROUTER"></a>VUE-ROUTER</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态字段以冒号开始</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">User</span> &#125;,</span><br></pre></td></tr></table></figure>

<p><em>路径参数</em> 用冒号 <code>:</code> 表示。当一个路由被匹配时，它的 <em>params</em> 的值将在每个组件中以 <code>route.params</code> 的形式暴露出来。在模板中访问<code>&#123;&#123;route.params.id&#125;&#125;</code></p>
<table>
<thead>
<tr>
<th align="left">匹配模式</th>
<th align="left">匹配路径</th>
<th align="left">route.params</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;users&#x2F;:username</td>
<td align="left">&#x2F;users&#x2F;eduardo</td>
<td align="left"><code>&#123; username: &#39;eduardo&#39; &#125;</code></td>
</tr>
<tr>
<td align="left">&#x2F;users&#x2F;:username&#x2F;posts&#x2F;:postId</td>
<td align="left">&#x2F;users&#x2F;eduardo&#x2F;posts&#x2F;123</td>
<td align="left"><code>&#123; username: &#39;eduardo&#39;, postId: &#39;123&#39; &#125;</code></td>
</tr>
</tbody></table>
<p>如何查看query?</p>
<ol>
<li>首先添加:import useRouter from “vue-router” 使用路由器</li>
<li>添加查询参数:push query parameter,</li>
<li>路径 be like:<a href="http://localhost:5173/?make=Audi&banana=banana">http://localhost:5173/?make=Audi&amp;banana=banana</a></li>
<li>核心是<code>?make=Audi&amp;banana=banana</code>,这就是查询字符串</li>
<li>为了访问路径中的参数,使用:useRoute</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    router.<span class="title function_">push</span>(&#123; <span class="attr">query</span>: &#123; <span class="attr">make</span>: make.<span class="property">value</span> &#125; &#125;);<span class="comment">//添加query参数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    make.<span class="property">value</span> = route.<span class="property">query</span>.<span class="property">make</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="banner轮播图实现"><a href="#banner轮播图实现" class="headerlink" title="banner轮播图实现"></a>banner轮播图实现</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630142132874.png" alt="image-20230630142132874"></p>
<p>基本就是在发送请求的时候,改个参数即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630142345951.png" alt="image-20230630142345951"></p>
<p>在改造接口的时候,基本上传递默认对象,然后把参数的默认值也设置为’1’</p>
<p><strong>组件化</strong>,基本纯复制就行了</p>
<p>也要把对应的模板复制过去哦</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630142536945.png" alt="image-20230630142536945"></p>
<p><strong>因为此时没有传递任何的参数</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630142641315.png" alt="image-20230630142641315"></p>
<p>所以默认为1.</p>
<p>传入上面编写的参数</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630142812693.png" alt="image-20230630142812693"></p>
<p>此时的请求::</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630142826594.png" alt="image-20230630142826594"></p>
<p> <strong>注意把绝对定位干掉,而且z-index也要干掉</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630143047521.png" alt="image-20230630143047521"></p>
<p>记得水平居中哦</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630171948846.png" alt="image-20230630171948846"></p>
<h2 id="激活状态显示和分类列表渲染"><a href="#激活状态显示和分类列表渲染" class="headerlink" title="激活状态显示和分类列表渲染"></a>激活状态显示和分类列表渲染</h2><p>激活状态就是给<code>router-link</code>标签绑定<strong>active-class</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630143302580.png" alt="image-20230630143302580"></p>
<p>经典v-for遍历数据显示页面,遍历的时候记得传递**:key属性**</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630143423352.png" alt="image-20230630143423352"></p>
<p>基本代码</p>
<p>全部放到<code>top-category</code>下面</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630172547005.png" alt="image-20230630172547005"></p>
<p><strong>在轮播图的后面,放入下列分类列表的模板</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630172614445.png" alt="image-20230630172614445"></p>
<p>不要忘记导入GoodsItem组件</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630143629875.png" alt="image-20230630143629875"></p>
<p>因为样式已经提前写了,直接使用即可.</p>
<p>写好的代码就别瞎改了,改了就出bug,妈的</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630173945493.png" alt="image-20230630173945493"></p>
<p>此处传入的数据是<code>:good=&quot;good&quot;</code>,直接看<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630174010271.png" alt="image-20230630174010271"></p>
<p>这里面的defineProps即可</p>
<h2 id="解决路由缓存问题"><a href="#解决路由缓存问题" class="headerlink" title="解决路由缓存问题"></a>解决路由缓存问题</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630144212276.png" alt="image-20230630144212276"></p>
<p><code>就是当后面的路由参数改变,但是渲染的还是一份组件,生命周期函数不会重复调用了</code></p>
<p><strong>也就是获取数据接口的函数不会在路由切换期间调用</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630144435012.png" alt="image-20230630144435012"></p>
<p>上述思路很完美,组件实例不复用,就是加入<code>:key!</code></p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630144542180.png" alt="image-20230630144542180"></p>
<p>在LayOut文件夹中</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630144659893.png" alt="image-20230630144659893"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630144709235.png" alt="image-20230630144709235"></p>
<h5 id="请注意，"><a href="#请注意，" class="headerlink" title="请注意，"></a>请注意，</h5><p>在模板中我们仍然可以访问 <code>$router</code> 和 <code>$route</code>，所以不需要在 <code>setup</code> 中返回 <code>router</code> 或 <code>route</code>。</p>
<p><strong>直接破坏组件的复用机制,强制销毁重建,也就是在<code>模板中使用全局$route对象</code></strong></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>太过于简单粗暴,对于轮播图的数据来说,重复发送请求,存在性能的优化空间.</li>
<li>而且组件直接销毁重建,不是很好,对于性能来说</li>
</ol>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><h4 id="监听路由的变化"><a href="#监听路由的变化" class="headerlink" title="监听路由的变化"></a>监听路由的变化</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630145109365.png" alt="image-20230630145109365"></p>
<p>在<code>Category组件里面</code>,直接导入即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630150635280.png" alt="image-20230630150635280"></p>
<p><code>这就是组合式api的魅力,想用直接导入!!!</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630151106301.png" alt="image-20230630151106301"></p>
<p><code>to</code> 代表<strong>目标路由对象</strong></p>
<p>这个就是打印出来的路由对象,也就是<strong>route</strong><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630150954352.png" alt="image-20230630150954352"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630151113142.png" alt="image-20230630151113142"></p>
<p>此处的<code>id = route.params.id</code>代表函数的<strong>默认参数</strong>,如果传入了其他的参数</p>
<p>比如此处的<code>to.params.id的话</code>,则传入这个参数就覆盖了原本的默认参数了</p>
<p>目的就是适配路由的逻辑</p>
<p>合理使用netWork的清空按钮:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630151345461.png" alt="image-20230630151345461"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630151339224.png" alt="image-20230630151339224"></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630151631748.png" alt="image-20230630151631748"></p>
<p><strong>key只要给到一个独一无二的值,就会直接破坏组件的缓存</strong>,但是<code>存在性能上的浪费</code></p>
<h2 id="使用逻辑函数拆分业务"><a href="#使用逻辑函数拆分业务" class="headerlink" title="使用逻辑函数拆分业务"></a>使用逻辑函数拆分业务</h2><p>钩子函数:<code>hook</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630151958706.png" alt="image-20230630151958706"></p>
<p>把<strong>同一个组件里面独立的业务代码通过函数做封装处理</strong>,提升可维护性,方便代码的后期维护,就是把代码封装为一个个文件,直接到文件里面找对应代码即可</p>
<h3 id="具体咋做呢"><a href="#具体咋做呢" class="headerlink" title="具体咋做呢?"></a>具体咋做呢?</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630152202086.png" alt="image-20230630152202086"></p>
<h3 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h3><p>就近维护原则</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630152408296.png" alt="image-20230630152408296"></p>
<p>直接创建文件夹,use钩子:<code>hook</code>函数.</p>
<p>创建<code>useBanner.js文件</code></p>
<h4 id="把独立的业务逻辑封装到各个函数的内部"><a href="#把独立的业务逻辑封装到各个函数的内部" class="headerlink" title="把独立的业务逻辑封装到各个函数的内部"></a>把独立的业务逻辑封装到各个函数的内部</h4><p>直接把所有的逻辑代码复制过去!!!</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630152553776.png" alt="image-20230630152553776"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630154005230.png" alt="image-20230630154005230"></p>
<p>我知道有很多错误,但是你先别急.</p>
<h4 id="在函数内部把组件中需要用到的数据或者方法return出去"><a href="#在函数内部把组件中需要用到的数据或者方法return出去" class="headerlink" title="在函数内部把组件中需要用到的数据或者方法return出去."></a>在函数内部把组件中需要用到的数据或者方法return出去.</h4><p>完整的js文件代码</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630155002369.png" alt="image-20230630155002369"></p>
<p><strong>一执行这个函数,就可以<code>直接得到这个对象</code>,使用<code>解构赋值的方式</code>,把<code>对应的数据</code>从这个<code>函数里面解构出来</code></strong></p>
<p>总体代码</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630155116562.png" alt="image-20230630155116562"></p>
<p>也就是把相应的逻辑给抽象出去了,直接使用<code>bannerList</code>即可</p>
<p>把左侧的对应代码直接复制封装</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630155412961.png" alt="image-20230630155412961"></p>
<p>相对应的,直接套用封装的逻辑即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630155345462.png" alt="image-20230630155345462"></p>
<p>别忘记最后直接使用<code>return 对象的方式做一层封装</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630155513564.png" alt="image-20230630155513564"></p>
<p>整体做一层抽象函数的封装</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630155607588.png" alt="image-20230630155607588"></p>
<h4 id="整体总结"><a href="#整体总结" class="headerlink" title="整体总结"></a>整体总结</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630160158867.png" alt="image-20230630160158867"></p>
<p>就是在setup区域::</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630155722136.png" alt="image-20230630155722136"></p>
<p><strong>再也看不见逻辑代码了,而是只有两个函数的执行,拿到内部的数据,</strong></p>
<p><code>在实际的逻辑组合中,就只剩下封装好的js文件了</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630155842066.png" alt="image-20230630155842066"></p>
<p><strong>方便维护和复用</strong>,降低组件的复杂度</p>
<p><strong>hook其实就是<code>把数据从封装好的函数中钩取出来</code>,然后<code>直接使用处理好的数据</code>即可!!!!</strong></p>
<h1 id="二级分类组件"><a href="#二级分类组件" class="headerlink" title="二级分类组件"></a>二级分类组件</h1><h2 id="整体认识和路由配置"><a href="#整体认识和路由配置" class="headerlink" title="整体认识和路由配置"></a>整体认识和路由配置</h2><p>一级分类就是<code>每个cateGory组件</code>,根据请求的id不同,数据库返回的数据也不同,然后<strong>模板是一样的</strong>.</p>
<p><code>根据数据不同修改模板的数据即可</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630190321037.png" alt="image-20230630190321037"></p>
<p>对应的全部分类下面的路由,就是二级分类</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630190231430.png" alt="image-20230630190231430"></p>
<p><code>全部分类下</code>的就是<strong>二级分类</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630190147125.png" alt="image-20230630190147125"></p>
<p>商品列表具有无限加载功能</p>
<h3 id="配置二级路由"><a href="#配置二级路由" class="headerlink" title="配置二级路由"></a>配置二级路由</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630190605069.png" alt="image-20230630190605069"></p>
<p> 首先创建路由组件,在这个位置:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630191348410.png" alt="image-20230630191348410"></p>
<p>经典<code>index.vue</code></p>
<p>文件内容</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630191747505.png" alt="image-20230630191747505"></p>
<h3 id="配置路由关系"><a href="#配置路由关系" class="headerlink" title="配置路由关系,"></a>配置路由关系,</h3><p><code>还是在layout,还是在layout的子路由下面</code></p>
<p><strong>因为显示的页面不同,所以路径不同</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630191944380.png" alt="image-20230630191944380"></p>
<h3 id="修改模板实现跳转"><a href="#修改模板实现跳转" class="headerlink" title="修改模板实现跳转"></a>修改模板实现跳转</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630192104195.png" alt="image-20230630192104195"></p>
<p>在此处修改RouterLink即可</p>
<p>如此配置<code>to属性</code>即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630192221680.png" alt="image-20230630192221680"></p>
<p>看来后端是真的重要啊</p>
<h2 id="面包屑导航实现"><a href="#面包屑导航实现" class="headerlink" title="面包屑导航实现"></a>面包屑导航实现</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630192559124.png" alt="image-20230630192559124"></p>
<h3 id="封装接口"><a href="#封装接口" class="headerlink" title="封装接口"></a>封装接口</h3><p><strong>获取二级分类列表的数据,接口函数就放到::<code>category.js</code>文件里面</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630192743213.png" alt="image-20230630192743213"></p>
<h3 id="调用接口获取数据"><a href="#调用接口获取数据" class="headerlink" title="调用接口获取数据"></a>调用接口获取数据</h3><p>典中典,不多点评</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630193108017.png" alt="image-20230630193108017"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630193051454.png" alt="image-20230630193051454"></p>
<p>接口返回的数据,在控制台的network查看即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630193216683.png" alt="image-20230630193216683"></p>
<p>主要是<code>name</code>和<code>parentName</code>,渲染到模板的指定位置</p>
<h3 id="渲染模板"><a href="#渲染模板" class="headerlink" title="渲染模板"></a>渲染模板</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630193509991.png" alt="image-20230630193509991"></p>
<h2 id="商品列表组件实现"><a href="#商品列表组件实现" class="headerlink" title="商品列表组件实现"></a>商品列表组件实现</h2><p><strong><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630201920385.png" alt="image-20230630201920385"></strong></p>
<h3 id="基础列表渲染"><a href="#基础列表渲染" class="headerlink" title="基础列表渲染"></a>基础列表渲染</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630202028135.png" alt="image-20230630202028135"></p>
<h4 id="封装接口-1"><a href="#封装接口-1" class="headerlink" title="封装接口"></a>封装接口</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630202201952.png" alt="image-20230630202201952"></p>
<p>获取导航的数据,基本就是发送post请求,给后端发送要求,然后得到返回的数据</p>
<h4 id="准备参数"><a href="#准备参数" class="headerlink" title="准备参数"></a>准备参数</h4><p>引入的东西:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630202704986.png" alt="image-20230630202704986"></p>
<p>完整代码:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630202610713.png" alt="image-20230630202610713"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630202440480.png" alt="image-20230630202440480"></p>
<p>发送的参数在network区域也能看到</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630202508485.png" alt="image-20230630202508485"></p>
<p><code>实际返回数据</code></p>
<h4 id="获取数据渲染"><a href="#获取数据渲染" class="headerlink" title="获取数据渲染"></a>获取数据渲染</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630202743460.png" alt="image-20230630202743460"></p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p>先使用最基础的参数,把这些架子先搭起来,把基础的参数和架子搭起来之后</p>
</li>
<li><p>就可以完成复杂的参数加入了</p>
</li>
</ol>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630202936233.png" alt="image-20230630202936233"></p>
<h3 id="筛选功能"><a href="#筛选功能" class="headerlink" title="筛选功能"></a>筛选功能</h3><ol>
<li>获取激活项数据</li>
<li>使用新的参数发送请求重新渲染列表</li>
</ol>
<p><code>element-plue</code>提供了接口,tabs这个组件</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702222135635.png" alt="image-20230702222135635"></p>
<p>el-tabs上面的<code>v-model</code>表示现在用户选中的值</p>
<p><code>@tab-click</code>表示点击触发的事件函数</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702222547657.png" alt="image-20230702222547657"></p>
<p><strong>subCategory 的 index.vue</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702222407843.png" alt="image-20230702222407843"></p>
<p><code>@tab-change</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702223134611.png" alt="image-20230702223134611"></p>
<p><strong>看网络是否重新请求数据即可</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702223159835.png" alt="image-20230702223159835"></p>
<p>只要发送给后端的接口数据发生变化,则就可以了</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702223318023.png" alt="image-20230702223318023"></p>
<h3 id="无限加载"><a href="#无限加载" class="headerlink" title="无限加载"></a>无限加载</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702223619831.png" alt="image-20230702223619831"></p>
<p>监听是否满足触底条件</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702225050060.png" alt="image-20230702225050060"></p>
<p><strong>触底就触发函数捏</strong></p>
<p>使用展开运算符<code>...</code></p>
<p>把老数据和新数据的值展开然后做一个拼接</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702224612017.png" alt="image-20230702224612017"></p>
<p>完整的代码:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702224843376.png" alt="image-20230702224843376"></p>
<p>检验数组是否为空,就看length</p>
<h3 id="路由行为定制"><a href="#路由行为定制" class="headerlink" title="路由行为定制"></a>路由行为定制</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703202817981.png" alt="image-20230703202817981"></p>
<p>这样设置,每次切换路由都会使得top坐标设置为0.页面滚动到顶部</p>
<h2 id="商品详情组件"><a href="#商品详情组件" class="headerlink" title="商品详情组件"></a>商品详情组件</h2><h3 id="访问数据对象的多层属性"><a href="#访问数据对象的多层属性" class="headerlink" title="访问数据对象的多层属性"></a>访问数据对象的多层属性</h3><p>![new ducument](F:\WebDeveLoper\学习图片\new ducument.jpg)</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703220929597.png" alt="image-20230703220929597"></p>
<h3 id="热榜区域实现"><a href="#热榜区域实现" class="headerlink" title="热榜区域实现"></a>热榜区域实现</h3><p>因为二者的结构一致,所以存在可以封装为组件的部分.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703221443883.png" alt="image-20230703221443883"></p>
<p>封装组件:写代码</p>
<p>就近维护原则:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703225137441.png" alt="image-20230703225137441"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;goods-hot&quot;&gt;</span><br><span class="line">    &lt;h3&gt;周日榜单&lt;/h3&gt;</span><br><span class="line">    &lt;!-- 商品区块 --&gt;</span><br><span class="line">    &lt;RouterLink to=&quot;/&quot; class=&quot;goods-item&quot; v-for=&quot;item in 3&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">      &lt;img :src=&quot;item.picture&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">      &lt;p class=&quot;name ellipsis&quot;&gt;一双男鞋&lt;/p&gt;</span><br><span class="line">      &lt;p class=&quot;desc ellipsis&quot;&gt;一双好穿的男鞋&lt;/p&gt;</span><br><span class="line">      &lt;p class=&quot;price&quot;&gt;&amp;yen;200.00&lt;/p&gt;</span><br><span class="line">    &lt;/RouterLink&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">.goods-hot &#123;</span><br><span class="line">  h3 &#123;</span><br><span class="line">    height: 70px;</span><br><span class="line">    background: $helpColor;</span><br><span class="line">    color: #fff;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">    line-height: 70px;</span><br><span class="line">    padding-left: 25px;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">    font-weight: normal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .goods-item &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    padding: 20px 30px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    background: #fff;</span><br><span class="line"></span><br><span class="line">    img &#123;</span><br><span class="line">      width: 160px;</span><br><span class="line">      height: 160px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p &#123;</span><br><span class="line">      padding-top: 10px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .name &#123;</span><br><span class="line">      font-size: 16px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .desc &#123;</span><br><span class="line">      color: #999;</span><br><span class="line">      height: 29px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .price &#123;</span><br><span class="line">      color: $priceColor;</span><br><span class="line">      font-size: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703225116359.png" alt="image-20230703225116359"></p>
<h4 id="获取渲染数据"><a href="#获取渲染数据" class="headerlink" title="获取渲染数据"></a>获取渲染数据</h4><p>封装接口,带入到模板里面</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703222839016.png" alt="image-20230703222839016"></p>
<p>首先以24小时的数据为例,把整个模板先搭出来,然后,再去想如何改变一些常量.</p>
<p>也就是先搭架子,然后再去整变量.</p>
<h4 id="适配不同的title和列表内容"><a href="#适配不同的title和列表内容" class="headerlink" title="适配不同的title和列表内容"></a>适配不同的title和列表内容</h4><p><code>为了适配,重点是找到判断的条件</code></p>
<p><strong>判断条件</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703230222869.png" alt="image-20230703230222869"></p>
<p>根据判断条件:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703230315449.png" alt="image-20230703230315449"></p>
<p>使用<strong>vue调试工具</strong>查看prop是否正确传值</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703225551102.png" alt="image-20230703225551102"></p>
<h5 id="title"><a href="#title" class="headerlink" title="title"></a>title</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703230047392.png" alt="image-20230703230047392"></p>
<h5 id="列表数据"><a href="#列表数据" class="headerlink" title="列表数据"></a>列表数据</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703230827978.png" alt="image-20230703230827978"></p>
<p>调整type即可</p>
<h3 id="封装图片预览组件"><a href="#封装图片预览组件" class="headerlink" title="封装图片预览组件"></a>封装图片预览组件</h3><p>左侧的图片捏</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703231104038.png" alt="image-20230703231104038"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703231044118.png" alt="image-20230703231044118"></p>
<h4 id="通过小图切换大图显示的思路"><a href="#通过小图切换大图显示的思路" class="headerlink" title="通过小图切换大图显示的思路.:"></a>通过小图切换大图显示的思路.:</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703231545856.png" alt="image-20230703231545856"></p>
<h5 id="components-放一些和相关业务非强相关的组件"><a href="#components-放一些和相关业务非强相关的组件" class="headerlink" title="components,放一些和相关业务非强相关的组件"></a>components,放一些和相关业务非强相关的组件</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230703231909621.png" alt="image-20230703231909621"></p>
<p>因为要放置<strong>放大镜功能</strong>和<strong>hover小图到大图</strong>的.</p>
<h5 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704153907996.png" alt="image-20230704153907996"></p>
<p>为每个小图绑定一个鼠标移入的事件<code>@mouseenter事件</code>,然后把<code>v-for的</code> <code>index</code>传入处理函数,此时传入的<strong>index就是鼠标每次移入到图片上得到的下标值.</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704154751223.png" alt="image-20230704154751223"></p>
<p>此时只需要把大图的src动态绑定成<code>imageList[activeIndex]</code>即可,每次跟随切换.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704154841740.png" alt="image-20230704154841740"></p>
<p>只要小图片的li标签上有<code>.active</code>类名,则应用此样式</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704155414471.png" alt="image-20230704155414471"></p>
<h5 id="tab切换套路"><a href="#tab切换套路" class="headerlink" title="tab切换套路:"></a>tab切换套路:</h5><p>动态类名控制::<code> :class=&quot;&#123; active: index === activeIndex &#125;&quot;</code>通过一个激活的index值,匹配列表的index值,</p>
<p>展示谁是激活的状态.</p>
<h4 id="放大镜功能"><a href="#放大镜功能" class="headerlink" title="放大镜功能"></a>放大镜功能</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704155959410.png" alt="image-20230704155959410"></p>
<h5 id="左侧滑块跟随鼠标移动"><a href="#左侧滑块跟随鼠标移动" class="headerlink" title="左侧滑块跟随鼠标移动"></a>左侧滑块跟随鼠标移动</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704160229075.png" alt="image-20230704160229075"></p>
<p>使用vueUse,获取当前鼠标在盒子里的相对位置<a href="http://www.vueusejs.com/core/useMouseInElement/">useMouseInElement | VueUse中文文档 (vueusejs.com)</a></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704160550493.png" alt="image-20230704160550493"></p>
<p>三个参数<code>elementX.elementY,和isOutside</code>,</p>
<p>elementX:<strong>距离盒子左侧的距离</strong></p>
<p>elementY:<strong>距离盒子顶部的距离</strong></p>
<p>isOutside:在盒子外面为<strong>true</strong>,在内部<strong>false</strong></p>
<p>然后修改滑块跟随鼠标移动的left和top</p>
<p>要手动停止一个watch:<code>监听器</code>，请调用 <code>watch</code> 或 <code>watchEffect</code> 返回的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watch</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// ...当该侦听器不再需要时</span></span><br><span class="line"><span class="title function_">stop</span>()</span><br></pre></td></tr></table></figure>

<p>有效移动范围和边界距离:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704162251342.png" alt="image-20230704162251342"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704162348417.png" alt="image-20230704162348417"></p>
<p>就是让滑块不出去这个大图片,而且移动捏</p>
<h6 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h6><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704162732122.png" alt="image-20230704162732122"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704165032492.png" alt="image-20230704165032492"></p>
<p>没有处理的问题就是,在鼠标移出去之后,停止监听Mouse事件,然后移入滑块再次监听该事件.,不停止监听</p>
<p>则鼠标在外面也会触发滑块的移动</p>
<h5 id="右侧大图放大效果"><a href="#右侧大图放大效果" class="headerlink" title="右侧大图放大效果"></a>右侧大图放大效果</h5><p>首先大图和滑块的移动方向是相反的,只要加<strong>负号 <code>-</code> 即可</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704165634305.png" alt="image-20230704165634305"></p>
<h6 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现::"></a>具体实现::</h6><p><strong>如何控制背景图的移动? 答案是 :: background-position</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704170708859.png" alt="image-20230704170708859"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704170717122.png" alt="image-20230704170717122"></p>
<p>控制样式里面的<code>background-position</code>即可</p>
<h5 id="大图的显示和隐藏"><a href="#大图的显示和隐藏" class="headerlink" title="大图的显示和隐藏"></a>大图的显示和隐藏</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704170805375.png" alt="image-20230704170805375"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704171144121.png" alt="image-20230704171144121"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704171215126.png" alt="image-20230704171215126"></p>
<p>就是上面的v-show,<code>!isOutside</code>就是不在外面,在里面,就可以控制显示和隐藏了.</p>
<h5 id="解决性能浪费问题"><a href="#解决性能浪费问题" class="headerlink" title="解决性能浪费问题."></a>解决性能浪费问题.</h5><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704171416307.png" alt="image-20230704171416307"></p>
<h4 id="组件props适配"><a href="#组件props适配" class="headerlink" title="组件props适配"></a>组件props适配</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704172129609.png" alt="image-20230704172129609"></p>
<p>目的还是增强图片详情的适应性</p>
<p>传入props<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704172353570.png" alt="image-20230704172353570"></p>
<h4 id="回顾总结-1"><a href="#回顾总结-1" class="headerlink" title="回顾总结"></a>回顾总结</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704172902353.png" alt="image-20230704172902353"></p>
<h5 id="封装复杂组件的通用思路"><a href="#封装复杂组件的通用思路" class="headerlink" title="封装复杂组件的通用思路:"></a>封装复杂组件的通用思路:</h5><ol>
<li>把复杂的功能拆解成要实现的许多部分,比如上面的对应逻辑拆分</li>
<li>小图数组,通过下标得到图片的url地址,然后切换图片.</li>
<li>寻找核心的实现思路,如何实现用户的需求(自己的需求)?</li>
<li>获取鼠标的相对位移<code>vueUse的useMouseInElement函数</code>,操作layer滑块的left和top</li>
<li>寻找要实现上面功能的关键技术,可以是原生的js技术,也可以是别人封装好的东西.<code>vueUse</code>.</li>
<li>实现思路,实现代码,最后看看能否优化和整理.</li>
</ol>
<h3 id="封装SKU组件"><a href="#封装SKU组件" class="headerlink" title="封装SKU组件"></a>封装SKU组件</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704180950859.png" alt="image-20230704180950859"></p>
<p>熟悉一个三方组件,首先看<code>props</code>和<code>emit</code></p>
<p><strong>props决定了当前组件接收的数据</strong></p>
<p><strong>emit决定了产出的数据</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704181147151.png" alt="image-20230704181147151"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704182539536.png" alt="image-20230704182539536"></p>
<p>接收一个goods对象,里面有两个数组,就是基本的商品信息</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704182640901.png" alt="image-20230704182640901"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704182450848.png" alt="image-20230704182450848"></p>
<p>触发名为change的事件,然后传递一些商品的信息.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704190033135.png" alt="image-20230704190033135"></p>
<p>传入相关的goods参数,然后在emit(“change”,<code>数据对象</code>)事件的时候,触发函数<code>skuChange</code>,</p>
<p>在函数声明处可以接收到子组件传递的数据</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704190137820.png" alt="image-20230704190137820"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704190153438.png" alt="image-20230704190153438"></p>
<p>这个inventory是库存,然后skuID就是商品的id,specsText就是商品的描述信息,或者叫做规格文本</p>
<p>目的主要是验证:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704192736457.png" alt="image-20230704192736457"></p>
<h3 id="通用组件注册到全局"><a href="#通用组件注册到全局" class="headerlink" title="通用组件注册到全局"></a>通用组件注册到全局</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704193251940.png" alt="image-20230704193251940"></p>
<h4 id="写一个插件-把全局组件目录统一注册"><a href="#写一个插件-把全局组件目录统一注册" class="headerlink" title="写一个插件,把全局组件目录统一注册!!!"></a>写一个插件,把全局组件目录统一注册!!!</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704193525807.png" alt="image-20230704193525807"></p>
<h4 id="架构的提升"><a href="#架构的提升" class="headerlink" title="架构的提升!!!"></a>架构的提升!!!</h4><p>全局注册组件,省去一个引用组件的步骤,主要就是方便直接导入,</p>
<p>插件定义好,在mian.js直接引入use即可</p>
<h2 id="登录组件"><a href="#登录组件" class="headerlink" title="登录组件"></a>登录组件</h2><p><strong>表单验证和登录登出业务</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704202552189.png" alt="image-20230704202552189"></p>
<h3 id="区分登录状态和非登录状态"><a href="#区分登录状态和非登录状态" class="headerlink" title="区分登录状态和非登录状态"></a>区分登录状态和非登录状态</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704203801643.png" alt="image-20230704203801643"></p>
<p>多模板渲染,v-if和v-else.</p>
<h3 id="在模板中可以直接访问暴露的全局对象-route和-router"><a href="#在模板中可以直接访问暴露的全局对象-route和-router" class="headerlink" title="在模板中可以直接访问暴露的全局对象,$route和$router"></a>在模板中可以直接访问暴露的全局对象,$route和$router</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704203917514.png" alt="image-20230704203917514"></p>
<h3 id="表单校验功能"><a href="#表单校验功能" class="headerlink" title="表单校验功能"></a>表单校验功能</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704205413290.png" alt="image-20230704205413290"></p>
<p>目的就是省去一些错误的请求提交,为后端节省接口压力</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704205506157.png" alt="image-20230704205506157"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704210255986.png" alt="image-20230704210255986"></p>
<p>这个:model和:rules比较重要,还有就是el-form-item和el-input这三个组件,基本是三层嵌套关系</p>
<p>这个prop基本就是对应这个item是哪一个校验规则.</p>
<p><code>:model</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704210356594.png" alt="image-20230704210356594"></p>
<p><code>:rules</code></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rules = reactive&lt;<span class="title class_">FormRules</span>&lt;<span class="title class_">RuleForm</span>&gt;&gt;(&#123;</span><br><span class="line">  <span class="attr">name</span>: [</span><br><span class="line">    &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;Please input Activity name&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">      <span class="comment">//message:当校验不通过时的提示语</span></span><br><span class="line">      <span class="comment">//trigger:在什么事件下发生的校验</span></span><br><span class="line">    &#123; <span class="attr">min</span>: <span class="number">3</span>, <span class="attr">max</span>: <span class="number">5</span>, <span class="attr">message</span>: <span class="string">&#x27;Length should be 3 to 5&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">region</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Please select Activity zone&#x27;</span>,</span><br><span class="line">      <span class="attr">trigger</span>: <span class="string">&#x27;change&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">count</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Please select Activity count&#x27;</span>,</span><br><span class="line">      <span class="attr">trigger</span>: <span class="string">&#x27;change&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">date1</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Please pick a date&#x27;</span>,</span><br><span class="line">      <span class="attr">trigger</span>: <span class="string">&#x27;change&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">date2</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Please pick a time&#x27;</span>,</span><br><span class="line">      <span class="attr">trigger</span>: <span class="string">&#x27;change&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">type</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;array&#x27;</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Please select at least one activity type&#x27;</span>,</span><br><span class="line">      <span class="attr">trigger</span>: <span class="string">&#x27;change&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">resource</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Please select activity resource&#x27;</span>,</span><br><span class="line">      <span class="attr">trigger</span>: <span class="string">&#x27;change&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">desc</span>: [</span><br><span class="line">    &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;Please input activity form&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>具体要求</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704210743461.png" alt="image-20230704210743461"></p>
<p>item通过<code>prop</code>指定绑定的规则片段,el-input双向绑定数据:<code>v-model</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704210910840.png" alt="image-20230704210910840"></p>
<p>组合式API</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704210255986.png" alt="image-20230704210255986"></p>
<h4 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704211003913.png" alt="image-20230704211003913"></p>
<p>小兔鲜项目要求:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704211505872.png" alt="image-20230704211505872"></p>
<p><strong>失去焦点时触发:blur事件</strong></p>
<p>规则代码<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704211955773.png" alt="image-20230704211955773"></p>
<p>下面是<strong>模板绑定数据</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704211934975.png" alt="image-20230704211934975"></p>
<h4 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705142750566.png" alt="image-20230705142750566"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705150613316.png" alt="image-20230705150613316"></p>
<p>这个value就是你绑定的<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705150632447.png" alt="image-20230705150632447"></p>
<p><code>v-model</code>.</p>
<h4 id="在用户点击按钮时-对所有规则统一校验"><a href="#在用户点击按钮时-对所有规则统一校验" class="headerlink" title="在用户点击按钮时,对所有规则统一校验"></a>在用户点击按钮时,对所有规则统一校验</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705150558050.png" alt="image-20230705150558050"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705151021067.png" alt="image-20230705151021067"></p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705151508242.png" alt="image-20230705151508242"></p>
<h3 id="登录业务"><a href="#登录业务" class="headerlink" title="登录业务"></a>登录业务</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705151723869.png" alt="image-20230705151723869"></p>
<p>封装接口</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705152754121.png" alt="image-20230705152754121"></p>
<p>在登录时的完整代码:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705180041482.png" alt="image-20230705180041482"></p>
<p>绑定到登录按钮的点击事件上:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705180106369.png" alt="image-20230705180106369"></p>
<p>如果想对许多接口做一个统一的错误处理:</p>
<p>使用axios的响应拦截器,做一个统一的错误处理</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705183750950.png" alt="image-20230705183750950"></p>
<p>主要就是error这个错误对象里面的res对象,包含有后端返回的data.</p>
<p>在响应拦截器中<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705183930392.png" alt="image-20230705183930392"></p>
<p>首先对res:响应对象做一层解包</p>
<p><code>response</code>-&gt;<code>response</code>.<code>data</code></p>
<h3 id="登录数据的管理"><a href="#登录数据的管理" class="headerlink" title="登录数据的管理"></a>登录数据的管理</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705184314850.png" alt="image-20230705184314850"></p>
<p>和数据相关的操作放到pinia里面,然后组件只负责触发action函数</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705184458879.png" alt="image-20230705184458879"></p>
<h4 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705193607230.png" alt="image-20230705193607230"></p>
<p><strong>在组件中执行函数,然后把数据给到userInfo这个变量中.</strong></p>
<p>在vue的调试工具中可以看到:具体详细的数据:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705193056562.png" alt="image-20230705193056562"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705193543249.png" alt="image-20230705193543249"></p>
<h4 id="持久化保持token存储"><a href="#持久化保持token存储" class="headerlink" title="持久化保持token存储"></a>持久化保持token存储</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705193944811.png" alt="image-20230705193944811"></p>
<h4 id="目的-保持token不丢失-保持登录状态"><a href="#目的-保持token不丢失-保持登录状态" class="headerlink" title="目的:保持token不丢失,保持登录状态"></a><strong>目的:保持token不丢失,保持登录状态</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. npm i pinia-plugin-persistedstate</span><br><span class="line"></span><br><span class="line">2. import piniaPluginPersistedstate from &quot;pinia-plugin-persistedstate&quot;; //引入pinia持久化插件</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705195016934.png" alt="image-20230705195016934"></p>
<p>安装插件后,直接在<code>defineStore</code>第三个参数下配置即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705194932425.png" alt="image-20230705194932425"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705195158802.png" alt="image-20230705195158802"></p>
<p><strong>前端在判断用户是否登录的重要指标就是判断用户的<code>token</code>值,<code>token存在就是登录了</code>,没存在就是没有登录.</strong></p>
<h4 id="多模板适配-权限管理"><a href="#多模板适配-权限管理" class="headerlink" title="多模板适配:权限管理."></a>多模板适配:权限管理.</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705200803805.png" alt="image-20230705200803805"></p>
<h4 id="axios请求拦截器携带token"><a href="#axios请求拦截器携带token" class="headerlink" title="axios请求拦截器携带token."></a>axios请求拦截器携带token.</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705201102729.png" alt="image-20230705201102729"></p>
<p>配置要求,<code>Bearer $&#123;token&#125;</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705201204000.png" alt="image-20230705201204000"></p>
<p>接口的鉴权,鉴权token::<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705202708915.png" alt="image-20230705202708915"></p>
<p>退出登录功能:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705203008237.png" alt="image-20230705203008237"></p>
<p>清除登录的逻辑在pinia中进行管理:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705211223742.png" alt="image-20230705211223742"></p>
<p>这两个函数是触发elpop组件的事件触发的.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705211248092.png" alt="image-20230705211248092"></p>
<p>使用节流,防止多次触发函数.</p>
<h4 id="登录的token失效-拦截失败status"><a href="#登录的token失效-拦截失败status" class="headerlink" title="登录的token失效,拦截失败status"></a>登录的token失效,拦截失败status</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230705211505279.png" alt="image-20230705211505279"></p>
<p>在请求失败的回调函数中拦截401,然后清除掉过期的用户信息.</p>
<p>之后跳转到登录页</p>
<h2 id="购物车组件"><a href="#购物车组件" class="headerlink" title="购物车组件"></a>购物车组件</h2><h3 id="购物车业务逻辑"><a href="#购物车业务逻辑" class="headerlink" title="购物车业务逻辑"></a>购物车业务逻辑</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706001235986.png" alt="image-20230706001235986"></p>
<p>搭架子:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706001730446.png" alt="image-20230706001730446"></p>
<p>添加input-number组件</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706001828820.png" alt="image-20230706001828820"></p>
<p>思路图:<strong>业务逻辑图!!!</strong> </p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706002500989.png" alt="image-20230706002500989"></p>
<p>经典在外面先声明一个全局变量:let skuObj &#x3D; {};</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706002330220.png" alt="image-20230706002330220"></p>
<p><code>如果添加过就count++</code></p>
<p>没添加过::<code>直接push</code></p>
<p>思路:<strong>通过匹配传递过来的商品对象中的skuID能不能在cartList中找到,如果找到了,就是添加过.</strong></p>
<p>因为是个数组列表,直接find遍历查找item即可.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706212243434.png" alt="image-20230706212243434"></p>
<h3 id="头部购物车"><a href="#头部购物车" class="headerlink" title="头部购物车"></a>头部购物车</h3><h4 id="渲染购物车组件"><a href="#渲染购物车组件" class="headerlink" title="渲染购物车组件"></a>渲染购物车组件</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706212354086.png" alt="image-20230706212354086"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706215250698.png" alt="image-20230706215250698"></p>
<h4 id="删除购物车内元素"><a href="#删除购物车内元素" class="headerlink" title="删除购物车内元素"></a>删除购物车内元素</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706214742569.png" alt="image-20230706214742569"></p>
<p><strong>主要是删除数组中的某一项元素</strong>.商品的<code>skuId</code>代表商品的唯一标识.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706215144736.png" alt="image-20230706215144736"></p>
<h4 id="头部购物车的统计计算"><a href="#头部购物车的统计计算" class="headerlink" title="头部购物车的统计计算"></a>头部购物车的统计计算</h4><p> <strong>把所有关于商品购物车的逻辑放到pinia仓库中统一进行管理!!!</strong></p>
<p>然后在pinia中使用计算属性<code>computed</code>写计算逻辑即可.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706215739955.png" alt="image-20230706215739955"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706220326907.png" alt="image-20230706220326907"></p>
<p>使用数组的reduce方法.做到数组元素的累加.迭代累加方法<code>reduce</code></p>
<p><code>Number.toFixed(2)</code>,保留两位小数.</p>
<h4 id="单选功能"><a href="#单选功能" class="headerlink" title="单选功能:"></a>单选功能:</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230707001436716.png" alt="image-20230707001436716"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230707002636786.png" alt="image-20230707002636786"></p>
<p>精髓之修改默认函数的参数,就拿到item里面的值了</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230707002705608.png" alt="image-20230707002705608"></p>
<h5 id="在默认参数的基础上-传入自己想要的参数"><a href="#在默认参数的基础上-传入自己想要的参数" class="headerlink" title="在默认参数的基础上,传入自己想要的参数:"></a>在默认参数的基础上,传入自己想要的参数:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708215445898.png" alt="image-20230708215445898"></h5><p><strong>外层包一层箭头函数</strong></p>
<h4 id="全选功能"><a href="#全选功能" class="headerlink" title="全选功能"></a>全选功能</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708215725289.png" alt="image-20230708215725289"></p>
<p>在pinia初始化一个isAll:<code>computed</code>,然后依赖是<strong>数组内的全部selected.</strong></p>
<p>箭头函数触发隐式return:**必须是<code>(item)=&gt;item % 2</code>这种格式.**如果是<code>(item)=&gt;&#123;item % 2&#125;</code>这种就不会隐式返回.</p>
<p>重点::<strong>{}</strong>;</p>
<p>触发<code>action</code>:将<strong>store</strong>中所有项的<strong>selected</strong>都<code>修改成isAll</code>的值.</p>
<p>action:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708220501792.png" alt="image-20230708220501792"></p>
<p>getter:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708220731225.png" alt="image-20230708220731225"></p>
<h3 id="接口购物车"><a href="#接口购物车" class="headerlink" title="接口购物车"></a>接口购物车</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708233245970.png" alt="image-20230708233245970"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">checkLogin</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">			<span class="keyword">let</span> isLogin = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">const</span> user = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">			<span class="keyword">const</span> &#123;</span><br><span class="line">				<span class="attr">userInfo</span>: &#123; token &#125;,</span><br><span class="line">			&#125; = user;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;token::: &quot;</span>, token);</span><br><span class="line">			<span class="keyword">if</span> (token) &#123;</span><br><span class="line">				isLogin.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				isLogin.<span class="property">value</span> = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> isLogin.<span class="property">value</span>;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></figure>

<p>不如直接从保存user的store中提取捏</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708233806693.png" alt="image-20230708233806693"></p>
<p>全局状态管理:pinia!!!!!!.</p>
<p>加入购物车:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708234846594.png" alt="image-20230708234846594"></p>
<p>典中典封装请求:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">params</span>: &#123;</span><br><span class="line">​      <span class="comment">//query参数在axios是通过params配置对象来传递的</span></span><br><span class="line">​      <span class="attr">id</span>: id,</span><br><span class="line">​    &#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title class_">XiaoTuXian</span>(&#123;</span><br><span class="line">		<span class="attr">url</span>: <span class="string">&quot;/category/goods/temporary&quot;</span>,</span><br><span class="line">		<span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">		<span class="attr">data</span>: data, <span class="comment">//请求体参数在axios是通过data配置对象来传递的</span></span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>



<h1 id="计算属性永远的神"><a href="#计算属性永远的神" class="headerlink" title="计算属性永远的神"></a>计算属性永远的神</h1><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230706222738297.png" alt="image-20230706222738297"></p>
<p><strong>改了1个小时没改好</strong>,加个<code>!</code>条件好了,我去!!!!!!!!!!!!.</p>
<h1 id="当你想修改别人写的样式的时候"><a href="#当你想修改别人写的样式的时候" class="headerlink" title="当你想修改别人写的样式的时候:"></a>当你想修改别人写的样式的时候:</h1><p><strong>先F12打开调试工具,选到你想修改的元素,然后去对应的地方＋样式然后直接看效果.</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704184129320.png" alt="image-20230704184129320"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230704184149333.png" alt="image-20230704184149333"></p>
<p>直接在底下的样式部分修改即可.</p>
<h1 id="为什么叫做组合式API"><a href="#为什么叫做组合式API" class="headerlink" title="为什么叫做组合式API"></a>为什么叫做组合式API</h1><p>把数据和方法,拆分出去在组合回来!!!!!!,组合的就是<code>代码逻辑</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230630160152926.png" alt="image-20230630160152926"></p>
<h1 id="axios发送的请求"><a href="#axios发送的请求" class="headerlink" title="axios发送的请求"></a>axios发送的请求</h1><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627200849597.png" alt="image-20230627200849597"></p>
<p>在fetch&#x2F;xhr的位置筛选看到</p>
<h1 id="人已经麻了"><a href="#人已经麻了" class="headerlink" title="人已经麻了"></a>人已经麻了</h1><p><strong>就是想在点击相应的树叶结点,然后切换到对应的样式</strong></p>
<p>结果搞了半天获取不到他对应的HTML元素</p>
<p>感觉还是得找到对应的index,然后直接绑定index即可,也就是使用for-each.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">resetNodeStyles</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> selectedNode = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.tree-node-selected&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (selectedNode) &#123;</span><br><span class="line">			<span class="comment">// selectedNode.classList.remove(&quot;tree-node-selected&quot;);</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">handleNodeClick</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> treeInstance = treeRef.<span class="property">value</span>;</span><br><span class="line">		<span class="keyword">const</span> nodeId = data.<span class="property">$treeNodeId</span>;</span><br><span class="line">		<span class="title function_">resetNodeStyles</span>();</span><br><span class="line">		<span class="keyword">const</span> nodeElement = treeInstance.<span class="title function_">getNode</span>(nodeId);</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;nodeElement::: &quot;</span>, nodeElement);</span><br><span class="line">		<span class="comment">// nodeElement.classList.add(&quot;tree-node-selected&quot;);</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//暂时得不到这个element元素,麻了</span></span><br></pre></td></tr></table></figure>

<p>删除pnpm的node_module记得关闭<strong>vscode</strong></p>
<h2 id="引入tailwindCSS"><a href="#引入tailwindCSS" class="headerlink" title="引入tailwindCSS"></a>引入tailwindCSS</h2><h3 id="Install-Tailwind-CSS-with-Vite"><a href="#Install-Tailwind-CSS-with-Vite" class="headerlink" title="Install Tailwind CSS with Vite"></a>Install Tailwind CSS with Vite</h3><p><a href="https://www.tailwindcss.cn/docs/guides/vite#vue">Install Tailwind CSS with Vite - TailwindCSS中文文档 | TailwindCSS中文网</a></p>
<p>直接看这个文档,一步步跟着来即可</p>
<p>Installation</p>
<p>具体先下载如下三个插件::</p>
<p><code>npm install -D tailwindcss postcss autoprefixernpx</code></p>
<p>然后运行这个命令</p>
<p><code>npx tailwindcss init -p</code></p>
<p>然后就会多出来两个文件</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627155720415.png" alt="image-20230627155720415"></p>
<p><strong>postcss和tailwindCSS</strong></p>
<p>然后运行下面的东西即可</p>
<ol>
<li><h2 id="Configure-your-template-paths"><a href="#Configure-your-template-paths" class="headerlink" title="Configure your template paths"></a>Configure your template paths</h2><p>Add the paths to all of your template files in your <code>tailwind.config.js</code> file.</p>
<p>tailwind.config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */</span><br><span class="line">export default &#123;</span><br><span class="line">  content: [</span><br><span class="line">    &quot;./index.html&quot;,</span><br><span class="line">    &quot;./src/**/*.&#123;vue,js,ts,jsx,tsx&#125;&quot;,</span><br><span class="line">  ],</span><br><span class="line">  theme: &#123;</span><br><span class="line">    extend: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="Add-the-Tailwind-directives-to-your-CSS"><a href="#Add-the-Tailwind-directives-to-your-CSS" class="headerlink" title="Add the Tailwind directives to your CSS"></a>Add the Tailwind directives to your CSS</h2><p>Add the <code>@tailwind</code> directives for each of Tailwind’s layers to your <code>./src/style.css</code> file.</p>
<p><code>style.css</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@tailwind base;</span><br><span class="line">@tailwind components;</span><br><span class="line">@tailwind utilities;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入配置如图</p>
</li>
<li><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627155908745.png" alt="image-20230627155908745"></p>
</li>
<li><p>直接把这个style文件放到src文件夹下即可<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627155928325.png" alt="image-20230627155928325"></p>
</li>
<li><h2 id="Start-your-build-process"><a href="#Start-your-build-process" class="headerlink" title="Start your build process"></a>Start your build process</h2><p>Run your build process with <code>npm run dev</code>.</p>
<p>Terminal</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="Start-using-Tailwind-in-your-project"><a href="#Start-using-Tailwind-in-your-project" class="headerlink" title="Start using Tailwind in your project"></a>Start using Tailwind in your project</h2><p>Start using Tailwind’s utility classes to style your content.</p>
<p>App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 class=&quot;text-3xl font-bold underline&quot;&gt;</span><br><span class="line">    Hello world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Copyright © 2023 Tailwind Labs Inc.</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/post/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="调整vscode的窗口大小"><a href="#调整vscode的窗口大小" class="headerlink" title="调整vscode的窗口大小"></a>调整vscode的窗口大小</h1><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626194730446.png" alt="image-20230626194730446"></p>
<p>设置为1即可<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626194745909.png" alt="image-20230626194745909"></p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="其实学习最好还是有实际的代码例子和一个为你讲解的人"><a href="#其实学习最好还是有实际的代码例子和一个为你讲解的人" class="headerlink" title="其实学习最好还是有实际的代码例子和一个为你讲解的人."></a>其实学习最好还是有实际的代码例子和一个为你讲解的人.</h2><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="不要管那些无聊并且复杂的从英文翻译过来的概念"><a href="#不要管那些无聊并且复杂的从英文翻译过来的概念" class="headerlink" title="不要管那些无聊并且复杂的从英文翻译过来的概念"></a>不要管那些无聊并且复杂的从英文翻译过来的概念</h3><h3 id="多问问chatGpt-然后多从代码的角度去理解"><a href="#多问问chatGpt-然后多从代码的角度去理解" class="headerlink" title="多问问chatGpt,然后多从代码的角度去理解"></a>多问问chatGpt,然后<strong>多从代码的角度去理解</strong></h3><h3 id="多多使用chatGpt学习"><a href="#多多使用chatGpt学习" class="headerlink" title="多多使用chatGpt学习"></a>多多使用chatGpt学习</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提供了一个数组结构的 data，要求实现一个 query 方法，返回一个新的数组，query 方法内部有 过滤、排序、分组 等操作，并且支持链式调用，调用最终的 execute 方法返回结果：</span></span><br><span class="line"><span class="comment">// 请不要使用原生的数组 filter 方法，原生的数组 sort 方法,完全使用js代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataQuery</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">operations</span> = [];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">filter</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">operations</span>.<span class="title function_">push</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> filteredData = [];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="title function_">callback</span>(data[i])) &#123;</span><br><span class="line">					filteredData.<span class="title function_">push</span>(data[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> filteredData;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">sort</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">operations</span>.<span class="title function_">push</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> sortedData = data.<span class="title function_">slice</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sortedData.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; sortedData.<span class="property">length</span>; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="title function_">callback</span>(sortedData[j], sortedData[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">const</span> temp = sortedData[i];</span><br><span class="line">						sortedData[i] = sortedData[j];</span><br><span class="line">						sortedData[j] = temp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sortedData;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">groupBy</span>(<span class="params">key</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">operations</span>.<span class="title function_">push</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> groups = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">			data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">const</span> value = item[key];</span><br><span class="line">				groups[value] = groups[value] || [];</span><br><span class="line">				groups[value].<span class="title function_">push</span>(item);</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(groups);</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">operations</span>.<span class="title function_">reduce</span>(</span><br><span class="line">			<span class="function">(<span class="params">result, operation</span>) =&gt;</span> <span class="title function_">operation</span>(result),</span><br><span class="line">			<span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&quot;Charlie&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&quot;David&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">&quot;Eve&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">DataQuery</span>(data)</span><br><span class="line">	.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">age</span> &gt; <span class="number">25</span>)</span><br><span class="line">	.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">age</span> - b.<span class="property">age</span>)</span><br><span class="line">	.<span class="title function_">groupBy</span>(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">	.<span class="title function_">execute</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="comment">// =&gt; [</span></span><br><span class="line"><span class="comment">//      [&#123; name: &#x27;Eve&#x27;, age: 30 &#125;, &#123; name: &#x27;Bob&#x27;, age: 30 &#125;],</span></span><br><span class="line"><span class="comment">//      [&#123; name: &#x27;Alice&#x27;, age: 25 &#125;, &#123; name: &#x27;David&#x27;, age: 25 &#125;],</span></span><br><span class="line"><span class="comment">//      [&#123; name: &#x27;Charlie&#x27;, age: 20 &#125;]</span></span><br><span class="line"><span class="comment">//    ]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="以下是递归和迭代"><a href="#以下是递归和迭代" class="headerlink" title="以下是递归和迭代"></a>以下是递归和迭代</h3><p>中文中的”迭代”和”递归”译成英文分别是”iteration”和”recursion”。在编程中，这两个概念都是控制程序执行的方式。</p>
<p><strong>迭代通常使用循环语句，例如for循环或while循环</strong>，重复执行代码块直到满足特定条件。迭代通常用于处理大量数据，例如列表或数组等。通过对列表或数组等结构进行迭代遍历，可以在代码中对其中的每个元素执行特定的操作。以下是一个使用Python for循环迭代列表的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">numbers = [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">for number in numbers:</span><br><span class="line">    print(number)</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>



<p>递归是一种在函数内部自引用的技术。递归函数不断调用自身，直到达到某个终止条件。递归通常用于解决问题，其中问题可以分解为子问题，这些子问题可以与原问题具有相同的解决方案。递归在分析和操作树和图形结构时非常有用。以下是一个使用Python实现递归的示例，计算一个数字的阶乘：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def factorial(n):</span><br><span class="line">    if n == 0:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return n * factorial(n-1)</span><br><span class="line"></span><br><span class="line">print(factorial(5))</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">120</span><br></pre></td></tr></table></figure>



<p>该代码中的 <code>factorial()</code> 函数在自身内部多次调用，将 5 不断减 1，直到达到终止条件，即 <code>n</code> 等于 0。因此，<code>factorial(5)</code> 实际上是执行了以下计算：5 * 4 * 3 * 2 * 1 &#x3D; 120。</p>
<p>总的来说，迭代和递归都是使用编程语言控制程序执行流程的技术。迭代通常用于遍历数据结构，而递归通常用于解决分治问题。</p>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1.动态规划,"></a>1.动态规划,</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>递归就是在一个函数中,这个函数内部的代码不停的重复调用自己,从代码的角度看即可</strong>,函数内部不断调用自己,以同样的方法不断计算</p>
<p>通过一个对象(<strong>对象就是哈希表</strong>:<code>let memory = &#123; &#125;</code>)去储存结果值,然后在搜索的时候,如果这个结果存在于对象<code>&#123; &#125;</code>中,直接return对象:<code>&#123; &#125;</code>中储存的结果值即可</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230527122936021.png" alt="image-20230527122936021"></p>
<p>这里的memo就是定义了一个对象</p>
<p>去保存计算的中间结果,然后得到储存的结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">memo=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">in</span> memo:</span><br><span class="line">    <span class="keyword">return</span> memo[i]</span><br></pre></td></tr></table></figure>

<p><strong>这就是用存储空间换执行时间</strong>,<code>带备忘录(memo)的递归</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230527123136647.png" alt="image-20230527123136647"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230527123253734.png" alt="image-20230527123253734"></p>
<p>迭代在代码中就是利用循环解题</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230527123843189.png" alt="image-20230527123843189"></p>
<p><strong>迭代就是循环</strong>,循环就是迭代.</p>
<h2 id="js中事件监听器可以添加的事件类型"><a href="#js中事件监听器可以添加的事件类型" class="headerlink" title="js中事件监听器可以添加的事件类型"></a>js中事件监听器可以添加的事件类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;h1&gt;Home&lt;/h1&gt;</span><br><span class="line">		&lt;details</span><br><span class="line">			class=&quot;dropdown mb-32&quot;</span><br><span class="line">			ref=&quot;details&quot;&gt;</span><br><span class="line">			&lt;summary class=&quot;m-1 btn&quot;&gt;open or close&lt;/summary&gt;</span><br><span class="line">			&lt;ul</span><br><span class="line">				class=&quot;p-2 shadow menu dropdown-content z-[1] bg-base-100 rounded-box w-52&quot;&gt;</span><br><span class="line">				&lt;li&gt;&lt;a&gt;Item 1&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">				&lt;li&gt;&lt;a&gt;Item 2&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">			&lt;/ul&gt;</span><br><span class="line">		&lt;/details&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">	const emit = defineEmits([&quot;change&quot;]);</span><br><span class="line">	const details = ref(null);</span><br><span class="line">	onMounted(() =&gt; &#123;</span><br><span class="line">		const ul = details.value.querySelector(&quot;ul&quot;);</span><br><span class="line">		const li = ul.querySelectorAll(&quot;li&quot;);</span><br><span class="line">		//获取li内部元素的值</span><br><span class="line">		li.forEach((item) =&gt; &#123;</span><br><span class="line">			item.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">				emit(&quot;change&quot;, item.innerText);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当使用 <code>addEventListener()</code> 来为一个 DOM 元素或窗口添加事件处理程序时，我们必须指定一个要处理的事件类型和一个事件处理函数，当该事件类型被触发时，该事件处理函数就会被执行。</p>
<p><strong>以下是常见的 HTML DOM 元素事件：</strong></p>
<ul>
<li><code>click</code>：当元素被点击时触发。</li>
<li><code>dblclick</code>：当元素被双击时触发。</li>
<li><code>mousedown</code>：当左键在元素上被按下时触发。</li>
<li><code>mousemove</code>：当鼠标在元素上移动时触发。</li>
<li><code>mouseout</code>：当鼠标移出元素时触发。</li>
<li><code>mouseover</code>：当鼠标悬停在元素上时触发。</li>
<li><code>mouseup</code>：当左键在元素上被松开时触发。</li>
<li><code>keydown</code>：当键盘上的键被按下时触发。</li>
<li><code>keyup</code>：当键盘上的键被松开时触发。</li>
<li><code>focus</code>：当元素获取焦点时触发。</li>
<li><code>blur</code>：当元素失去焦点时触发。</li>
<li><code>change</code>：当元素的值发生改变时触发。</li>
<li><code>submit</code>：当表单被提交时触发。</li>
<li><code>reset</code>：当表单被重置时触发。</li>
<li><code>load</code>：当文档或某个元素的内容（如图像）被加载时触发。</li>
<li><code>unload</code>：当文档或某个元素的内容被卸载时触发。</li>
</ul>
<p><strong>以下是常见的 window 事件：</strong></p>
<ul>
<li><code>load</code>：当浏览器完成页面加载时触发。</li>
<li><code>unload</code>：当窗口正在被卸载时触发。</li>
<li><code>resize</code>：当窗口的大小被改变时触发。</li>
<li><code>scroll</code>：当元素的滚动条被滚动时触发。</li>
<li><code>contextmenu</code>：当用户右击鼠标时触发。</li>
</ul>
<p>此外，除了这些常用的事件类型之外，还有一些其他的自定义事件可以使用，通常使用自定义事件可以实现更复杂的功能和逻辑。</p>
<h2 id="事件监听的版本"><a href="#事件监听的版本" class="headerlink" title="事件监听的版本"></a>事件监听的版本</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230507152154201.png" alt="image-20230507152154201"></p>
<p>onclick相当于给dom元素对象赋值,所以事件是会被覆盖的,只能触发最后设定的onclick,</p>
<p>但是addEventlistener则是添加事件,可以绑定给btn这个元素多次</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230507152413933.png" alt="image-20230507152413933"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230507152711931.png" alt="image-20230507152711931"></p>
<h2 id="1-web-api：元素获取。"><a href="#1-web-api：元素获取。" class="headerlink" title="1.web api：元素获取。"></a>1.web api：元素获取。</h2><h4 id="1-web的应用程序接口"><a href="#1-web的应用程序接口" class="headerlink" title="1.web的应用程序接口"></a>1.web的应用程序接口</h4><h4 id="web的对象，就是dom（文档对象模型），和bom（浏览器对象模型）"><a href="#web的对象，就是dom（文档对象模型），和bom（浏览器对象模型）" class="headerlink" title="web的对象，就是dom（文档对象模型），和bom（浏览器对象模型）"></a>web的对象，就是dom（文档对象模型），和bom（浏览器对象模型）</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304125049832.png" alt="image-20230304125049832"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304125240801.png" alt="image-20230304125240801"></p>
<p>2.由标签生成的js对象，有属性和方法。修改属性会映射到标签上。</p>
<p>3.html里叫标签，js中是对象。</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304130332600.png" alt="image-20230304130332600"></p>
<p>4.document是整个网页的文档，最大的。</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304130425670.png" alt="image-20230304130425670"></p>
<p>使用css选择器在js中选择。</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304131120773.png" alt="image-20230304131120773"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304131826370.png" alt="image-20230304131826370"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304132019245.png" alt="image-20230304132019245"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304132046073.png" alt="image-20230304132046073"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304132253764.png" alt="image-20230304132253764"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304134350941.png" alt="image-20230304134350941"></p>
<p>已经被淘汰的原始方式<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304134838993.png" alt="image-20230304134838993"></p>
<h2 id="2-innerText添加js变量到网页"><a href="#2-innerText添加js变量到网页" class="headerlink" title="2.,innerText添加js变量到网页."></a>2.,innerText添加js变量到网页.</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304140201445.png" alt="image-20230304140201445"></p>
<p>2.innerHTML：<strong>解析取值中的标签</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304140409847.png" alt="image-20230304140409847"></p>
<p>3.总结</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230304140459354.png" alt="image-20230304140459354"></p>
<h2 id="3-new关键字"><a href="#3-new关键字" class="headerlink" title="3.new关键字"></a>3.new关键字</h2><ol>
<li><p>首先创建了一个空的对象</p>
</li>
<li><p>将这个空对象的原型指向了（原来用于构造这个对象的构造函数）的原型</p>
<p> <code>person.prototype == new person.__proto__</code></p>
<p> 返回true。</p>
<p> 3.将空对象作为先前this的指向。</p>
<p> 4.如果在构造函数内部返回基本数据类型，则忽略返回值。</p>
<p> 若返回对象，则new就是创建这个返回对象</p>
</li>
</ol>
<h2 id="4-js的事件监听"><a href="#4-js的事件监听" class="headerlink" title="4.js的事件监听"></a>4.js的事件监听</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230227190927749.png" alt="image-20230227190927749"></p>
<p><strong>mouseover</strong>：鼠标移动。</p>
<p>事件源就是<strong>dom元素</strong></p>
<p>类型和触发函数。<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230227191346585.png" alt="image-20230227191346585"></p>
<p>将button转化为对象。事件监听就是方法。每次触发都会进行函数。</p>
<h2 id="5-web操作元素属性。"><a href="#5-web操作元素属性。" class="headerlink" title="5.web操作元素属性。"></a>5.web操作元素属性。</h2><p>style,简单修改标签的css样式,style这个对象的属性基本是整个css</p>
<p>和classlist: remove()去除一个类</p>
<p>append ()添加一个类名字</p>
<p>toggle()切换一个类!</p>
<h2 id="6-herf和src的区别"><a href="#6-herf和src的区别" class="headerlink" title="6.herf和src的区别"></a>6.herf和src的区别</h2><p>herf相当于超文本的引用 hypertext reference.<strong>建立了一个通道</strong>,让用户点击访问,但<strong>仅仅就是一扇门</strong>.实际上<strong>资源不在本地</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230307183056945.png" alt="image-20230307183056945"></p>
<p>但是src是资源的路径.</p>
<p>src<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230307183217017.png" alt="image-20230307183217017"></p>
<p>src相当于吃豆人一样<strong>吃下去资源</strong>,而且<strong>下载在本地</strong>,相当于汽车在加油,<strong>加完油就是加载资源</strong>,期间其他的标签只能<strong>等待</strong>src指向的<strong>资源加载完</strong>,<strong>资源是挂载在文档的(即网页上的</strong>).</p>
<ul>
<li><a href="https://dev.to/dance2die/href-vs-src-in-html-10l7">href属性的资源是根据一个触发器来加载的，比如用户点击了一个链接；而src属性的资源是自动加载的，不需要用户干预</a><a href="https://dev.to/dance2die/href-vs-src-in-html-10l7">3</a><a href="https://www.sung.codes/blog/2019/href-vs-src-in-html">4</a>。</li>
<li><a href="https://stackoverflow.com/questions/3395359/difference-between-src-and-href">href属性的资源是作为文档的一部分来处理的，比如样式表会影响文档的外观；而src属性的资源是作为独立的实体来处理的，比如图片会显示在文档中</a><a href="https://stackoverflow.com/questions/3395359/difference-between-src-and-href">5</a>。</li>
</ul>
<h2 id="7-WINdows对象"><a href="#7-WINdows对象" class="headerlink" title="7.WINdows对象"></a>7.WINdows对象</h2><h3 id="1-1BOM对象"><a href="#1-1BOM对象" class="headerlink" title="1.1BOM对象"></a>1.1BOM对象</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230306184447967.png" alt="image-20230306184447967"></p>
<p><strong>通过js跳转页面:location.</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">num</span>);<span class="comment">//通过var关键字定义的对象,默认是全局变量,并且挂载在window上.</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-定时器-延时函数"><a href="#2-2-定时器-延时函数" class="headerlink" title="2.2.定时器:延时函数."></a>2.2.定时器:延时函数.</h3><p>定时炸弹.(一次性的),只执行一次.</p>
<p>一直会运行的:setInterval().(间歇函数)</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230306185433314.png" alt="image-20230306185433314"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230306185714844.png" alt="image-20230306185714844"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230306185802225.png" alt="image-20230306185802225"></p>
<p>都是bom对象的方法.  	window.setTimeout.</p>
<p>该函数返回的是数字id</p>
<p>执行的次数不同:</p>
<p>setTimeout()执行一次,但是setInterval()(翻译:设置间隔)就是不停的执行.</p>
<h2 id="3-3-js执行机制"><a href="#3-3-js执行机制" class="headerlink" title="3.3.js执行机制:"></a>3.3.js执行机制:</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230306214406289.png" alt="image-20230306214406289"></p>
<p>我先添加,再进行删除.<strong>单线程</strong>导致<strong>页面不连贯</strong>.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2222</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3333</span>);</span><br><span class="line">        <span class="comment">//单线程处理,打印结果是111,3333,2222,尽管毫秒＝0.</span></span><br></pre></td></tr></table></figure>

<h4 id="js中的同步和异步"><a href="#js中的同步和异步" class="headerlink" title="js中的同步和异步:"></a>js中的同步和异步:</h4><p>为了利用利用多核cpu的计算能力.允许js脚本创建多个线程.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230306215104747.png" alt="image-20230306215104747"></p>
<p>先找到所有的执行栈,而异步任务都是耗时间的,二者的任务队列不同</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230306215232912.png" alt="image-20230306215232912"></p>
<p><strong>回调函数:以函数为参数使用匿名函数,即没取名字的函数,主要是为了方便</strong></p>
<p>先执行<strong>执行栈中的同步任务</strong>😁🥰</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230306215943284.png" alt="image-20230306215943284"></p>
<p>事件循环:执行完主车道的任务,然后执行应急车道的任务.执行完异步的函数和事件(应急车道)后,继续执行主车道的任务,然后不断循环,知道事件全部执行完成.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230306220424639.png" alt="image-20230306220424639"></p>
<p>粉色框圈的是耗费时间的任务,耗费时间完成后,推入到任务队列里面去,然后执行栈会不断的循环查看任务队列</p>
<h2 id="4-4浏览器的本地存储"><a href="#4-4浏览器的本地存储" class="headerlink" title="4.4浏览器的本地存储"></a>4.4浏览器的本地存储</h2><h3 id="4-1介绍"><a href="#4-1介绍" class="headerlink" title="4.1介绍:"></a>4.1介绍:</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308211605540.png" alt="image-20230308211605540"></p>
<p><strong>没有解决跨域问题,不同域名不能互相访问本地存储</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308211906466.png" alt="image-20230308211906466"></p>
<p>setitem都是<strong>字符串</strong>传入进去,<strong>不带引号</strong>就是<strong>变量</strong></p>
<p>获取:getItem(“key”).删除本地存储:removeItem(“key”);</p>
<p>本地查看:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308212209132.png" alt="image-20230308212209132"></p>
<p>全部:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308212432766.png" alt="image-20230308212432766"></p>
<p>本地存储<strong>只能</strong>存储<strong>字符串数据类型</strong>.</p>
<h3 id="4-2-sessionStorage"><a href="#4-2-sessionStorage" class="headerlink" title="4.2:sessionStorage"></a>4.2:sessionStorage</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308212720632.png" alt="image-20230308212720632"></p>
<h3 id="4-3总结"><a href="#4-3总结" class="headerlink" title="4.3总结:"></a>4.3总结:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308212830062.png" alt="image-20230308212830062"></h3><h3 id="4-4存储对象"><a href="#4-4存储对象" class="headerlink" title="4.4存储对象"></a>4.4存储对象</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308214311121.png" alt="image-20230308214311121"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308215251448.png" alt="image-20230308215251448"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308215305055.png" alt="image-20230308215305055"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308215513875.png" alt="image-20230308215513875"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308215618342.png" alt="image-20230308215618342"></p>
<p><strong>本地存储只能存储字符串</strong></p>
<h2 id="5-1综合案例"><a href="#5-1综合案例" class="headerlink" title="5.1综合案例"></a>5.1综合案例</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308215941596.png" alt="image-20230308215941596"></p>
<h2 id="数组中的-map方法"><a href="#数组中的-map方法" class="headerlink" title="数组中的:map方法"></a>数组中的:map方法</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308221335779.png" alt="image-20230308221335779"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230308222034604.png" alt="image-20230308222034604"></p>
<h2 id="8-JS中的数组方法"><a href="#8-JS中的数组方法" class="headerlink" title="8.JS中的数组方法"></a>8.JS中的数组方法</h2><h3 id="2-数组方法"><a href="#2-数组方法" class="headerlink" title="2.数组方法"></a>2.数组方法</h3><p>程序员最常用的方法是 <code>Array.forEach()</code> 和 <code>Array.filter()</code>，以及 <code>Object.assign()</code>。</p>
<h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><ul>
<li><strong>Array.forEach()：</strong> 对数组中的每个元素都执行一次回调函数，没有返回值。常用于遍历数组并执行一些操作。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">array.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`array[<span class="subst">$&#123;index&#125;</span>] = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// array[0] = 1</span></span><br><span class="line"><span class="comment">// array[1] = 2</span></span><br><span class="line"><span class="comment">// array[2] = 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Array.map()：</strong> 将数组中的每个元素都传递给一个回调函数,同时执行一次回调函数内部的代码，将每个回调函数的返回值组成一个新的数组返回。通常用于将一个数组转换为另一个数组。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = array1.<span class="title function_">map</span>(<span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array2); <span class="comment">// 输出 [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Array.filter()：</strong> 将数组中的每个元素都传递给一个回调函数，只有回调函数返回真值的元素才会被保留，并组成一个新的数组返回。通常用于过滤数组中的元素。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = array1.<span class="title function_">filter</span>(<span class="function"><span class="params">value</span> =&gt;</span> value % <span class="number">2</span> === <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array2); <span class="comment">// 输出 [1, 3]</span></span><br><span class="line">cars.<span class="property">value</span> = carsData.<span class="title function_">filter</span>(<span class="function">(<span class="params">car</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> car.<span class="property">make</span> === make.<span class="property">value</span>;</span><br><span class="line">    <span class="comment">//过滤条件就是car.make===make.value,返回对应的car元素</span></span><br><span class="line">			&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Array.find()：</strong> 从数组中查找符合条件的第一个元素，并返回指向该元素的指针(<code>内存地址</code>)。通常用于查找数组中的元素。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> value = array.<span class="title function_">find</span>(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><ul>
<li><strong>Array.push()：</strong> 向数组末尾添加一个或多个元素，并返回新数组的长度。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> length = array.<span class="title function_">push</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);  <span class="comment">// 输出 [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(length); <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Array.pop()：</strong> 从数组末尾弹出一个元素，并返回该元素的值。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> value = array.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// 输出 [1, 2]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Array.unshift()：</strong> 向数组开头添加一个或多个元素，并返回新数组的长度。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> length = array.<span class="title function_">unshift</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);  <span class="comment">// 输出 [1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(length); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Array.shift()：</strong> 从数组开头弹出一个元素，并返回该元素的值。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> value = array.<span class="title function_">shift</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// 输出 [2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Array.sort()：</strong> 对数组中的元素进行排序，并返回排序后的数组。如果不传递任何参数，默认按照 Unicode 字符顺序进行排序。例如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">array.<span class="title function_">sort</span>(); <span class="comment">// 按照 Unicode 字符顺序排序</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// 输出 [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array2 = [&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;Charlie&quot;</span> &#125;];</span><br><span class="line">array2.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (a.<span class="property">name</span> &gt; b.<span class="property">name</span>) ? <span class="number">1</span> : -<span class="number">1</span>); <span class="comment">// 按照 name 属性升序排序</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array2); <span class="comment">// 输出 [&#123; name: &quot;Alice&quot; &#125;, &#123; name: &quot;Bob&quot; &#125;, &#123; name: &quot;Charlie&quot; &#125;]</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Array.reverse()：</strong> 反转数组中元素的顺序，并返回反转后的数组。例如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">array.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// 输出 [3, 2, 1]</span></span><br></pre></td></tr></table></figure>



<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul>
<li><strong>Array.concat()：</strong> 将两个或多个数组合并成一个新数组，并返回该新数组。例如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> array3 = array1.<span class="title function_">concat</span>(array2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array3); <span class="comment">// 输出 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Array.slice()：</strong> 返回数组中指定部分的浅拷贝。包括 start，不包括 end。例如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> slice1 = array.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> slice2 = array.<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(slice1); <span class="comment">// 输出 [2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(slice2); <span class="comment">// 输出 [3, 4, 5]</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Array.includes()：</strong> 判断数组中是否包含某个元素，返回 Boolean 类型的值。例如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">includes</span>(<span class="number">2</span>)); <span class="comment">// 输出 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">includes</span>(<span class="number">4</span>)); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Array.indexOf()、Array.lastIndexOf()：</strong> 分别从数组前后两个方向查找某个元素第一次&#x2F;最后一次出现的位置，如果找到则返回该元素的下标，否则返回 -1。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const array = [1, 2, 3, 2];</span><br><span class="line">console.log(array.indexOf(2));     // 输出 1</span><br><span class="line">console.log(array.lastIndexOf(2)); // 输出 3</span><br><span class="line">console.log(array.indexOf(4));     // 输出 -1</span><br></pre></td></tr></table></figure>

<h2 id="2-函数的arguments对象"><a href="#2-函数的arguments对象" class="headerlink" title="2.函数的arguments对象"></a>2.函数的arguments对象</h2><p>在JavaScript中，每个函数都有一个特殊的内部对象arguments。 arguments对象包含了函数调用时传递给函数的参数列表。 arguments对象的作用在于访问和操作实参列表，可以在函数内部获取和使用实参值。</p>
<p>arguments对象在不确定参数数量的函数调用中非常有用。你可以通过 arguments对象在函数内部处理不确定数量的参数。</p>
<p>arguments对象是一个类数组对象，因此可以使用数组相关的性质来访问各个元素。</p>
<p>以下是一个例子说明arguments对象的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy codefunction Adder() &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    for(var i =0; i&lt; arguments.length;i++)&#123;</span><br><span class="line">        sum += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = Adder(1,2,3,4,5);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>

<p>在上面代码中，我们定义了一个函数Adder，它没有明确的参数个数，函数内部通过arguments对象来访问传入的参数列表。通过遍历这个arguments对象，我们将传入的所有参数相加并返回它们的和。在函数调用时，我们传了 1,2,3,4,5 五个参数，函数内部就会对这些参数求和并返回它们的和。</p>
<p>需要注意的事项： arguments对象和参数表示出现的位置有关，是类数组对象，不是数组，即不能使用数组对象的方法和属性，比如不能使用length属性，不能使用sort()方法等，但是可以使用一些其他的技巧来将arguments转换为数组，例如使用Array.from()或者通过Array.prototype.slice.call(arguments)方法，将其转化成真正的数组对象。</p>
<h2 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3.箭头函数"></a>3.箭头函数</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230311104642110.png" alt="image-20230311104642110"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230311104651097.png" alt="image-20230311104651097"></p>
<p>这是因为普通函数的this是<strong>动态绑定</strong>的,<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230311104825706.png" alt="image-20230311104825706"></p>
<p>异步函数setTimeout在<strong>执行栈里面的任务执行完才会被window对象执行</strong>,所以这个时候的this 就绑定在window对象上,而window对象上是没有bibi的.</p>
<p>但是<strong>箭头函数</strong>的<strong>this</strong>是<strong>静态</strong>的,不会出现动态定义的情况.同时它被函数包裹的时候,</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230311105238286.png" alt="image-20230311105238286"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230311104622985.png" alt="image-20230311104622985"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230311105719712.png" alt="image-20230311105719712"></p>
<p><strong>箭头函数的this值就取决于外部普通函数的this值</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230311105843601.png" alt="image-20230311105843601"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230311110045314.png" alt="image-20230311110045314"></p>
<h2 id="9-js中的throw和try-catch"><a href="#9-js中的throw和try-catch" class="headerlink" title="9.js中的throw和try_catch"></a>9.js中的throw和try_catch</h2><h3 id="1-throw"><a href="#1-throw" class="headerlink" title="1.throw"></a>1.throw</h3><p>在 JavaScript 中，<code>throw</code> 用于抛出异常。可以通过 throw 语句将控制权传递回代码的调用者，以便它们可以处理异常。语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Copy</span> code</span><br><span class="line"><span class="keyword">throw</span> expression;</span><br></pre></td></tr></table></figure>

<p>其中，expression 是要抛出的异常对象。</p>
<p>例如，以下代码将抛出一个类型为 Error 的异常：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Copy</span> code</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something went wrong.&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>当这个异常被抛出时，它将会被传递回调用堆栈，直到找到一个 try-catch 语句来处理它。如果没有可用的 try-catch 语句来处理异常，程序将会终止并在控制台中输出错误信息。</p>
<h3 id="2-try-catch"><a href="#2-try-catch" class="headerlink" title="2.try-catch"></a>2.try-catch</h3><p>在 JavaScript 中，<code>try-catch</code> 是一种错误处理机制，用于捕捉可能会导致程序崩溃的异常，并在发生异常时执行一些特定的代码。</p>
<p><code>try-catch</code> 语句由 <code>try</code> 代码块和至少一个 <code>catch</code> 代码块组成。<code>try</code> 代码块包含了可能会抛出异常的代码，而 <code>catch</code> 代码块包含了异常处理程序，用于捕获 <code>try</code> 代码块中抛出的异常，并执行必要的错误处理逻辑。</p>
<p>以下是使用 <code>try-catch</code> 语句的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copy codetry &#123;</span><br><span class="line">  // 可能抛出异常的代码</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  // 处理异常的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 try 代码块中的代码抛出异常时，异常将被包含在一个 JavaScript 对象中（通常是一个 Error 对象），并传递到 catch 代码块中的 error 参数中。您可以使用 error 对象的方法和属性来了解异常的原因及其他相关信息，并执行必要的错误处理逻辑。如果不需要在 catch 中执行任何特定的操作，也可以空着 catch 块，这样就不会处理任何异常。</p>
<p>需要注意的是，catch 块必须紧随 try 块之后，而且在同一个代码块中。如果将 catch 块放置在 try 块之外，则会导致语法错误。</p>
<p>使用 <code>try-catch</code> 可以使程序更加容错，避免因为一些意外的错误而使程序无法正常运行。</p>
<h3 id="3-new-Error"><a href="#3-new-Error" class="headerlink" title="3.new Error"></a>3.new Error</h3><p><code>Error</code> 是 JavaScript 中的一个内置对象，用于表示程序的运行时错误，它能够被抛出（throw）和捕获（catch）。 <code>new Error()</code> 创建一个新的错误对象实例，可通过 <code>throw</code> 抛出并且抛出后会被 <code>catch</code> 捕获。当发生错误时，可以使用 <code>Error</code> 报告错误的具体信息，可以包括错误消息、堆栈跟踪和错误码等。</p>
<p>以下是一个例子，展示了如何使用 <code>Error</code> 对象来创建和抛出一个错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num2 === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>); <span class="comment">// 抛出一个错误</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num1 / num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">divide</span>(<span class="number">10</span>, <span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>); <span class="comment">// 捕获错误并输出错误消息: &quot;Cannot divide by zero&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个名为 <code>divide</code> 的函数，它的作用是计算两个数字的除法。如果第二个参数为 <code>0</code>，则会抛出一个 <code>Error</code>，表示除数为零是无效的操作。 接下来我们在 <code>try-catch</code> 块中测试这个函数，当出现错误时， <code>catch</code> 块会捕获到这个错误并输出错误消息。</p>
<h2 id="10-异步操作"><a href="#10-异步操作" class="headerlink" title="10.异步操作"></a>10.异步操作</h2><h2 id="1-ajax"><a href="#1-ajax" class="headerlink" title="1.ajax"></a>1.ajax</h2><p>全称：异步的JS和XMLHttpRequest。XMLHttpRequest对象用于和服务器交互。</p>
<p>通过 XMLHttpRequest 可以在<strong>不刷新页面</strong>的情况下请求特定 URL，<strong>获取数据</strong>。这允许网页在不影响用户操作的情况下，更新页面的局部内容。<code>XMLHttpRequest</code> 在 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/AJAX">AJAX</a> 编程中被大量使用</p>
<p>并发：</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228115908939.png" alt="image-20230228115908939"></p>
<p>单核处理器实现并发：操作系统 分配不同的时间片。<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228120013722.png" alt="image-20230228120013722"></p>
<p>多核处理器的并行：<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228120043489.png" alt="image-20230228120043489"></p>
<p>同步和异步是两种不同的<strong>编程模型</strong>：</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228121340497.png" alt="image-20230228121340497"></p>
<p>才能进行下一个任务。</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228121437528.png" alt="image-20230228121437528"></p>
<p>你在执行任务a的时候也可以同时进行任务b</p>
<p>AJax的典型应用场景：</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228122122398.png" alt="image-20230228122122398"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228122143979.png" alt="image-20230228122143979"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228122158686.png" alt="image-20230228122158686"></p>
<h2 id="2-jquery中的ajax"><a href="#2-jquery中的ajax" class="headerlink" title="2.jquery中的ajax"></a>2.jquery中的ajax</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228123049839.png" alt="image-20230228123049839"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228130038095.png" alt="image-20230228130038095"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228130102414.png" alt="image-20230228130102414"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230228130705341.png" alt="image-20230228130705341"></p>
<h2 id="11-原型和原型链"><a href="#11-原型和原型链" class="headerlink" title="11.原型和原型链"></a>11.原型和原型链</h2><p>1.<code>super</code>的使用</p>
<p>在Javascript中，“<code>super</code>”是用于访问和调用父类对象上的方法的<strong>关键字</strong>。当一个子类继承自一个父类时，它可以使用super关键字来调用父类方法或构造函数。</p>
<p>在ES6中，当我们在子类中使用super时，它既可以用来调用父类的构造函数，也可以用来调用父类的方法。<code>如果你要使用它来调用父类构造函数，你必须在使用this之前调用它，否则会抛出错误。</code></p>
<p><strong>当在子类中使用super时，它会返回一个父类对象，并且可以访问父类的所有方法和属性，包括静态属性和方法。这使得我们可以在子类中重写父类方法或属性，并使用super来调用原来的实现。</strong></p>
<p>例如，下面是一个简单的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">sayHello</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I am in grade <span class="subst">$&#123;<span class="variable language_">this</span>.grade&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;John&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">student.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is John. I am in grade 10.</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，Person是父类，Student是子类。当Student类的实例调用它的sayHello()方法时，首先调用父类的sayHello()方法，然后在子类中打印一个额外的消息。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型:"></a>原型:</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230314120015433.png" alt="image-20230314120015433"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链:"></a>原型链:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230314120718165.png" alt="image-20230314120718165"></h2><p>因为实例和产生实例的类中都有一个属性,一个是__proto__一个是prototype,二者指向的都是这个类的prototype:存放着方法.</p>
<p>同时这个<strong>产生实例的类</strong>也有__proto__指向自己的父类,继承所带来的方法和属性就存放在prototype这个属性里面了.</p>
<h4 id="就是继承的关系"><a href="#就是继承的关系" class="headerlink" title="就是继承的关系"></a>就是继承的关系</h4><h2 id="12-迭代器和Map数据结构"><a href="#12-迭代器和Map数据结构" class="headerlink" title="12,迭代器和Map数据结构"></a>12,迭代器和Map数据结构</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230409133030266.png" alt="image-20230409133030266"></p>
<h2 id="迭代器工作原理"><a href="#迭代器工作原理" class="headerlink" title="迭代器工作原理"></a>迭代器工作原理</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230409133057874.png" alt="image-20230409133057874"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">			<span class="comment">//迭代器iterator是一种接口,为各种不同的数据结构提供统一的访问机制.</span></span><br><span class="line">			<span class="comment">//任何数据结构只要部署了这个迭代器接口,就可以使用for...of去遍历得到值</span></span><br><span class="line">			<span class="keyword">const</span> <span class="title class_">BanJi</span> = &#123;</span><br><span class="line">				<span class="attr">name</span>: <span class="string">&quot;终极一班&quot;</span>,</span><br><span class="line">				<span class="attr">students</span>: [<span class="string">&quot;XM&quot;</span>, <span class="string">&quot;XH&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;XD&quot;</span>],</span><br><span class="line">				[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">					<span class="comment">//索引变量,目的是遍历学生数组的值</span></span><br><span class="line">					<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">const</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">					<span class="keyword">return</span> &#123;</span><br><span class="line">						<span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">							<span class="keyword">if</span> (index &lt; _this.<span class="property">students</span>.<span class="property">length</span>) &#123;</span><br><span class="line">								<span class="comment">//此时说明遍历重复还没有结束</span></span><br><span class="line">								<span class="keyword">const</span> result = &#123; <span class="attr">value</span>: _this.<span class="property">students</span>[index], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">								index++;</span><br><span class="line">								<span class="keyword">return</span> result;</span><br><span class="line">							&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">								<span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;; <span class="comment">//this指向当前对象,所以在return里面this指向return这个对象,所以为了指向BanJi对象,使用</span></span><br><span class="line">					<span class="comment">// const _this = this;,在班级对象中</span></span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title class_">BanJi</span>) &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Map数据结构"><a href="#Map数据结构" class="headerlink" title="Map数据结构"></a>Map数据结构</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">			<span class="comment">// for in 遍历一个对象</span></span><br><span class="line">			<span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;string&quot;</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> obj) &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(item, obj[item]); </span><br><span class="line">                <span class="comment">//此处是获取对象内部属性值的另外一种方式</span></span><br><span class="line">                <span class="comment">//obj.a和obj[a]是等价的</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//map数据结构是升级版的对象</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">			<span class="comment">//添加元素</span></span><br><span class="line">			m.<span class="title function_">set</span>(<span class="string">&quot;李昊戈&quot;</span>, <span class="string">&quot;前面是键,后面是值&quot;</span>);</span><br><span class="line">			m.<span class="title function_">set</span>(<span class="string">&quot;change&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;它甚至里面可以放函数&quot;</span>);</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">let</span> key = &#123;</span><br><span class="line">				<span class="attr">name</span>: <span class="string">&quot;#bfa&quot;</span>,</span><br><span class="line">			&#125;;</span><br><span class="line">			m.<span class="title function_">set</span>(key, [<span class="string">&quot;数组1&quot;</span>, <span class="string">&quot;数组1&quot;</span>, <span class="string">&quot;数组1&quot;</span>]);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// m.delete(key); //传入键名就是删除</span></span><br><span class="line">			<span class="keyword">let</span> sum = m.<span class="property">size</span>; <span class="comment">//map里面的属性个数m.size</span></span><br><span class="line"></span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(m);</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(sum);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">let</span> fun = m.<span class="title function_">get</span>(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">			<span class="title function_">fun</span>();</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&quot;李昊戈&quot;</span>));</span><br><span class="line"></span><br><span class="line">			<span class="comment">//清空map对象</span></span><br><span class="line">			<span class="comment">// m.clear();</span></span><br><span class="line">			<span class="comment">// console.log(m);</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//遍历</span></span><br><span class="line">			<span class="comment">// for of 遍历一个 Map</span></span><br><span class="line">			<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">				[&#123; <span class="attr">name</span>: <span class="string">&quot;a&quot;</span> &#125;, <span class="string">&quot;string&quot;</span>],</span><br><span class="line">				[</span><br><span class="line">					<span class="string">&quot;b&quot;</span>,</span><br><span class="line">					<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">						<span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line">						<span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">					&#125;,</span><br><span class="line">				],</span><br><span class="line">				[<span class="string">&quot;c&quot;</span>, <span class="string">&quot;同意&quot;</span>],</span><br><span class="line">			]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 结果如下：</span></span><br><span class="line">			<span class="comment">// a string</span></span><br><span class="line">			<span class="comment">// b 1</span></span><br><span class="line">			<span class="comment">// c false</span></span><br><span class="line">		&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="13-JS事件流"><a href="#13-JS事件流" class="headerlink" title="13.JS事件流"></a>13.JS事件流</h2><p>1.事件捕获和事件冒泡(一个从上往下,一个从下往上)</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230420170145262.png" alt="image-20230420170145262"></p>
<p>当你点击了一个按钮的时候,事件发生的顺序如上</p>
<p>网页给用户做出的反应:<strong>就是事件处理程序</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230420165509391.png" alt="image-20230420165509391"></p>
<p>原生js里面的onclick默认采用事件冒泡,点击底层的快乐按钮</p>
<p>输出:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是span</span></span><br><span class="line"><span class="comment">// 我是button</span></span><br><span class="line"><span class="comment">// 我是body</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230420165727390.png" alt="image-20230420165727390"></p>
<p>当你使用addEventListener时,添加第三个参数为true,此时就会改变模式为事件捕获,从上到下</p>
<p>输出:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230420165828100.png" alt="image-20230420165828100"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230420170117118.png" alt="image-20230420170117118"></p>
<h2 id="14-js的事件循环"><a href="#14-js的事件循环" class="headerlink" title="14.js的事件循环"></a>14.js的事件循环</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230420171955447.png" alt="image-20230420171955447"></p>
<p>上述的script指<span style="color:tomato">的是引入script标签&lt;span</p>
<p>可以把微任务和宏任务想象成两个数组,交替执行</p>
<p>微任务比宏任务执行的要块</p>
<p>执行完微队列的一个任务,直接执行宏队列的一个任务,交替循环</p>
<h2 id="15-JS的防抖和节流"><a href="#15-JS的防抖和节流" class="headerlink" title="15.JS的防抖和节流"></a>15.JS的防抖和节流</h2><h2 id="15-js的防抖"><a href="#15-js的防抖" class="headerlink" title="15.js的防抖"></a>15.js的防抖</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426160935264.png" alt="image-20230426160935264"></p>
<p>单位时间内,频繁的触发事件,只执行最后一次</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426161246162.png" alt="image-20230426161246162"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426183505290.png" alt="image-20230426183505290"></p>
<h2 id="16-js的节流"><a href="#16-js的节流" class="headerlink" title="16.js的节流"></a>16.js的节流</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426191930253.png" alt="image-20230426191930253"></p>
<p>单位时间内,频繁触发事件,只执行一次</p>
<p>就像技能有冷却一样,只能放一次技能</p>
<p>就要等待冷却这个事件执行完毕</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426192207759.png" alt="image-20230426192207759"></p>
<p>使用方法: <strong>lodash库的throttle</strong>,或者<strong>手写</strong></p>
<h3 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426202059919.png" alt="image-20230426202059919"></p>
<h3 id="定时器的坑"><a href="#定时器的坑" class="headerlink" title="定时器的坑"></a>定时器的坑</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426201931248.png" alt="image-20230426201931248"></p>
<p>清除定时器以后,会直接赋值timer&#x3D;1.使用let timer&#x3D;null</p>
<h2 id="大概实现js图片的拖拽和图片防撞检测"><a href="#大概实现js图片的拖拽和图片防撞检测" class="headerlink" title="大概实现js图片的拖拽和图片防撞检测"></a>大概实现js图片的拖拽和图片防撞检测</h2><h2 id="前后端交互axios"><a href="#前后端交互axios" class="headerlink" title="前后端交互axios"></a>前后端交互axios</h2><h2 id="RestApi"><a href="#RestApi" class="headerlink" title="RestApi"></a>RestApi</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510160020514.png" alt="image-20230510160020514"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510160058360.png" alt="image-20230510160058360"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510160115368.png" alt="image-20230510160115368"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510160132447.png" alt="image-20230510160132447"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510160210671.png" alt="image-20230510160210671"></p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处?"></a>好处?</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510160509343.png" alt="image-20230510160509343"></p>
<p>相当于让你定义一套通用的接口服务,然后做到url见名知意,就是一套定义前后端接口的规范</p>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510191755268.png" alt="image-20230510191755268"></p>
<p>只写一个url,默认发送get请求</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510191906306.png" alt="image-20230510191906306"></p>
<p>则,最终结果:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510191921286.png" alt="image-20230510191921286"></p>
<p>baseURL:路径的前缀</p>
<p>请求体:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230510192105729.png" alt="image-20230510192105729"></p>
<p>只在post和put和delete等发送数据到服务器的方法中有效</p>
<p>axios会根据data(请求体)的数据类型自动设置</p>
<p>headers里的”Content-type”</p>
<p>form data,上传文件数据</p>
<h3 id="transformRequest"><a href="#transformRequest" class="headerlink" title="transformRequest"></a>transformRequest</h3><p> 可以用来处理请求数据（data）</p>
<p>它需要一个数组作为参数，数组可以接收多个函数，请求发送时多个函数会按照顺序执行</p>
<p>函数在执行时，会接收到两个参数data和headers</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">transformRequest</span>:[<span class="keyword">function</span>(<span class="params">data, headers</span>)&#123;</span><br><span class="line"><span class="comment">//可以在函数中对data和headers进行修改</span></span><br><span class="line"> data.<span class="property">name</span> = <span class="string">&quot;猪八戒&quot;</span></span><br><span class="line">headers[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    <span class="comment">//层层递进,这个返回的data就是下面那个传入函数参数的data</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">data, headers</span>)&#123;</span><br><span class="line">   最后一个函数必须返回一个字符串，才能使得数据有效</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line"> &#125;]</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230511131331179.png" alt="image-20230511131331179"></p>
<p>Content-Type必须写这个属性去修改请求头,Content-type:会让axios认为这是一个新的属性,不修改请求头</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>过期时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timeout 过期时间</span></span><br><span class="line"><span class="attr">timeout</span>: <span class="number">1000</span>,<span class="comment">//单位ms</span></span><br><span class="line">                    </span><br></pre></td></tr></table></figure>

<p>等待1s,如果请求的地址没有响应就取消</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230511132335304.png" alt="image-20230511132335304"></p>
<p>默认值:0,一直等待</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230511132416233.png" alt="image-20230511132416233"></p>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>&#x2F;&#x2F; 用来终止请求</p>
<h3 id="axios的默认全局配置"><a href="#axios的默认全局配置" class="headerlink" title="axios的默认全局配置"></a>axios的默认全局配置</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230511133332606.png" alt="image-20230511133332606"></p>
<p>默认配置作用于每个请求</p>
<h3 id="axios的实例"><a href="#axios的实例" class="headerlink" title="axios的实例"></a>axios的实例</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230511133939450.png" alt="image-20230511133939450"></p>
<p>相当于创建一个副本,单独修改实例的默认配置<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230511134246959.png" alt="image-20230511134246959"></p>
<p>或者像修改全局配置一样</p>
<h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><p>在请求或响应被 then 或 catch 处理前拦截它们</p>
<p>在请求到达服务器之前,做统一操作</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230511180106201.png" alt="image-20230511180106201"></p>
<ol>
<li>Interceptors拦截器</li>
<li>request请求</li>
<li>use代表配置</li>
<li>上述代码是请求拦截器的配置</li>
<li>config就是axios的配置对象</li>
</ol>
<p><strong>一般也就是修改请求头</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230511182324286.png" alt="image-20230511182324286"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">			axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">				<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">					<span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">					<span class="comment">// 对响应数据做点什么</span></span><br><span class="line">					<span class="keyword">return</span> response;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">					<span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">					<span class="comment">// 对响应错误做点什么</span></span><br><span class="line">					<span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">				&#125;</span><br><span class="line">			);</span><br></pre></td></tr></table></figure>

<h2 id="离散大作业"><a href="#离散大作业" class="headerlink" title="离散大作业"></a>离散大作业</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230511192320674.png" alt="image-20230511192320674"></p>
<p>某社交网络中共有n个人，即a1,a1,a2,…,an.当给定n，以及部分人际关系。为扩展人际关系，可利用已有的人际关系来认识一些不识之人，若只通过一人的牵线，试问哪些人员之间可间接建立起人际关系。<br>算法:<br>   输入描述:n, (a1, a2),(a1, a3), …, (ai, aj)</p>
<p>例如，5,(1, 2),(1,3),(1,4),(2,5),(3,4)</p>
<p>输出描述: (ai,aj)…(ak, al)</p>
<p>要求:各括号对的输出要求保证按字典序或自然数递增排序。</p>
<p>例如，(1,5)(2,3)(2,4)</p>
<h2 id="set和map数据结构"><a href="#set和map数据结构" class="headerlink" title="set和map数据结构"></a>set和map数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set:"></a>Set:</h3><h4 id="它类似于数组，但是成员的值都是唯一的，没有重复的值。"><a href="#它类似于数组，但是成员的值都是唯一的，没有重复的值。" class="headerlink" title="它类似于数组，但是成员的值都是唯一的，没有重复的值。"></a><strong>它类似于数组，但是成员的值都是唯一的，没有重复的值。</strong></h4><p>在 JavaScript 中，<code>[...]</code> 表示展开运算符（spread operator），它可以将可迭代对象（例如数组或 Set）转换为数组。这个运算符可以将可迭代对象中的元素解构（或展开）成一个数组。</p>
<ol>
<li><code>// 去除数组的重复成员</code></li>
<li><code>[...new Set(array)]</code></li>
</ol>
<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>
<ol>
<li><p><code>const s = new Set();</code></p>
</li>
<li><h3 id="去除字符串里的重复字符"><a href="#去除字符串里的重复字符" class="headerlink" title="去除字符串里的重复字符"></a>去除字符串里的重复字符</h3></li>
<li><p><code>[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)</code></p>
</li>
<li><p><code>// &quot;abc&quot;</code></p>
</li>
</ol>
<p>去除数组重复成员的另一种方法</p>
<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dedupe</span>(<span class="params">array</span>)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">dedupe</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h4 id="因此使用-Set-可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。"><a href="#因此使用-Set-可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。" class="headerlink" title="因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。"></a><strong>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</strong></h4><ol>
<li><code>let a = new Set([1, 2, 3]);</code></li>
<li><code>let b = new Set([4, 3, 2]);</code></li>
<li>&#96;&#96;</li>
<li><code>// 并集</code></li>
<li><code>let union = new Set([...a, ...b]);</code></li>
<li><code>// Set &#123;1, 2, 3, 4&#125;</code></li>
<li>&#96;&#96;</li>
<li><code>// 交集</code></li>
<li><code>let intersect = new Set([...a].filter(x =&gt; b.has(x)));</code></li>
<li><code>// set &#123;2, 3&#125;</code></li>
<li>&#96;&#96;</li>
<li><code>// （a 相对于 b 的）差集</code></li>
<li><code>let difference = new Set([...a].filter(x =&gt; !b.has(x)));</code></li>
<li><code>// Set &#123;1&#125;</code></li>
</ol>
<h2 id="扩展运算符…"><a href="#扩展运算符…" class="headerlink" title="扩展运算符…"></a>扩展运算符…</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">扩展运算符是<span class="title class_">ES6</span>新引入的一种语法，它使用三个点 <span class="string">`...`</span> 表示，常用于将一个可迭代对象（比如数组、字符串、<span class="title class_">Set</span>、<span class="title class_">Map</span>等）拆分成单独的元素。在这个例子中，使用扩展运算符 <span class="string">`...`</span> 将两个数组合并成一个新数组。具体解释如下：</span><br><span class="line"></span><br><span class="line">-   <span class="string">`let arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];`</span>：定义一个包含三个元素的数组 <span class="string">`arr1`</span>，元素分别为 “a”、“b”、“c”。</span><br><span class="line">-   <span class="string">`let arr2 = [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;];`</span>：定义另一个包含五个元素的数组 <span class="string">`arr2`</span>，元素分别为 “d”、“e”、“f”、“g” 和 “h”。</span><br><span class="line">-   <span class="string">`const merge=[...arr1, ...arr2];`</span>：使用扩展运算符 <span class="string">`...`</span> 将 <span class="string">`arr1`</span> 和 <span class="string">`arr2`</span> 合并成一个新数组 <span class="string">`merge`</span>。</span><br><span class="line"></span><br><span class="line">通过使用扩展运算符，我们可以很方便地将两个数组合并为一个，而不需要使用<span class="string">`concat`</span>等数组方法。类似地，我们还可以使用扩展运算符对字符串、<span class="title class_">Set</span>、<span class="title class_">Map</span>等可迭代对象进行拆分和合并操作。例如：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">let str = &quot;hello&quot;;</span></span><br><span class="line"><span class="string">let charArray = [...str]; //将字符串 &quot;hello&quot; 转换为包含字符的数组 [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">## 例子</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  合并数组</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">const arr1 = [1, 2, 3];</span></span><br><span class="line"><span class="string">const arr2 = [4, 5, 6];</span></span><br><span class="line"><span class="string">const mergedArr = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  复制数组</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">const arr1 = [1, 2, 3];</span></span><br><span class="line"><span class="string">const copiedArr = [...arr1]; // [1, 2, 3]</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  将一个数组插入到另一个数组中</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">let arr1 = [1, 2, 3];</span></span><br><span class="line"><span class="string">let arr2 = [4, 5, 6];</span></span><br><span class="line"><span class="string">arr1.splice(1, 0, ...arr2); // 在下标为1的位置插入arr2中的元素</span></span><br><span class="line"><span class="string">// arr1变为[1, 4, 5, 6, 2, 3]</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  将一个类数组对象转换为数组</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">function sum(...args) &#123;</span></span><br><span class="line"><span class="string">  const numbers = [...args];</span></span><br><span class="line"><span class="string">  return numbers.reduce((total, val) =&gt; total + val, 0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sum(1, 2, 3, 4); // 10</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  合并对象</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">const obj1 = &#123; a: 1, b: 2 &#125;;</span></span><br><span class="line"><span class="string">const obj2 = &#123; c: 3, d: 4 &#125;;</span></span><br><span class="line"><span class="string">const mergedObj = &#123; ...obj1, ...obj2 &#125;; // &#123; a: 1, b: 2, c: 3, d: 4 &#125;</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  克隆对象</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">const obj = &#123; a: 1, b: 2 &#125;;</span></span><br><span class="line"><span class="string">const clonedObj = &#123; ...obj &#125;; // &#123; a: 1, b: 2 &#125;</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line">以上是一些常见的扩展运算符用法，扩展运算符可以大大简化我们的代码，提高代码的可读性和可维护性。</span><br></pre></td></tr></table></figure>

<h2 id="数组去重加上…扩展运算符"><a href="#数组去重加上…扩展运算符" class="headerlink" title="数组去重加上…扩展运算符"></a>数组去重加上…扩展运算符</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230525011157922.png" alt="image-20230525011157922"></p>
<p>一行代码去重展示</p>
<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230528194535713.png" alt="image-20230528194535713"></p>
<p>前面的名字只是匹配模式</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230528194627542.png" alt="image-20230528194627542"></p>
<p>后面的才是变量.</p>
<h3 id="总体文档"><a href="#总体文档" class="headerlink" title="总体文档:"></a>总体文档:</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230528203608120.png" alt="image-20230528203608120"></p>
<h2 id="JS的深浅Copy"><a href="#JS的深浅Copy" class="headerlink" title="JS的深浅Copy"></a>JS的深浅Copy</h2><p>直接复制对象的一些问题</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708184344454.png" alt="image-20230708184344454"></p>
<p>修改o的属性age,但是obj的属性也被修改了.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708184515523.png" alt="image-20230708184515523"></p>
<p>直接复制对象,复制的是对象的地址,内存内存的还是同一份数据.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230708184630468.png" alt="image-20230708184630468"></p>
<p>为了解决复制对象只是复制指向对象内存的指针的这个问题:</p>
<p>创建出来两个拷贝,浅拷贝和深拷贝.</p>
<p>ChatGPT:</p>
<p>shallow Copy:<br>浅拷贝创建一个新对象，该对象与原始对象共享相同的引用。它只复制对象的顶层结构，嵌套的对象仍然是从原始对象引用的。</p>
<p>以下是使用<code>Object.assign</code>或展开语法(<code>...</code>)进行浅拷贝的示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> originalObject = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">nestedObject</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">    <span class="attr">country</span>: <span class="string">&#x27;USA&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.assign进行浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> shallowCopy1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, originalObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用展开语法进行浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> shallowCopy2 = &#123; ...originalObject &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改浅拷贝中的嵌套对象会影响原始对象</span></span><br><span class="line">shallowCopy1.<span class="property">nestedObject</span>.<span class="property">city</span> = <span class="string">&#x27;San Francisco&#x27;</span>;</span><br><span class="line">shallowCopy2.<span class="property">nestedObject</span>.<span class="property">country</span> = <span class="string">&#x27;Canada&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalObject);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(shallowCopy1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(shallowCopy2);</span><br></pre></td></tr></table></figure>



<p>输出:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">nestedObject</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;San Francisco&#x27;</span>,</span><br><span class="line">    <span class="attr">country</span>: <span class="string">&#x27;Canada&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">nestedObject</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;San Francisco&#x27;</span>,</span><br><span class="line">    <span class="attr">country</span>: <span class="string">&#x27;Canada&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">nestedObject</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;San Francisco&#x27;</span>,</span><br><span class="line">    <span class="attr">country</span>: <span class="string">&#x27;Canada&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，修改浅拷贝中的嵌套对象的属性会影响原始对象。这表明浅拷贝只克隆顶层属性，而嵌套对象仍然是共享的。</p>
<p>也就是遇到<code>对象:object</code>这种<strong>引用类型</strong>,依然是复制对应的指针.而不是克隆对应的对象.</p>
<p>deep copy:<br>deep copy创建一个完全独立的对象副本，包括所有嵌套的对象。在修改复制后的对象的属性时，不会影响原始对象或任何嵌套对象。</p>
<p>以下是使用<code>JSON.parse</code>和<code>JSON.stringify</code>进行深拷贝的示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> originalObject = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">nestedObject</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">    <span class="attr">country</span>: <span class="string">&#x27;USA&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用JSON.parse和JSON.stringify进行深拷贝</span></span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(originalObject));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改深拷贝中的嵌套对象不会影响原始对象</span></span><br><span class="line">deepCopy.<span class="property">nestedObject</span>.<span class="property">city</span> = <span class="string">&#x27;San Francisco&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalObject);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deepCopy);</span><br></pre></td></tr></table></figure>



<p>输出:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">nestedObject</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">    <span class="attr">country</span>: <span class="string">&#x27;USA&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">nestedObject</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;San Francisco&#x27;</span>,</span><br><span class="line">    <span class="attr">country</span>: <span class="string">&#x27;USA&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这个例子中，修改深拷贝中的嵌套对象不会影响原始对象。这说明深拷贝创建了对象及其所有嵌套对象的新副本。</p>
<p>需要注意的是，<code>JSON.stringify</code>和<code>JSON.parse</code>有一些限制，例如不能复制函数或循环引用。在这种情况下，你可能需要使用专门的库，如<code>lodash</code>或自定义的深拷贝实现，以实现完整的深拷贝。</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="业务开发常用"><a href="#业务开发常用" class="headerlink" title="业务开发常用"></a>业务开发常用</h2><h3 id="1-实现弹窗"><a href="#1-实现弹窗" class="headerlink" title="1.实现弹窗"></a>1.实现弹窗</h3><p>实现弹窗遮罩就用这个!!!!</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230526232542457.png" alt="image-20230526232542457"></p>
<p>搭配这个实现弹窗</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230526232700551.png" alt="image-20230526232700551"></p>
<h3 id="离散大作业-1"><a href="#离散大作业-1" class="headerlink" title="离散大作业"></a>离散大作业</h3><p>根据给出的测试用例，原来的代码存在以下问题，需要进行修改：</p>
<ol>
<li>输入格式不正确。输入的第一行为节点数，之后的每一行为两个数字，表示两个节点之间有一条边。您需要修改代码，将输入格式与测试用例保持一致。</li>
<li>输出格式不正确。输出的 i 和 j 应该对应题目中给定的节点编号，需要根据下标进行转换。</li>
</ol>
<p>修改后的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">mul</span>(vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; data)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">newMul</span>(data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[i][k] &amp;&amp; data[k][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    newMul[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newMul;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">data</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> m, x, y;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        data[x - <span class="number">1</span>][y - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        data[y - <span class="number">1</span>][x - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; data[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; data[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; good = <span class="built_in">mul</span>(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (good[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的修改主要针对输入和输出格式进行了调整，以适配给出的测试用例。希望对您有所帮助。</p>
<h2 id="css实现元素居中的几种方式"><a href="#css实现元素居中的几种方式" class="headerlink" title="css实现元素居中的几种方式"></a>css实现元素居中的几种方式</h2><p>以下是一些CSS实现元素居中的方法及其示例：</p>
<ol>
<li>text-align 属性：将元素内部的文本居中</li>
</ol>
<p>示例代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>display: flex 和 justify-content 属性：使用 flex 布局实现居中</li>
</ol>
<p>示例代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>position 属性：使用 position 属性将元素绝对定位到容器的中心</li>
</ol>
<p>示例代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>margin 属性：使用 margin 属性将元素居中</li>
</ol>
<p>示例代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>grid 布局：使用 grid 布局实现居中</li>
</ol>
<p>示例代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"> <span class="attribute">display</span>: grid;</span><br><span class="line"> place-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提供了不同的方法，您可以根据需要选择最适合您设计的方法。</p>
<ol start="6">
<li>table 属性：使用 table 属性将元素居中</li>
</ol>
<p>示例代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>line-height 属性：将元素的 line-height 属性设置为容器高度的值，使元素垂直居中</li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  height: 400px;</span><br><span class="line">  line-height: 400px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>padding 属性：使用 padding 属性将元素居中</li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 500px;</span><br><span class="line">  padding-left: 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container div &#123;</span><br><span class="line">  margin-left: -100px; /* 宽度的一半 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>使用display: inline-block和vertical-align属性结合使元素水平垂直居中</li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  font-size: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container div &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230411202933846.png" alt="image-20230411202933846"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230411202944632.png" alt="image-20230411202944632"></p>
<p>当子元素大小超出父元素的内容区时,子元素会从父元素溢出:overflow</p>
<p>overflow样式必须设置在父元素中,在哪溢出,在哪设置</p>
<p><code>overflow:auto</code>自动根据溢出的方向,生成对应的滚动条</p>
<p><strong>用的最多的还是overflow:hidden</strong></p>
<h2 id="行内元素的盒模型"><a href="#行内元素的盒模型" class="headerlink" title="行内元素的盒模型"></a>行内元素的盒模型</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230411202301017.png" alt="image-20230411202301017"></p>
<p>不影响布局的意思是,<strong>不会挤开其他元素,而是覆盖其他元素</strong>.</p>
<p>别想其他人学习了,自己学先!</p>
<h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230411204117702.png" alt="image-20230411204117702"></p>
<p>块元素:block:独占一行,可以设置内容区域的宽高,</p>
<p>行内元素,一行以内,不独占一行,不可以设置宽高,而是内容去撑开大小.</p>
<p>代码效果:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230411204135890.png" alt="image-20230411204135890"></p>
<p>行内块布局时不是很好用,尽量少用,比如上面的<span>和<span>之间的换行浏览器就会解析为空格,表现在显示上就是</p>
<p>块与块之间会有白色空隙.</p>
<p>平时尽量多了解自己不会的,然后找相关视频去看,去学习!</p>
<h2 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h2><p>该属性设置元素的可见性</p>
<p><code>display:none</code>元素彻底消失不见.</p>
<p><code>visibility:hidden</code>元素是隐藏在页面中不可见,但是仍然占据页面位置,<em>披了一层隐形衣</em></p>
<p>今日作业:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230411212516437.png" alt="image-20230411212516437"><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230411212524641.png" alt="image-20230411212524641"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230411213314333.png" alt="image-20230411213314333"></p>
<p>文字垂直居中,和超链接去除下划线,<del></del>这个是让文字划线删除</p>
<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230414193326125.png" alt="image-20230414193326125"></p>
<p>其实就是默认情况下,元素的排列规则和满足的布局方式,默认情况下的网页表面就是文档流</p>
<p>块元素:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230415144118377.png" alt="image-20230415144118377"></p>
<h2 id="margin-0-auto原理"><a href="#margin-0-auto原理" class="headerlink" title="margin 0 auto原理"></a>margin 0 auto原理</h2><p>子元素在父元素的内容区内排列</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230414181811836.png" alt="image-20230414181811836"></p>
<p>子元素的可见框包括<strong>内容区content-box,padding,border,<strong>还有水平外边距,就是</strong>margin-left和margin-right.</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230414185723226.png" alt="image-20230414185723226"></p>
<p>也就解释了为什么有时候设置margin-right没有用了.</p>
<p>自己写的:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230414211219598.png" alt="image-20230414211219598"></p>
<h2 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动:float"></a>浮动:float</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230414213252289.png" alt="image-20230414213252289"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230414212539633.png" alt="image-20230414212539633"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230414212552932.png" alt="image-20230414212552932"></p>
<p>在html中,box3在box2的上面,box3是大哥,浮动的时候就往上走</p>
<p>然后如果是</p>
<div>box2
<div>box3


<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230414212812088.png" alt="image-20230414212812088"></p>
<p>则出现这种一边齐的情况.</p>
<h2 id="稀土掘金实现超强文字动效"><a href="#稀土掘金实现超强文字动效" class="headerlink" title="稀土掘金实现超强文字动效"></a>稀土掘金实现超强文字动效</h2><p>repeating-radial-gradient是CSS属性之一，用于创建一个以圆心为中心，呈放射状分布的渐变图案。该属性可以在一个元素的背景中使用，并指定颜色和半径的值来创建一个重复的、环形的渐变。</p>
<p>该属性的语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">repeating-radial-gradient</span>(center, shape size, color-stop1, color-stop2, ..., color-stopN);</span><br></pre></td></tr></table></figure>

<p>其中，<code>center</code>是圆心的位置，可以使用关键字或者坐标值来指定；<code>shape size</code>是渐变形状和大小，可以使用关键字或者长度值来指定；<code>color-stop</code>是颜色停靠点，用于指定不同颜色的分界点，可以使用颜色值或者百分比值来指定。</p>
<p>例如，以下代码将创建一个以圆心为中心的渐变图案，从红色逐渐过渡到蓝色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">repeating-radial-gradient</span>(circle at center, red, blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该属性可以用于创建各种不同的渐变效果，具有很高的灵活性和可定制性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> --offset &#123;</span><br><span class="line">  syntax: <span class="string">&#x27;&lt;length&gt;&#x27;</span>;//语法:长度</span><br><span class="line">  inherits: false;</span><br><span class="line">  initial-value: <span class="number">5px</span>;//初始值</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">repeating-radial-gradient</span>(circle at <span class="number">0</span> <span class="number">0</span> , <span class="number">#000</span> <span class="built_in">calc</span>(<span class="built_in">var</span>(--offset) - <span class="number">5px</span>), <span class="number">#000</span> <span class="built_in">var</span>(--offset), <span class="number">#fff</span> <span class="built_in">var</span>(--offset), <span class="number">#fff</span> <span class="built_in">calc</span>(<span class="built_in">var</span>(--offset) + <span class="number">5px</span>));</span><br><span class="line">    <span class="attribute">animation</span>: move .<span class="number">5s</span> infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attr">--offset</span>: <span class="number">15px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;这段代码的意思</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个 CSS 自定义属性 <code>--offset</code>，其初始值为 <code>5px</code>，不继承任何父元素的属性。</p>
<p>接下来，通过在 <code>p</code> 元素上设置 <code>background</code> 属性，使用 <code>repeating-radial-gradient</code> 函数创建一个圆形的渐变背景。在渐变中使用了四种颜色：黑色、白色以及两个计算出来的颜色。这四个颜色通过 <code>calc</code> 函数的方式动态计算，其中 <code>var(--offset)</code> 代表自定义属性的值。这样就可以在 <code>--offset</code> 值改变时改变渐变的颜色。</p>
<p>此外，该 <code>p</code> 元素还使用了 CSS 动画 <code>move</code>，将 <code>--offset</code> 的值从初始值 <code>5px</code> 缓慢地增加到 <code>15px</code>，使渐变颜色不断向下移动。这样就创建了一个具有动态效果的渐变背景。</p>
<h2 id="浮动的特点2"><a href="#浮动的特点2" class="headerlink" title="浮动的特点2"></a>浮动的特点2</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230415143526015.png" alt="image-20230415143526015"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230415143535394.png" alt="image-20230415143535394"></p>
<h2 id="学习弹性盒子"><a href="#学习弹性盒子" class="headerlink" title="学习弹性盒子"></a>学习弹性盒子</h2><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>单独设置弹性盒子的子元素在侧轴的对齐方式,诀窍是先设置align-items,然后再单独设置align-self</p>
<p>还要看主轴的设置方向,因为主轴是列设置,从上到下,则侧轴:蓝色激光条,设置时就是从左到右</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230417175353161.png" alt="image-20230417175353161"></p>
<p>比如此处主轴设置末尾</p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>每当有剩余的可用空间,为元素设置flex-grow:1;都会使元素按照1这个比率去自动填充剩余空间,弹性生长属性</p>
<h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2><h3 id="要使用display-grid"><a href="#要使用display-grid" class="headerlink" title="要使用display:grid,"></a>要使用display:grid,</h3><h3 id="首先打开开发者工具-然后去打开显示网格线"><a href="#首先打开开发者工具-然后去打开显示网格线" class="headerlink" title="首先打开开发者工具,然后去打开显示网格线"></a>首先打开开发者工具,然后去打开显示网格线</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">**<span class="attribute">display</span>: grid;**</span><br><span class="line"></span><br><span class="line">`<span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">1</span>fr <span class="number">2</span>fr);`</span><br><span class="line"></span><br><span class="line">​	  决定网格的模板列</span><br><span class="line"></span><br><span class="line">​     - 等分为<span class="number">4</span>等份,“fr”是用于表示网格项大小的相对单位,相对来说都一样,就是等分</span><br><span class="line"></span><br><span class="line">​     - 可以等价替换为<span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line"></span><br><span class="line">​     - :重复四次每次都是<span class="number">1</span>fr</span><br><span class="line"></span><br><span class="line">​     - grid-template-columns: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">1</span>fr <span class="number">2</span>fr);</span><br><span class="line"></span><br><span class="line">​     - :重复两次,每次是:<span class="number">1</span>fr <span class="number">2</span>fr,生成<span class="number">4</span>列</span><br></pre></td></tr></table></figure>



<h3 id="上述是基本的设置"><a href="#上述是基本的设置" class="headerlink" title="上述是基本的设置"></a>上述是基本的设置</h3><pre><code>     <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">   网格容器<span class="attribute">display</span>:grid</span><br><span class="line"></span><br><span class="line">   - 要使用网格布局必须先设置网格容器</span><br><span class="line">     :grid:块级网格布局 或 display:inline-grid</span><br><span class="line">        - 默认情况下，我们开启的是一个单列的网格布局 </span><br><span class="line"></span><br><span class="line">​                grid-template-columns</span><br><span class="line"></span><br><span class="line">   - 用来设置网格布局的列数</span><br><span class="line">     			 grid-template-rows</span><br><span class="line">        - 用来设置网格布局的行数</span><br><span class="line"></span><br><span class="line">​            网格项</span><br><span class="line"></span><br><span class="line">   - 网格容器的子元素都会自动变为网格项</span><br><span class="line"></span><br><span class="line">​      网格项</span><br><span class="line"></span><br><span class="line">​        **grid-column-start 网格列的起始位置**</span><br><span class="line"></span><br><span class="line">​        **grid-column-end  网格列的结束位置**</span><br><span class="line"></span><br><span class="line">​        **grid-row-start  网格行的起始位置**</span><br><span class="line"></span><br><span class="line">​        **grid-row-end  网格行的结束位置**</span><br><span class="line"></span><br><span class="line">​      网格布局非常适合做响应式布局,因为元素设置后,其余元素就像水一样,直接顺次排列</span><br><span class="line"></span><br><span class="line">​	`原因是grid-auto-flow默认值是row,决定方式是自动添加行`</span><br><span class="line"></span><br><span class="line">​    上述属性针对的数字都是网格线的数字,打开开发者工具,选择outer即可看到网格线</span><br></pre></td></tr></table></figure>
</code></pre>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230418152846502.png" alt="image-20230418152846502"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line"></span><br><span class="line">​      可以通过<span class="attribute">z-index</span>来调整网格项的层级</span><br><span class="line"></span><br><span class="line">​        <span class="attribute">grid-column</span> 同时设置列开始和结束</span><br><span class="line"></span><br><span class="line">​          <span class="attribute">grid-column</span>:column-start/column-end</span><br><span class="line"></span><br><span class="line">​        grid-row 同时设置行开始和结束</span><br><span class="line"></span><br><span class="line">​          grid-row:row-start/row-end</span><br><span class="line"></span><br><span class="line">​        grid-area 同时设置行列的开始和结束</span><br><span class="line"></span><br><span class="line">​          grid-area: 行start/列start/行end/列end</span><br><span class="line"></span><br><span class="line">​        grid-column-gap 列间距</span><br><span class="line"></span><br><span class="line">​        grid-row-gap 行间距</span><br><span class="line"></span><br><span class="line">​        grid-gap 同时指定行间距和列间距</span><br><span class="line"></span><br><span class="line">​          grid-gap 行间距 列间距</span><br><span class="line"></span><br><span class="line">​    --&gt;</span><br></pre></td></tr></table></figure>



<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426105626908.png" alt="image-20230426105626908"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426105206922.png" alt="image-20230426105206922"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426105218347.png" alt="image-20230426105218347"></p>
<p>上述的screen和print表示带有屏幕的设备和打印机设备</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230426105611748.png" alt="image-20230426105611748"></p>
<h2 id="响应式界面"><a href="#响应式界面" class="headerlink" title="响应式界面"></a>响应式界面</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230428211438763.png" alt="image-20230428211438763"></p>
<h3 id="先写移动端-再写网页端"><a href="#先写移动端-再写网页端" class="headerlink" title="先写移动端,再写网页端"></a>先写移动端,再写网页端</h3><h3 id="Mobile-first"><a href="#Mobile-first" class="headerlink" title="Mobile first"></a>Mobile first</h3><p>flex-grow属性,自动撑满整个空间</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230428212502127.png" alt="image-20230428212502127"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230428212511558.png" alt="image-20230428212511558"></p>
<p>父元素和子元素的高度相同时,可以达到居中效果,可以给父元素一个背景颜色看下父元素在哪</p>
<p>调整两个div之间的距离,请使用margin-right</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230428212739540.png" alt="image-20230428212739540"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230428212801490.png" alt="image-20230428212801490"></p>
<p>:active指的是</p>
<h2 id="chatGpt媒体查询"><a href="#chatGpt媒体查询" class="headerlink" title="chatGpt媒体查询"></a>chatGpt媒体查询</h2><p>当我们在编写响应式的网页时，往往需要针对不同的设备尺寸设置不同的样式。而媒体查询（Media Query）就是一种常用的CSS技术，它可以根据设备尺寸、屏幕分辨率等参数来应用不同的样式。下面给出一些常用的媒体查询及其用法：</p>
<ol>
<li>最大宽度媒体查询</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media screen and (max-width: 768px) &#123;</span><br><span class="line">  /* 当屏幕宽度小于768px时应用以下样式 */</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此媒体查询将应用于最大宽度不超过768像素的屏幕，通常用于在移动设备上应用不同的样式。</p>
<ol>
<li>最小宽度媒体查询</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media screen and (min-width: 768px) &#123;</span><br><span class="line">  /* 当屏幕宽度大于等于768px时应用以下样式 */</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此媒体查询将应用于最小宽度不少于768像素的屏幕，通常用于在大屏设备上应用不同的样式。</p>
<ol>
<li>屏幕方向媒体查询</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media screen and (orientation: landscape) &#123;</span><br><span class="line">  /* 当屏幕为横屏时应用以下样式 */</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (orientation: portrait) &#123;</span><br><span class="line">  /* 当屏幕为竖屏时应用以下样式 */</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此媒体查询将根据设备屏幕的方向应用不同的样式，通常用于在横屏和竖屏模式下设置不同的样式。</p>
<ol>
<li>屏幕分辨率媒体查询</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media screen and (min-resolution: 300dpi) &#123;</span><br><span class="line">  /* 当屏幕分辨率大于等于300dpi时应用以下样式 */</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-resolution: 72dpi) &#123;</span><br><span class="line">  /* 当屏幕分辨率小于等于72dpi时应用以下样式 */</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此媒体查询将根据设备屏幕分辨率应用不同的样式，通常用于针对高清屏幕设备应用不同的样式。</p>
<h2 id="10个让你大吃一惊的css设置"><a href="#10个让你大吃一惊的css设置" class="headerlink" title="10个让你大吃一惊的css设置"></a>10个让你大吃一惊的css设置</h2><h3 id="1-当在网页中跳转到图片的指定位置"><a href="#1-当在网页中跳转到图片的指定位置" class="headerlink" title="1.当在网页中跳转到图片的指定位置"></a>1.当在网页中跳转到图片的指定位置</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230514234301776.png" alt="image-20230514234301776"></p>
<p>直接a href&#x3D;”#page2”,并且page2有个id</p>
<p>那么:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230514235455511.png" alt="image-20230514235455511"></p>
<p>加入这一行css属性,网页滑动就是流畅的动画了</p>
<h3 id="2-Writing-Mode"><a href="#2-Writing-Mode" class="headerlink" title="2.Writing Mode"></a>2.Writing Mode</h3><p>改变文字的方向</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230514235249206.png" alt="image-20230514235249206"><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230514235255696.png" alt="image-20230514235255696"></p>
<p>从横向改为竖向</p>
<h3 id="3-Gap"><a href="#3-Gap" class="headerlink" title="3.Gap"></a>3.Gap</h3><p>flex和grid布局中,flex的项目的间隔</p>
<h3 id="4-scroll-snap-type"><a href="#4-scroll-snap-type" class="headerlink" title="4.scroll-snap-type"></a>4.scroll-snap-type</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230514235955878.png" alt="image-20230514235955878"></p>
<p>子元素设置scroll-snap-align:center</p>
<p>达到选择子元素时自动捕捉到中间的效果,更自然的滑动体验</p>
<h2 id="使用CSS-transform属性设计页面旋转切换效果"><a href="#使用CSS-transform属性设计页面旋转切换效果" class="headerlink" title="使用CSS transform属性设计页面旋转切换效果"></a>使用CSS transform属性设计页面旋转切换效果</h2><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230523125542878.png" alt="image-20230523125542878"></p>
<p>大概是这样的</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230523125712160.png" alt="image-20230523125712160"></p>
<p>section是背后深色的页面,然后两个page都是绝对定位,所以是重叠的</p>
<p>translateY(100vh)就会让元素向下平移100vh,然后移出去页面</p>
<p>在点击按钮后,再次设置相关样式</p>
<h2 id="练习Canvas"><a href="#练习Canvas" class="headerlink" title="练习Canvas"></a>练习Canvas</h2><h3 id="创建canvas-画布"><a href="#创建canvas-画布" class="headerlink" title="创建canvas:画布"></a>创建canvas:画布</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230524163422330.png" alt="image-20230524163422330"></p>
<h3 id="不要使用css控制宽高"><a href="#不要使用css控制宽高" class="headerlink" title="不要使用css控制宽高"></a>不要使用css控制宽高</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230524165017219.png" alt="image-20230524165017219"></p>
<h3 id="画直线"><a href="#画直线" class="headerlink" title="画直线"></a>画直线</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230524165939193.png" alt="image-20230524165939193"></p>
<h3 id="给直线一点颜色"><a href="#给直线一点颜色" class="headerlink" title="给直线一点颜色"></a>给直线一点颜色</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230524170552377.png" alt="image-20230524170552377"></p>
<h3 id="渐变颜色"><a href="#渐变颜色" class="headerlink" title="渐变颜色"></a>渐变颜色</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230524171021193.png" alt="image-20230524171021193"></p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="5-simple-tips-to-making-responsive-layouts-the-easy-way"><a href="#5-simple-tips-to-making-responsive-layouts-the-easy-way" class="headerlink" title="5 simple tips to making responsive layouts the easy way"></a>5 simple tips to making responsive layouts the easy way</h2><p>响应式的布局</p>
<h3 id="1-从全局样式开始"><a href="#1-从全局样式开始" class="headerlink" title="1.从全局样式开始"></a>1.从全局样式开始</h3><h3 id="2-不要使用固定的尺寸"><a href="#2-不要使用固定的尺寸" class="headerlink" title="2.不要使用固定的尺寸"></a>2.不要使用固定的尺寸</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230531160213987.png" alt="image-20230531160213987"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230531160341996.png" alt="image-20230531160341996">  </p>
<p>当你把你的width设置成600px的时候,在移动端就会导致溢出,这种<code>width:600px</code>就是固定的尺寸</p>
<p>会导致溢出,请使用<strong>max-width</strong>,如果使用max-width,在小于max-width这个尺寸的时候,就会shrink,收缩.</p>
<p>从而不溢出</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230531160730186.png" alt="image-20230531160730186"></p>
<p>同样的,使用可以响应性质的东西:<strong>min-height</strong>,这样在浏览器窗口缩小的时候,也会自然增长:grow,而且不要设置单一的高度和宽度:height和width</p>
<h3 id="3-尽量使用媒体查询增加网页复杂度"><a href="#3-尽量使用媒体查询增加网页复杂度" class="headerlink" title="3.尽量使用媒体查询增加网页复杂度"></a>3.尽量使用媒体查询增加网页复杂度</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230531161155841.png" alt="image-20230531161155841"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230531161314445.png" alt="image-20230531161314445"></p>
<p>在专栏项中,小于40em的时候应用这个display:block</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230531161448015.png" alt="image-20230531161448015"></p>
<p>当宽度大于40em的时候生效.</p>
<p>一般在媒体查询的时候写<code>40em</code>就差不多了.</p>
<p>移动端优先原则</p>
<p>基本上宽度和高度就差不多行了,不要多多使用什么特定设备查询</p>
<h3 id="4-使用一些现代的css方法"><a href="#4-使用一些现代的css方法" class="headerlink" title="4.使用一些现代的css方法"></a>4.使用一些现代的css方法</h3><p><code>font-size:</code><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230531162414659.png" alt="image-20230531162414659"></p>
<p>clamp这个函数</p>
<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="vue学习路线"><a href="#vue学习路线" class="headerlink" title="vue学习路线"></a>vue学习路线</h2><p>1学习方法：</p>
<p>项目多并非一蹴而就，靠的是不断积累。建议边学习边做项目，在做项目的过程中不断提升自己。找到短板进行补充，给自己一定成就感。实践与理论同样重要，要注意结合，例如算法会用到的数学知识。用有意思的项目做为自己学习道路的标记。可尝试以教为学。<br>    2、单片机：大佬说，单片机这种玩意儿就是应用层、驱动层，跑一些逻辑程序。最终还是都要学到嵌入式AI的，加油。<br>    3、项目中用到的新技术：先判断需求，再去翻其他大佬是如何实现的，再分硬件和软件逐个攻破，多看教程和书籍，及时总结。<br>    4、善用Arduino<br>    5、关于嵌入式：如果想尝试就一定需要学linux，纯单片机开发较少，最终还是看算法的。<br>    6、PCB：工程级，靠熟能生巧，跟着教程学习即可，边做边学，推荐：杜洋工作室的PCB双人相声教程。<br>    7、时间管理方法：分清优先级，先做优先级最高的事情。<br>    8、研究生：学历是很大的竞争力，读研很香。<br>    9、深度与广度：先在某个领域吃透深度，再考虑广度。深度围绕职业发展，广度围绕兴趣爱好。<br>    10、Matlab被ban：对企业有影响，科技存在国界，我辈当自强！	<br>    11、本科学习：多做比赛，多实践，多拿奖。<br>    12、指路：→ <a href="http://www.pengzhihui.com/">www.pengzhihui.com</a></p>
<p>OhMYGpt实现原理:</p>
<p>前端用的 Vue3+TailwindCSS+NaiveUI 组件库</p>
<p>送给jQuery转Vue的人一句话：时刻记住，Vue只关注数据，UI上的变化是根据数据来驱动的。<br>一个常见的例子：表格新增一行数据，<strong>jquery需要先把这个新增一行的UI效果实现</strong>，之后再把数据绑定对应的控件；而对于Vue来说，这个表格可能就是一个数组，<strong>所谓的添加就是在这个数组追加一条数据，最后自动渲染UI效果。你完全不需要考虑UI和数据之间的绑定问题，因为他们本身就是双向绑定好的。</strong></p>
<h3 id="如果你发现网站关闭后每次都要重新登录-请看下这个图片-是不是打开了自动清除cookie数据"><a href="#如果你发现网站关闭后每次都要重新登录-请看下这个图片-是不是打开了自动清除cookie数据" class="headerlink" title="如果你发现网站关闭后每次都要重新登录,请看下这个图片,是不是打开了自动清除cookie数据"></a><code>如果你发现网站关闭后每次都要重新登录,请看下这个图片,是不是打开了自动清除cookie数据</code></h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230507210515371.png" alt="image-20230507210515371"></p>
<h3 id="业务永远比技术重要，技术是服务于业务的。"><a href="#业务永远比技术重要，技术是服务于业务的。" class="headerlink" title="业务永远比技术重要，技术是服务于业务的。"></a>业务永远比技术重要，技术是服务于业务的。</h3><p><img src="https://i2.hdslb.com/bfs/face/cb9ef82714507e6bda707dac216da94c97d70037.jpg@96w_96h_1c_1s.webp" alt="img"></p>
<p>​									<a href="https://space.bilibili.com/20259914">稚晖君</a></p>
<p>学习东西,有针对的去学,很感兴趣的技术</p>
<p>学习方法:</p>
<ol>
<li><p>边打仗边学习,学精学透然后再去搞是不行的,用到再学,</p>
</li>
<li><p>基础发展很快,实践最重要,边做项目,发现知识点不会,然后再去学,再去补,</p>
</li>
<li><p>看别人的项目,跟着别人的代码,学习里面自己不会的,学习的东西是一会就用得上的,学半天都很无聊,不知道什么时候用得上</p>
</li>
</ol>
<p>但是算法里面都要用,基础的课程学好,看懂前端的论文.</p>
<p>一定注意学习和理论的集合,必须应用,不然过段时间就忘了,阶段性的输出做笔记,总结代码,总结自己的代码和细节点,把新学到的知识和以前的知识做整合,然后做一些好用的项目</p>
<h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue router"></a>Vue router</h2><p>为了点击车辆卡片而显示其内部的数据,</p>
<p>我们不用重复的写相同的组件的代码,</p>
<p>只是为了显示,因为他们具有相同的数据结构,</p>
<p>只是后缀的id不同,我们渲染的还是同样的组件,只不过数据不同</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230415203211246.png" alt="image-20230415203211246"></p>
<p>请在Vuerouter这个文件直接看源代码,整理笔记比较麻烦</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">    <span class="keyword">import</span> carsData <span class="keyword">from</span> <span class="string">&quot;../components/data.json&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> &#123; useRouter, useRoute &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    <span class="comment">// useRoute是为了得到关于路径的信息</span></span><br><span class="line">​    <span class="comment">// useRouter是为了使用相关的函数</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">let</span> router = <span class="title function_">useRouter</span>(); <span class="comment">//不能重名,错误:const useRouter=useRouter()</span></span><br><span class="line">​    <span class="keyword">let</span> route = <span class="title function_">useRoute</span>();</span><br><span class="line">​    <span class="keyword">const</span> cars = <span class="title function_">ref</span>(carsData);</span><br><span class="line"></span><br><span class="line">​    <span class="comment">/*</span></span><br><span class="line"><span class="comment">​        需求:根据选择框选中的值,过滤显示选择的车牌厂家,也就是make.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​        这里使用watch监视make的值,每当make的值变化,执行一次后面的函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​        因为下面的v-for是根据cars的值去渲染的,所以改变cars的值,相应的就会改变</span></span><br><span class="line"><span class="comment">​        渲染的东西,render函数就是渲染函数.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     */</span></span><br><span class="line">​    <span class="keyword">const</span> make = <span class="title function_">ref</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">​    <span class="title function_">watch</span>(make, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">​        <span class="keyword">if</span> (make.<span class="property">value</span>) &#123;</span><br><span class="line">​            <span class="comment">//如果make的value不是空字符串</span></span><br><span class="line">​            <span class="keyword">if</span> (make.<span class="property">value</span> === <span class="string">&quot;All&quot;</span>) &#123;</span><br><span class="line">​                cars.<span class="property">value</span> = carsData;</span><br><span class="line">​            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">​                cars.<span class="property">value</span> = carsData.<span class="title function_">filter</span>(<span class="function">(<span class="params">car</span>) =&gt;</span> car.<span class="property">make</span> === make.<span class="property">value</span>);</span><br><span class="line">​                <span class="comment">//过滤你选中的make===车辆里面的make的数组元素,传递给cars.value</span></span><br><span class="line">​                <span class="comment">//上面的 car =&gt; car.make 里的 car 应该就是 carsData 里面的数组元素</span></span><br><span class="line">​                <span class="comment">// 筛选出来符合条件((car) =&gt; car.make === make.value)的,然后返回这些符合条件的数组元素</span></span><br><span class="line"></span><br><span class="line">​                <span class="comment">//filter:过滤器</span></span><br><span class="line">​                <span class="comment">//Returns the elements of an array that meet the condition specified in a callback function.</span></span><br><span class="line">​            &#125;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;);</span><br><span class="line">​    <span class="comment">/*</span></span><br><span class="line"><span class="comment">​    需求:添加查询参数,使得选择到保时捷:Porsche时,你把url发送给别人,别人打开网址的时候,还是选择保时捷的页面,</span></span><br><span class="line"><span class="comment">​    而不是All页面.</span></span><br><span class="line"><span class="comment">​    首先添加:import useRouter from &quot;vue-router&quot; 使用路由器</span></span><br><span class="line"><span class="comment">​    添加查询参数:push query parameter,路径 be like:http://localhost:5173/?make=Audi&amp;banana=banana</span></span><br><span class="line"><span class="comment">​    为了访问路径中的参数,使用:useRoute</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">​        router.<span class="title function_">push</span>(&#123; <span class="attr">query</span>: &#123; <span class="attr">make</span>: make.<span class="property">value</span> &#125; &#125;);</span><br><span class="line">​    &#125;;</span><br><span class="line">​    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">​        make.<span class="property">value</span> = route.<span class="property">query</span>.<span class="property">make</span>;</span><br><span class="line">​    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>​	import carsData from “..&#x2F;components&#x2F;data.json”;<br>​    import { ref, watch } from “vue”;<br>​    import { useRouter, useRoute } from “vue-router”;</p>
<p>​    let ruter &#x3D; useRouter();<br>​    let route &#x3D; useRoute();<br>​    const cars &#x3D; ref(carsData);<br>​    const make &#x3D; ref(“”);<br>​    watch(make, () &#x3D;&gt; {<br>​        if (make.value) {<br>​            if (make.value &#x3D;&#x3D;&#x3D; “All”) {<br>​                cars.value &#x3D; carsData;<br>​            } else {<br>​                cars.value &#x3D; carsData.filter((car) &#x3D;&gt; car.make &#x3D;&#x3D;&#x3D; make.value);<br>​            }<br>​        }<br>​    });</p>
<p>​    const handleChange &#x3D; () &#x3D;&gt; {<br>​        router.push({ query: { make: make.value } });<br>​    };<br>​    onMounted(() &#x3D;&gt; {<br>​        make.value &#x3D; route.query.make;<br>​    });</p>
<h2 id="小满router"><a href="#小满router" class="headerlink" title="小满router"></a>小满router</h2><h3 id="创建历史模式原理"><a href="#创建历史模式原理" class="headerlink" title="创建历史模式原理"></a>创建历史模式原理</h3><h4 id="1-createWebHashHistory"><a href="#1-createWebHashHistory" class="headerlink" title="1.createWebHashHistory"></a>1.createWebHashHistory</h4><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517165334984.png" alt="image-20230517165334984"></p>
<p>通过location.hash做的页面跳转</p>
<p>原理是window.addEventListener(<strong>hashchange</strong>,(e)&#x3D;&gt;{})</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517165457800.png" alt="image-20230517165457800"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517165226694.png" alt="image-20230517165226694"></p>
<h4 id="2-createWebHistory"><a href="#2-createWebHistory" class="headerlink" title="2.createWebHistory"></a>2.createWebHistory</h4><p>window监听popstate事件实现左右箭头跳转</p>
<p><strong><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517165620609.png" alt="image-20230517165620609"></strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517165717572.png" alt="image-20230517165717572"></p>
<p>相当于router.push的原理</p>
<h3 id="2-基本路由设置-path"><a href="#2-基本路由设置-path" class="headerlink" title="2.基本路由设置:path"></a>2.基本路由设置:path</h3><p><strong>底下的import是路由组件的懒加载</strong></p>
<p><code>lazy-loading</code></p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">路由懒加载 | Vue Router (vuejs.org)</a></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517165824687.png" alt="image-20230517165824687"></p>
<p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。</p>
<p><strong>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。</strong></p>
<h4 id="Vue-Router-支持开箱即用的动态导入，这意味着你可以用动态导入代替静态导入："><a href="#Vue-Router-支持开箱即用的动态导入，这意味着你可以用动态导入代替静态导入：" class="headerlink" title="Vue Router 支持开箱即用的动态导入，这意味着你可以用动态导入代替静态导入："></a>Vue Router 支持开箱即用的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports">动态导入</a>，这意味着你可以用动态导入代替静态导入：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将</span></span><br><span class="line"><span class="comment">// import UserDetails from &#x27;./views/UserDetails.vue&#x27;</span></span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserDetails</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./views/UserDetails.vue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">UserDetails</span> &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>component</code> (和 <code>components</code>) 配置接收一个返回 Promise 组件的函数，Vue Router <strong>只会在第一次进入页面时才会获取这个函数</strong>，然后使用缓存数据。这意味着你也可以使用更复杂的函数，只要它们返回一个 Promise ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">UserDetails</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(&#123;</span><br><span class="line">    <span class="comment">/* 组件定义 */</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>一般来说，对所有的路由<strong>都使用动态导入</strong>是个好主意。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>不要</strong>在路由中使用<a href="https://v3.vuejs.org/guide/component-dynamic-async.html#async-components">异步组件</a>。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的。</p>
<p>如果你使用的是 webpack 之类的打包器，它将自动从<a href="https://webpack.js.org/guides/code-splitting/">代码分割</a>中受益。</p>
<p>如果你使用的是 Babel，你将需要添加 <a href="https://babeljs.io/docs/plugins/syntax-dynamic-import/">syntax-dynamic-import</a> 插件，才能使 Babel 正确地解析语法。</p>
<h3 id="3-编程式路由"><a href="#3-编程式路由" class="headerlink" title="3.编程式路由"></a>3.编程式路由</h3><h4 id="命名式路由"><a href="#命名式路由" class="headerlink" title="命名式路由"></a>命名式路由</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">toPage</span> = (<span class="params">url: string</span>) =&gt; &#123;</span><br><span class="line">     router.<span class="title function_">push</span>(&#123;</span><br><span class="line">​      <span class="attr">name</span>: url,</span><br><span class="line">​    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517170032341.png" alt="image-20230517170032341"></p>
<p>{path:”&#x2F;“,<strong>name:”login”</strong>,component:()&#x3D;&gt;import(“”)}</p>
<h3 id="4-历史记录"><a href="#4-历史记录" class="headerlink" title="4.历史记录"></a>4.历史记录</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517173221005.png" alt="image-20230517173221005"></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//router.replace(url); //replace,不能通过左右箭头去跳转历史记录</span></span><br><span class="line">		<span class="comment">//定义replace,下面的go和back都不能用了,完全创建新的组件去渲染</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		router.<span class="title function_">go</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">prev</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="comment">//router.go(-1);//和back相同</span></span><br><span class="line">		router.<span class="title function_">back</span>();</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-路由传参"><a href="#5-路由传参" class="headerlink" title="5.路由传参"></a>5.路由传参</h3><h4 id="第一种方式-query"><a href="#第一种方式-query" class="headerlink" title="第一种方式:query"></a>第一种方式:query</h4><p>使用 useRoute 的 query</p>
<p>import { useRoute } from ‘vue-router’;<br>   const route &#x3D; useRoute()</p>
<ul>
<li>品牌：<br>价格：<br>ID：</li>
</ul>
<p><strong>想把数据传输到路由组件里面,路由传参,<strong>下面的query只能接收到</strong>对象类型的值,</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517175222685.png" alt="image-20230517175222685"></p>
<p>最终的query会放到路径(route)里面:<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517175539119.png" alt="image-20230517175539119"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517175358611.png" alt="image-20230517175358611"></p>
<p>也即是说,<code>route</code>负责<strong>路径</strong>的访问,<code>router</code>负责<strong>路由的控制</strong>,<strong>访问route</strong>:route.query?.name</p>
<p><strong>不知道的就console.log(route)</strong></p>
<p>渲染结果:</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517175602318.png" alt="image-20230517175602318"></p>
<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p><strong>params</strong>,得使用路由的name去访问路由组件,path无效,地址栏没有信息,比query更安全,保存在内存当中的,值在刷新网页会丢失<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517180045129.png" alt="image-20230517180045129"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517180005601.png" alt="image-20230517180005601"></p>
<h4 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h4><p><strong>动态路由参数</strong></p>
<p>很多时候,我们要把匹配到对应url的路由映射到同一个组件.假设有一个User组件,对所有的用户进行渲染,但是用户的id不同,在Vue router中,可以在路径中使用一个动态的字段实现,叫做<em>路径参数</em></p>
<p><em>路径参数</em></p>
<p>*在path里面在”&#x2F;reg&#x2F;:id”*以冒号＋名称的形式定义</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517181712935.png" alt="image-20230517181712935"></p>
<p>传入路径参数对应的值</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517180656404.png" alt="image-20230517180656404"></p>
<p>在实际映射的组件中使用<strong>find方法</strong>遍历data数组,然后找到第一个符合条件<code>value.id===Number(route.params.id)</code>的对象值并且返回,使用item接收</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517180922427.png" alt="image-20230517180922427"></p>
<h3 id="6-嵌套路由"><a href="#6-嵌套路由" class="headerlink" title="6.嵌套路由"></a>6.嵌套路由</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517182256700.png" alt="image-20230517182256700"></p>
<p>此处的footer.vue是父路由,<strong>path是”&#x2F;user”</strong></p>
<p>在对象中配置children这个属性,必须设定为<strong>数组</strong>,然后写<strong>对应的url和组件</strong></p>
<p><em>你作为&#x2F;user的子组件,在跳转的时候,也得是在&#x2F;user下跳转</em></p>
<p>想显示reg.vue组件,那么路径就是<code>/user/reg</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517182709895.png" alt="image-20230517182709895"></p>
<h3 id="7-命名视图"><a href="#7-命名视图" class="headerlink" title="7.命名视图"></a>7.命名视图</h3><p>这个东西(命名视图)可以在同一个组件中<strong>显示</strong>更多的router-view,类似于插槽slot</p>
<p>定义多个即::{},变成对象,并且＋s.</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517213316323.png" alt="image-20230517213316323"></p>
<p>类似于插槽,name指定插槽出口,此处是<code>name</code>指定<strong>路由出口</strong>,<strong>default就是指的是默认啥name都不写的router-view</strong>,指定<strong>name</strong>就是指定上面的components这个对象的key值:bbb和ccc</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517213244967.png" alt="image-20230517213244967"></p>
<h3 id="8-重定向和别名"><a href="#8-重定向和别名" class="headerlink" title="8.重定向和别名"></a>8.重定向和别名</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517213807616.png" alt="image-20230517213807616"></p>
<p>重定向redirect就是在访问路径&#x2F;的时候,改变路径到你指定的redirect的路径位置</p>
<p>现在我访问path:”&#x2F;“,则最终执行的访问是”&#x2F;user1”,to是父路由的信息</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517214011517.png" alt="image-20230517214011517"></p>
<p>传入query参数,那么在重定向的时候就会在路径附带上query<img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517214058272.png" alt="image-20230517214058272"></p>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>alias:给路径起个别名,但是对应同一个组件. </p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517214258004.png" alt="image-20230517214258004"></p>
<p>此时访问path和访问alias指定的路径,效果是一样的</p>
<p>访问&#x2F;root</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517214341557.png" alt="image-20230517214341557"></p>
<p>访问&#x2F;root1,<strong>效果相同!</strong></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517214413642.png" alt="image-20230517214413642"></p>
<h3 id="9-路由过渡动效"><a href="#9-路由过渡动效" class="headerlink" title="9.路由过渡动效"></a>9.路由过渡动效</h3><p><a href="https://router.vuejs.org/zh/guide/advanced/transitions.html">过渡动效 | Vue Router (vuejs.org)</a></p>
<p>想要在你的路径组件上使用转场，并对导航进行动画处理，你需要使用 <a href="https://router.vuejs.org/guide/advanced/composition-api.html#uselink">v-slot API</a>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;fade&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://v3.vuejs.org/guide/transitions-enterleave.html">Transition 的 API</a> 在这里同样适用。</p>
<h3 id="9-5-组合式API"><a href="#9-5-组合式API" class="headerlink" title="9.5.组合式API"></a>9.5.组合式API</h3><p><a href="https://router.vuejs.org/zh/guide/advanced/composition-api.html">Vue Router 和 组合式 API | Vue Router (vuejs.org)</a></p>
<h4 id="在-setup-中访问路由和当前路由"><a href="#在-setup-中访问路由和当前路由" class="headerlink" title="在 setup 中访问路由和当前路由"></a>在 <code>setup</code> 中访问路由和当前路由</h4><p>因为我们在 <code>setup</code> 里面没有访问 <code>this</code>，所以我们不能再直接访问 <code>this.$router</code> 或 <code>this.$route</code>。作为替代，我们使用 <code>useRouter</code> 和 <code>useRoute</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter, useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">pushWithQuery</span>(<span class="params">query</span>) &#123;</span><br><span class="line">      router.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">        <span class="attr">query</span>: &#123;</span><br><span class="line">          ...route.<span class="property">query</span>,</span><br><span class="line">          ...query,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>route</code> 对象是一个<strong>响应式对象</strong>，所以它的任何属性都可以被监听，但你应该<strong>避免监听整个 <code>route</code></strong> 对象。在大多数情况下，你应该直接监听你期望改变的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line">    <span class="keyword">const</span> userData = <span class="title function_">ref</span>()</span><br><span class="line">    <span class="comment">// 当参数更改时获取用户信息</span></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> route.<span class="property">params</span>.<span class="property">id</span>,</span><br><span class="line">      <span class="keyword">async</span> newId =&gt; &#123;</span><br><span class="line">        userData.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchUser</span>(newId)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="请注意，在模板中我们仍然可以访问-router-和-route，所以不需要在-setup-中返回-router-或-route"><a href="#请注意，在模板中我们仍然可以访问-router-和-route，所以不需要在-setup-中返回-router-或-route" class="headerlink" title="请注意，在模板中我们仍然可以访问 $router 和 $route，所以不需要在 setup 中返回 router 或 route."></a>请注意，在模板中我们仍然可以访问 <code>$router</code> 和 <code>$route</code>，所以不需要在 <code>setup</code> 中返回 <code>router</code> 或 <code>route</code>.</h4><h4 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h4><p>虽然你仍然可以通过 <code>setup</code> 函数来使用组件内的导航守卫，但 Vue Router 将更新和离开守卫作为 组合式 API 函数公开：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 与 beforeRouteLeave 相同，无法访问 `this`</span></span><br><span class="line">    <span class="title function_">onBeforeRouteLeave</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> answer = <span class="variable language_">window</span>.<span class="title function_">confirm</span>(</span><br><span class="line">        <span class="string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span></span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 取消导航并停留在同一页面上</span></span><br><span class="line">      <span class="keyword">if</span> (!answer) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> userData = <span class="title function_">ref</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 beforeRouteUpdate 相同，无法访问 `this`</span></span><br><span class="line">    <span class="title function_">onBeforeRouteUpdate</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//仅当 id 更改时才获取用户，例如仅 query 或 hash 值已更改</span></span><br><span class="line">      <span class="keyword">if</span> (to.<span class="property">params</span>.<span class="property">id</span> !== <span class="keyword">from</span>.<span class="property">params</span>.<span class="property">id</span>) &#123;</span><br><span class="line">        userData.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchUser</span>(to.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合式 API 守卫也可以用在任何由 <code>&lt;router-view&gt;</code> 渲染的组件中，它们不必像组件内守卫那样直接用在路由组件上。</p>
<h4 id="useLink"><a href="#useLink" class="headerlink" title="useLink"></a><code>useLink</code></h4><p><code>Vue Router</code> 将<code> RouterLink</code> 的内部行为作为一个组合式函数 (composable) 公开。它接收一个类似 <code>RouterLink</code> 所有 prop 的响应式对象，并暴露底层属性来构建你自己的 <code>RouterLink</code> 组件或生成自定义链接：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterLink</span>, useLink &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;AppLink&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 如果使用 TypeScript，请添加 @ts-ignore</span></span><br><span class="line">    ...<span class="title class_">RouterLink</span>.<span class="property">props</span>,</span><br><span class="line">    <span class="attr">inactiveClass</span>: <span class="title class_">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="comment">// 解析出来的路由对象</span></span><br><span class="line">      route,</span><br><span class="line">      <span class="comment">// 用在链接里的 href</span></span><br><span class="line">      href,</span><br><span class="line">      <span class="comment">// 布尔类型的 ref 标识链接是否匹配当前路由</span></span><br><span class="line">      isActive,</span><br><span class="line">      <span class="comment">// 布尔类型的 ref 标识链接是否严格匹配当前路由</span></span><br><span class="line">      isExactActive,</span><br><span class="line">      <span class="comment">// 导航至该链接的函数</span></span><br><span class="line">      navigate</span><br><span class="line">      &#125; = <span class="title function_">useLink</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isExternalLink = <span class="title function_">computed</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="keyword">typeof</span> props.<span class="property">to</span> === <span class="string">&#x27;string&#x27;</span> &amp;&amp; props.<span class="property">to</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; isExternalLink, href, navigate, isActive &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在 RouterLink 的 <code>v-slot</code> 中可以访问与 <code>useLink</code> 组合式函数相同的属性。</p>
<h3 id="10-路由元信息"><a href="#10-路由元信息" class="headerlink" title="10.路由元信息"></a>10.路由元信息</h3><p>通过路由记录的 <code>meta</code> 属性可以定义路由的<strong>元信息</strong>。使用路由<code>meta</code>可以在路由中附加自定义的数据.</p>
<ul>
<li>权限校验的验证标识:token。</li>
<li>路由组件的过渡名称:transition</li>
<li>路由组件持久化缓存 (keep-alive)。</li>
<li>标题名称:title</li>
</ul>
<p>我们可以在<strong>导航守卫</strong>或者是<strong>路由对象</strong>(useRoute(),route)中访问路由的meta。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/Login.vue&#x27;</span>),<span class="comment">//这里有路由的懒加载,lazyload</span></span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;登录&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/index&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/Index.vue&#x27;</span>),</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;首页&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="使用TS扩展"><a href="#使用TS扩展" class="headerlink" title="使用TS扩展"></a>使用TS扩展</h4><p>如果不使用扩展 将会是unknown 类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare module &#x27;vue-router&#x27; &#123;</span><br><span class="line">  interface RouteMeta &#123;</span><br><span class="line">    title?: string</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-路由导航守卫"><a href="#11-路由导航守卫" class="headerlink" title="11.路由导航守卫"></a>11.路由导航守卫</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517222725487.png" alt="image-20230517222725487"></p>
<p>beforeEach指的是前置的守卫,写在main.ts||main.js里面</p>
<p><strong><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517222818137.png" alt="image-20230517222818137"></strong></p>
<h4 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a><strong>全局前置守卫</strong></h4><p>router.<a href="">beforeEach</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(to, <span class="keyword">from</span>);</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>每个守卫方法接收三个参数(to,from,next)</p>
<ul>
<li><p>to:Route 要进入的目标的route对象.即跳转到对应的url时,里面Route存储的相关信息</p>
</li>
<li><p>from:Route 要离开时,当前路由对应的route对象</p>
</li>
<li><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230517224753113.png" alt="image-20230517224753113"></p>
</li>
<li><p>next():指的是.接下来跳转到哪个url,渲染哪个组件呢?</p>
</li>
<li><p>在 Vue.js 中使用 Vue Router 进行路由操作，可以使用 <code>beforeEach</code> 来对每个路由跳转进行拦截处理。 在这个路由跳转前的导航守卫中，可以通过调用 <code>next</code> 函数（该函数在 <code>beforeEach</code> 中传递的回调函数参数中）来控制导航行为。</p>
<p><code>next</code> 方法接收一个参数，这个参数可以是一个对象、一个 URL 字符串或者 <code>false</code>。</p>
<p>当传递一个对象时，这个对象应该包含下面的属性：</p>
<ul>
<li><code>path</code>: 跳转到的路由路径</li>
<li><code>query</code>: 一个包含查询参数的对象</li>
<li><code>params</code>: 一个包含动态路由参数的对象</li>
<li><code>replace</code>: 是否将导航行为替换为当前的路由历史记录，默认为 <code>false</code></li>
<li><code>name</code>: 跳转到的路由的名称</li>
</ul>
<p>当传递一个 URL 字符串时，下一个路由路径将被视为要跳转的目标。</p>
<p>当传递 <code>false</code> 时，表示取消当前的导航行为。</p>
<p>当不传递任何参数时，表示继续执行当前的导航行为，在这种情况下，必须手动调用 <code>next()</code> 来通知 Vue Router 继续执行。</p>
<p>在 <code>beforeEach</code> 导航守卫中使用 <code>next()</code>，可以将用户导航到下一个拦截的路由或取消导航行为。例如，当用户未登录时可以在 <code>beforeEach</code> 中进行拦截，通过 <code>next(&#39;/login&#39;)</code> 将用户导航跳转到登录页面。</p>
</li>
</ul>
<h4 id="全局后置守卫"><a href="#全局后置守卫" class="headerlink" title="全局后置守卫"></a>全局后置守卫</h4><p>使用场景一般可以用来做loadingBar(加载进度条)</p>
<p>你也可以注册全局后置hook，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title class_">Vnode</span>.<span class="property">component</span>?.<span class="property">exposed</span>?.<span class="title function_">endLoading</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>loadingBar组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wraps&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script setup lang=&#x27;ts&#x27;&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">let speed = ref&lt;number&gt;(1)</span><br><span class="line">let bar = ref&lt;HTMLElement&gt;()</span><br><span class="line">let timer = ref&lt;number&gt;(0)</span><br><span class="line">const startLoading = () =&gt; &#123;</span><br><span class="line">    let dom = bar.value as HTMLElement;</span><br><span class="line">    speed.value = 1</span><br><span class="line">    timer.value = window.requestAnimationFrame(function fn() &#123;</span><br><span class="line">        if (speed.value &lt; 90) &#123;</span><br><span class="line">            speed.value += 1;</span><br><span class="line">            dom.style.width = speed.value + &#x27;%&#x27;</span><br><span class="line">            timer.value = window.requestAnimationFrame(fn)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            speed.value = 1;</span><br><span class="line">            window.cancelAnimationFrame(timer.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const endLoading = () =&gt; &#123;</span><br><span class="line">    let dom = bar.value as HTMLElement;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">            speed.value = 100;</span><br><span class="line">            dom.style.width = speed.value + &#x27;%&#x27;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, 500)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">defineExpose(&#123;</span><br><span class="line">    startLoading,</span><br><span class="line">    endLoading</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;</span><br><span class="line">.wraps &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 2px;</span><br><span class="line">    .bar &#123;</span><br><span class="line">        height: inherit;</span><br><span class="line">        width: 0;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>main.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> loadingBar <span class="keyword">from</span> <span class="string">&#x27;./components/loadingBar.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vnode</span> = <span class="title function_">createVNode</span>(loadingBar)</span><br><span class="line"><span class="title function_">render</span>(<span class="title class_">Vnode</span>, <span class="variable language_">document</span>.<span class="property">body</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vnode</span>);</span><br><span class="line"> </span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Vnode</span>.<span class="property">component</span>?.<span class="property">exposed</span>?.<span class="title function_">startLoading</span>()</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Vnode</span>.<span class="property">component</span>?.<span class="property">exposed</span>?.<span class="title function_">endLoading</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="小满可视化"><a href="#小满可视化" class="headerlink" title="小满可视化"></a>小满可视化</h2><h4 id="看视频看到不会的"><a href="#看视频看到不会的" class="headerlink" title="看视频看到不会的"></a>看视频看到不会的</h4><h5 id="import-as-echarts-from-echarts"><a href="#import-as-echarts-from-echarts" class="headerlink" title="import * as echarts from echarts"></a>import * as echarts from echarts</h5><p>在 JavaScript 中，<code>*</code> 是一种通配符，可以用来匹配各种值。当使用 <code>import</code> 导入模块时，<code>*</code> 可以和 <code>as</code> 关键字一起使用，表示将模块中的所有导出成员都绑定到一个指定的名称上，这个名称可以是一个对象、变量或者别名等。</p>
<p>例如，这段代码中的 <code>* as echarts</code> 表示将整个 <code>echarts</code> 模块都绑定到一个名为 <code>echarts</code> 的对象上。也就是说，通过 <code>echarts</code> 对象可以访问到 <code>echarts</code> 模块中定义的所有成员，包括函数、类、常量等等。</p>
<p>当然，如果只想要引入模块中的某个成员，可以使用如下方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; someExport &#125; <span class="keyword">from</span> <span class="string">&quot;some-module&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&#123;&#125;</code> 表示只导入模块中的某个成员，<code>someExport</code> 是要导入的成员名称，<code>some-module</code> 表示模块的名称或路径。</p>
<p>总之，<code>* as</code> 意味着将整个模块作为一个对象引入，而 <code>&#123;&#125;</code> 表示只引入模块中的某个成员。</p>
<h2 id="什么是前端框架"><a href="#什么是前端框架" class="headerlink" title="什么是前端框架?"></a>什么是前端框架?</h2><p>MVVM就是view和model视图模型</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230417161724738.png" alt="image-20230417161724738"></p>
<h3 id="就是三部分"><a href="#就是三部分" class="headerlink" title="就是三部分"></a>就是三部分</h3><h3 id="1-渲染Rendering"><a href="#1-渲染Rendering" class="headerlink" title="1.渲染Rendering"></a>1.渲染Rendering</h3><p>就是在html文件中使用模板语法,将js中的数据渲染到html中</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230417161934915.png" alt="image-20230417161934915"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230417162035502.png" alt="image-20230417162035502"></p>
<h3 id="2-数据处理Data-handling"><a href="#2-数据处理Data-handling" class="headerlink" title="2.数据处理Data handling"></a>2.数据处理Data handling</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230417162105528.png" alt="image-20230417162105528"></p>
<p>先把你的数据放到框架里</p>
<p>然后将你的数据根据你的代码渲染到网页中</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230417162224061.png" alt="image-20230417162224061"></p>
<p>就是把值先放到框架里,使用这些值填充模板,都是a bouch of js代码,ts只是js的超集,等于c++和c语言</p>
<h3 id="3-事件处理Event-handling"><a href="#3-事件处理Event-handling" class="headerlink" title="3.事件处理Event handling"></a>3.事件处理Event handling</h3><p>不用在js里面写触发事件,直接在标签里面写属性,然后属性里面就绑定事件</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230417162458423.png" alt="image-20230417162458423"></p>
<h3 id="1-组件化-Vue"><a href="#1-组件化-Vue" class="headerlink" title="1.组件化.Vue"></a>1.组件化.Vue</h3><p>一个vue文件就是一个组件，引入vue文件即可实现。</p>
<h3 id="2-声明式编码"><a href="#2-声明式编码" class="headerlink" title="2.声明式编码"></a>2.声明式编码</h3><p>原生的js是命令式编码。 相当于让人喝水，但是一步步告诉拿起杯子去接水然后喝。</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230224212113001.png" alt="image-20230224212113001"></p>
<p>一步步指挥你。</p>
<p>但是vue是<em>声明式</em>编码</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230224212057332.png" alt="image-20230224212057332"></p>
<p>vue的指令需要记亿。相当于心有灵犀，依靠内部指令。 </p>
<h3 id="3-vue使用虚拟dom来做中间商。"><a href="#3-vue使用虚拟dom来做中间商。" class="headerlink" title="3.vue使用虚拟dom来做中间商。"></a>3.vue使用虚拟dom来做中间商。</h3><p>在构成列表的途中原生的js实现靠的是遍历和innerhtml加入字符串</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230224212945956.png" alt="image-20230224212945956"></p>
<p>虚拟dom：内存里的数据，vue翻译成真实的。针对于变化的数据。</p>
<p>比较算法就是diff。相当于增加元素的时候。</p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230224212825075.png" alt="image-20230224212825075"></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230225115430165.png" alt="image-20230225115430165"></p>
<h3 id="1-每个vue实例都具有手下人"><a href="#1-每个vue实例都具有手下人" class="headerlink" title="1.每个vue实例都具有手下人"></a>1.每个vue实例都具有手下人</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230225203455679.png" alt="image-20230225203455679"></p>
<p>粉色的都是组件。</p>
<h3 id="1-了解vue"><a href="#1-了解vue" class="headerlink" title="1.了解vue"></a>1.了解vue</h3><ul>
<li><p>前端框架:负责帮助我们构建UI(<code>用户界面</code>).</p>
</li>
<li><p>MVVM:模型-视图-<code>视图-模型</code></p>
</li>
<li><p>当数据发生变化时,页面会自动更新</p>
</li>
<li><p>可以通过页面操作数据</p>
</li>
</ul>
<p>后端:model(模型:数据) , 前端:视图(view).</p>
<p>服务器把数据拼接成网页,发送给浏览器显示.</p>
<p>服务器渲染:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开发成本:需要三个服务器去适配不同的客户端版本.返回json数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//桌面软件,网页,移动端:app</span></span><br></pre></td></tr></table></figure>

<p>现在就是将json数据通过dom插入到页面(views)里面</p>
<p>view-model:视图模型.用原生的js插入数据不方便,使用dom渲染视图时麻烦,vue框架,替换dom操作.</p>
<p><em>vue思想</em>:</p>
<ul>
<li><h4 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程:"></a>命令式编程:</h4></li>
<li><p>把事情的步骤按命令一步步执行</p>
</li>
<li><h4 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程:"></a>声明式编程:</h4></li>
<li><p>结果导向,我告诉vue我要什么样的界面,内部封装好了.具体的代码被vue写了,</p>
</li>
<li><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化:"></a>组件化:</h4></li>
<li><p>将开发的单位变成了组件,把之前的单位:页面继续细分,加快开发效率,一个组件相当于导航栏,下拉菜单,左边栏菜单</p>
</li>
<li><p>组件:将组件引入即可,增加代码复用性.</p>
</li>
<li><h4 id="渐进式"><a href="#渐进式" class="headerlink" title="渐进式"></a>渐进式</h4></li>
<li><p>适合于各种项目,可以在网页中一点一点的用vue去写,一个小组件用vue写,去替换一个网页中小的内容.</p>
</li>
<li><p>我想要h1,div,直接说,然后内部封装的功能自动帮你实现.</p>
</li>
</ul>
<h3 id="rest风格服务器"><a href="#rest风格服务器" class="headerlink" title="rest风格服务器:"></a><code>rest风格服务器</code>:</h3><p>Rest风格服务器.(<strong>资源在网络中以某种表现形式进行状态转移。</strong>)</p>
<p>URL中只使用名词来定位资源，用HTTP协议里的动词（GET、POST、PUT、DELETE）来实现资源的增删改查操作。</p>
<p>1.什么意思呢？<br>比如，我们有一个friends接口，对于“朋友”我们有增删改查四种操作，怎么定义REST接口？</p>
<p>增加一个朋友，uri: generalcode.cn&#x2F;v1&#x2F;friends 接口类型：POST<br>删除一个朋友，uri: generalcode.cn&#x2F;va&#x2F;friends 接口类型：DELETE（在http的parameter指定好友id）<br>修改一个朋友，uri: generalcode.cn&#x2F;va&#x2F;friends 接口类型：PUT（在http的parameter指定好友id）<br>查找一个朋友，uri: generalcode.cn&#x2F;va&#x2F;friends 接口类型：GET</p>
<p>上面我们定义的四个接口就是符合REST协议的，请注意，这几个接口都没有动词，只有名词friends，都是通过Http请求的接口类型来判断是什么业务操作。</p>
<p>举个反例：<br>generalcode.cn&#x2F;va&#x2F;deleteFriends 该接口用来表示删除朋友，这就是不符合REST协议的接口。<br>不能用deleteFriends ，而应该就用friends + http请求的delete方式。</p>
<p>一般接口的返回值绝大部分是JSON类型的。</p>
<p>总结：<br>看Url就知道要什么<br>看http method就知道干什么<br>看http status code就知道结果如何</p>
<h3 id="使用vite"><a href="#使用vite" class="headerlink" title="使用vite"></a>使用vite</h3><p>1.引入命令&#96;&#96;yarn add vite -D&#96;;</p>
<p>2.初始化yarn:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳过会话，直接通过默认值生成 package.json*</span></span><br><span class="line"></span><br><span class="line">​  yarn init --yes  <span class="comment">//简写 -y</span></span><br></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件:普通的js对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-render函数"><a href="#1-render函数" class="headerlink" title="1.render函数"></a>1.render函数</h3><p>render(给予,再次给出:<code>ren=re:再一次.der=do,给</code>)</p>
<p>v.使成为,<strong>加工之后,再次让其呈现出的样子.</strong></p>
<p>v.翻译: She is rendering the book into english from French.</p>
<p>v.提交,提供,<strong>把事物或者想法加工后再次表现出来</strong></p>
<p>the jury render a verdict:<code>陪审团做出了判决</code></p>
<p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230322213944227.png" alt="image-20230322213944227"></p>
<p>render函数是Vue.js中一个比较高级的概念，用于在组件中手动渲染内容。利用render函数可以更加精细地控制组件的渲染过程，以及使用JavaScript灵活地生成和管理DOM元素。在使用render函数之前，通常需要先掌握Vue.js中的虚拟DOM和常见的渲染函数API。</p>
<p><strong>虚拟DOM</strong></p>
<p>虚拟DOM（Virtual DOM）是模仿浏览器中的真实DOM结构，但仅仅是存在于内存中的一种数据结构，它使得我们可以对真实DOM的渲染进行抽象，从而能够更好的操作和更新它。虚拟DOM通常是由Vue.js自动生成的，它可以减少对实际DOM的直接操作，使我们能够更快速地更新渲染。</p>
<p><strong>常见渲染函数API</strong></p>
<p>在使用render函数的时候，通常需要掌握一些常用的渲染函数API：</p>
<ul>
<li><code>createElement(tag, [data], [...children])</code>：创建一个虚拟DOM元素。第一个参数是标签名称，第二个参数是该元素的属性，第三个参数是该元素的子元素，没有子元素时可以省略。</li>
<li><code>h(tag, [data], [...children])</code>：createElement函数的缩写。</li>
<li><code>vm._v(text)</code>：创建一个文本节点。接受一个字符串参数，用于显示文本内容。</li>
<li><code>vm._s(value)</code>：将值转换为字符串。如果值是一个对象或数组，会自动调用 JSON.stringify() 进行转换。</li>
</ul>
<p><strong>render函数的结构</strong></p>
<p>通常情况下，render函数的结构如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">attrs</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结构中可以看出，render函数接收一个名为createElement的参数，它是一个用于创建虚拟DOM元素的函数。在函数体内部，我们可以使用createElement函数创建虚拟DOM，并返回一个渲染结果。在上述的例子中，我们使用createElement函数创建了一个div元素，该元素包含一个名为message的属性，它的值将被显示在div元素中。另外，我们还设置了该元素的属性和样式。</p>
<p><strong>常见的render函数应用</strong></p>
<p>以下是一些常见的render函数应用例子：</p>
<ol>
<li>渲染静态的HTML元素：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;container&#x27;</span>&#125;, [</span><br><span class="line">    <span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;Welcome to my Website&#x27;</span>),</span><br><span class="line">    <span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;This is a paragraph of text.&#x27;</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>渲染列表：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&#x27;ul&#x27;</span>, [</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>, item)</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>渲染动态的表单：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    <span class="title function_">createElement</span>(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">domProps</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">on</span>: &#123;</span><br><span class="line">        <span class="attr">input</span>: <span class="function"><span class="params">event</span> =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">message</span> = event.<span class="property">target</span>.<span class="property">value</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>, <span class="variable language_">this</span>.<span class="property">message</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的例子中，我们使用了createElement函数创建了一个包含输入框和一个名为message的属性的div元素，每当我们在输入框中输入时，message会随之发生变化。而在p元素中，我们又输出了改变后的值。</p>
<p>总体来说，render函数可以给我们提供更多的自由度和灵活度，可以让我们更加精细地控制内容的渲染，更好地应对复杂的UI场景。但是，因为render函数需要手动编写，容易出错且不易调试，所以在使用render函数时需要时刻注意代码质量和效率。同时，对于初学者来说，可以先从模板语法入手，学习render函数时再逐步深入。</p>
<h3 id="vue的单文件组件"><a href="#vue的单文件组件" class="headerlink" title="vue的单文件组件"></a>vue的单文件组件</h3><p>Vue的单文件组件是一种用于组织Vue.js应用程序代码的结构化方式。文件后缀是.vue</p>
<p>它将一个组件的HTML、CSS、JavaScript以及其他相关代码放在一个单独的文件中，从而使得我们可以更好地管理代码结构.</p>
<p>一个单文件组件通常包含三个部分：模板<code>template</code>、<code>JavaScript</code>和样式<code>style</code>。其中，模板部分使用Vue.js的模板语法编写组件的HTML结构，脚本部分是用JavaScript编写组件的逻辑和行为，而样式部分则可以是CSS、Sass、Less等。</p>
<p>单文件组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello-world&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个单文件组件。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&#x27;Hello World!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.hello-world</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，样式部分使用了“scoped”关键字，限制样式仅在单文件组件内部有效。</p>
<p>在Vue.js应用程序中，我们可以使用import或require方法导入单文件组件，并将其注册为全局或局部组件，供应用程序的其他部分使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWorld.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">HelloWorld</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-data详解"><a href="#1-data详解" class="headerlink" title="1.data详解"></a>1.data详解</h3><p><img src="C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230325222536593.png" alt="image-20230325222536593"></p>
<p><strong>在data函数中每次返回的都是一个新对象,相互独立,数据不相通.</strong></p>
<p>如果创建:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> obj;<span class="comment">//此时返回的代理都代理的obj导致数据互通,改一个就全都变了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果data返回对象呢?</p>
<p><strong>也是响应式数据!</strong></p>
<h2 id="组合式api"><a href="#组合式api" class="headerlink" title="组合式api"></a>组合式api</h2><script setup>


## 指令v-for

![image-20230407155024250](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230407155024250.png)

1.   diff算法,different算法,比较不同

2.   然后主要就是v-for就是对数组和对象的元素进行遍历,

3.   然后也可以使用解构赋值去用v-for

4.   比如上面的{id,name,age} in arr2.将id,name,和age取出,放到dom元素里面

5.   当使用v-for时,可以为元素指定一个唯一的key,这样元素在比较时会按照key比较而不是顺序,相当于一个唯一的id,指定元素是谁,比较的时候就是看前后对照的key,从而保证正确的input标签

6.   ![image-20230407162221313](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230407162221313.png)

7.   正确的input对照:

     ![image-20230407162254746](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230407162254746.png)

     这样就不会发生替换,新增也只是新增唐僧这个元素,而不是,在最开始修改的时候,就把这四个dom全部修改,然后按照顺序放在页面上,导致后面跟着的input不同,

     ![image-20230407162428050](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230407162428050.png)

## 虚拟dom



## pinia的基本使用

## 状态管理

- 状态（state）
        - 应用当中的数据就是状态
            - 状态即数据

    - 视图（view）
        - 视图用来呈现数据，用户通过视图访问数据
    - 交互（actions）
        - 用户的操作
        - 状态会根据用户在视图中的操作发生变化

-   提升状态

    -   当有多个组件需要使用到同一个state时，可以将state提升到这些组件共同的祖先组件中声明

    -   ``` js
        import { provide, ref } from "vue";
        //privide提供
        //inject注入
        const count = ref(0);
        const increment = () => {
                count.value++;
            };
        provide("count", {//第一个参数是privide的id
                count,
                increment,
            });//父组件提供privide
        //子组件
        const {count, increment} = inject("count")//传入id
        <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    -   这样一来所有这些组件便都可以通过祖先元素来访问到这个state</span><br><span class="line"></span><br><span class="line">-   state的修改</span><br><span class="line"></span><br><span class="line">-   store实例本身就是一个reactive对象，</span><br><span class="line"></span><br><span class="line">-   可以通过它直接访问state中的数据</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">但是如果**直接将state中数据解构出来**，那么数据将会**丧失响应性**</span><br><span class="line"></span><br><span class="line">可以通过**storeToRefs()**来对store进行**解构**，</span><br><span class="line"></span><br><span class="line">**const &#123; name, age, title &#125; = storeToRefs(stuStore);**</span><br><span class="line"></span><br><span class="line">`//使用storeToRefs方法传入store对象,然后解构`</span><br><span class="line"></span><br><span class="line">它可以将state和getters中的属性`解构为ref属性`，从而保留其响应性</span><br><span class="line"></span><br><span class="line">state的修改=&gt;</span><br><span class="line"></span><br><span class="line">	1. 直接修改</span><br><span class="line"></span><br><span class="line">2.   通过$patch</span><br><span class="line"></span><br><span class="line">3.   const clickHandler = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">     ​    stuStore.$patch(&#123;</span><br><span class="line"></span><br><span class="line">     ​      name: &quot;孙小圣&quot;,</span><br><span class="line"></span><br><span class="line">     ​      age: 20,</span><br><span class="line"></span><br><span class="line">     ​      skills: [&quot;救命毫毛&quot;],</span><br><span class="line"></span><br><span class="line">     ​    &#125;);</span><br><span class="line"></span><br><span class="line">4.   通过$patch传函数的形式的修改</span><br><span class="line"></span><br><span class="line">5.   stuStore.$patch((state) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">     ​     	state.skills.push(&quot;救命毫毛&quot;)</span><br><span class="line"></span><br><span class="line">     ​     &#125;)</span><br><span class="line"></span><br><span class="line">6.   直接替换state</span><br><span class="line"></span><br><span class="line">7.   重置state</span><br><span class="line"></span><br><span class="line">store的订阅:</span><br><span class="line"></span><br><span class="line">![image-20230505155740816](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230505155740816.png)</span><br><span class="line"></span><br><span class="line">![image-20230505160030543](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230505160030543.png)</span><br><span class="line"></span><br><span class="line">detached表示即使组件卸载以后,订阅依然生效</span><br><span class="line"></span><br><span class="line">![image-20230505160303320](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230505160303320.png)</span><br><span class="line"></span><br><span class="line">state表示当前组件的pinia仓库,从中可以判断</span><br><span class="line"></span><br><span class="line">## vueRouter</span><br><span class="line"></span><br><span class="line">### 看b站的尚硅谷视频写的笔记如下</span><br><span class="line"></span><br><span class="line">[117_尚硅谷Vue技术_路由的简介_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Zy4y1K7SH?p=117&amp;vd_source=dc4491d23247de9bc4628ca7a93eb3ad)</span><br><span class="line"></span><br><span class="line">### 整理看youtobe的视频笔记如下</span><br><span class="line"></span><br><span class="line">[Vue3路由-初级到高级_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1pG4y1n7WZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=dc4491d23247de9bc4628ca7a93eb3ad)</span><br><span class="line"></span><br><span class="line">![image-20230504162743004](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230504162743004.png)</span><br><span class="line"></span><br><span class="line">![image-20230504162821089](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230504162821089.png)</span><br><span class="line"></span><br><span class="line">路由就是一个对应关系:**一个path对应一个组件**,决定渲染某个组件,就转到相应的路径上去.</span><br><span class="line"></span><br><span class="line">![image-20230504165038689](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230504165038689.png)</span><br><span class="line"></span><br><span class="line">多个route需要经过router的管理.router就相当于一个监测者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### vscode笔记</span><br><span class="line"></span><br><span class="line">## 如何在vue中使用font-awesome?</span><br><span class="line"></span><br><span class="line">直接引入cdn,然后在组件内部直接写html一样的样式即可</span><br><span class="line"></span><br><span class="line">但是目前来看,运行不了,会出现一个深色方框</span><br><span class="line"></span><br><span class="line">很奇怪,原生的也用不了好像</span><br><span class="line"></span><br><span class="line">是不是没用free?</span><br><span class="line"></span><br><span class="line">语义化标签是HTML中一种增强文档结构并提供更准确含义的标签，它可以让开发者更清晰地描述页面元素的作用和意义，提高页面的可读性、可访问性和搜索引擎优化。一些常用的语义化标签包括：</span><br><span class="line"></span><br><span class="line">这些语义化标签可以使HTML结构更加清晰明了，同时也有助于搜索引擎更好地理解页面内容，提高搜索引擎排名。</span><br><span class="line"></span><br><span class="line">## 如何在vue+ts的项目中解决pnpm找不到模块报错?</span><br><span class="line"></span><br><span class="line">### 为什么当我使用pnpm安装依赖的时候,ts提示我找不到模块</span><br><span class="line"></span><br><span class="line">如果你已经排除了以上所有问题，那么可能是你的**tsconfig.json配置文件没有正确地设置模块解析选项**。**你可以在tsconfig.json文件中增加以下配置项：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
"moduleResolution": "node"
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">让typescript的模块解析方式使用node的方式。</span><br><span class="line"></span><br><span class="line">在以下所有文件全部加上这段代码&quot;moduleResolution&quot;: &quot;node&quot;</span><br><span class="line"></span><br><span class="line">``` ts</span><br><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;files&quot;: [],</span><br><span class="line">  &quot;references&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;path&quot;: &quot;./tsconfig.node.json&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;path&quot;: &quot;./tsconfig.app.json&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

大概是这个样子,找**compilerOptions**,编译选项~

在下列三个文件

![image-20230519183129443](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230519183129443.png)

这三个文件全部配置:

![image-20230519183146020](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230519183146020.png)

![image-20230519183156284](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230519183156284.png)这个是tsconfig.json

#### ![image-20230519183234667](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230519183234667.png)三个文件的编译选项都加上!!!!!!

## watch是用于监听响应式数据的函数

每当该数据变化,watch里的callback都会执行

watch第一个参数监听源

watch第二个参数回调函数callback（newVal,oldVal）

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(message, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新的值----&#x27;</span>, newVal);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;旧的值----&#x27;</span>, oldVal);</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="attr">immediate</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">deep</span>:<span class="literal">true</span><span class="comment">//开启深度监听,即使是嵌套的对象依然可以监听到数据的变化</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



watch第三个参数一个options配置项是一个对象

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="attr">immediate</span>:<span class="literal">true</span> <span class="comment">//是否立即调用一次</span></span><br><span class="line"></span><br><span class="line">	<span class="attr">deep</span>:<span class="literal">true</span> <span class="comment">//是否开启深度监听</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 监听Ref 案例

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> message = <span class="title function_">ref</span>(&#123;</span><br><span class="line">    <span class="attr">nav</span>:&#123;</span><br><span class="line">        <span class="attr">bar</span>:&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="title function_">watch</span>(message, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新的值----&#x27;</span>, newVal);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;旧的值----&#x27;</span>, oldVal);</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="attr">immediate</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">deep</span>:<span class="literal">true</span><span class="comment">//开启深度监听,即使是嵌套的对象依然可以监听到数据的变化</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

### 监听多个ref 注意变成数组啦

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch ,reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> message2 = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="title function_">watch</span>([message,message2], <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新的值----&#x27;</span>, newVal);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;旧的值----&#x27;</span>, oldVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

### 监听Reactive

使用reactive监听深层对象开启和不开启deep 效果一样

因为reactive对象在vue源码内部默认开启deep选项

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch ,reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> message = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">nav</span>:&#123;</span><br><span class="line">        <span class="attr">bar</span>:&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="title function_">watch</span>(message, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新的值----&#x27;</span>, newVal);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;旧的值----&#x27;</span>, oldVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

### 监听reactive的单一值

()=>message.name,此时要使用箭头函数给他返回一个对象的属性值

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch ,reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> message = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">name2</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>message.<span class="property">name</span>, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;新的值----&#x27;</span>, newVal);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;旧的值----&#x27;</span>, oldVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

## WatchEffect

算是带上了immediate:true的watch,回调函数内部的代码初始时会自动执行一次

然后不断监听放进去的值,同时接受一个参数: (**on invaildate**:失效时),

这个函数每次都会在数据更新前执行一次,WatchEffect自动返回一个stop函数,用来停止监听.

![image-20230521151106732](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521151106732.png)

![image-20230521172540530](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521172540530.png)

 onTrigger帮助调试

![image-20230521172903646](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521172903646.png)

![image-20230521172935763](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521172935763.png)

## 认识组件和生命周期

## 组件:

细化组件,防止高耦合,就是.vue这种文件,当成div就行了,模板,可以复用,可以循环,可以嵌套

## 生命周期



![image-20230521174757068](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521174757068.png)



| 创建                         | 更新                               |      |
| :--------------------------- | ---------------------------------- | ---- |
| onBeforeMount :读不到Dom元素 | onBeforeUpdate:还是旧版本的dom数据 |      |
| onMounted :可以读到Dom元素   | onUpdate:读取到新版本的dom数据     |      |

![image-20230521175322401](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521175322401.png)

在组件卸载和创建的时候,`v-if`是会**触发销毁和创建的生命周期函数**的

![image-20230521175650283](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521175650283.png)

创建组件,走的setup这个语法糖的内部代码

onRenderTracked

![image-20230521175912997](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521175912997.png)

调试常用

![image-20230521180000440](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521180000440.png)

![image-20230521175948119](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521175948119.png)

### 源码解析!

暂时放弃,还是看不太懂......

大概看看.

![image-20230521193532910](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521193532910.png)

卸载的时候,清除所有的依赖函数,清空完成,执行onBeforeMount

![image-20230521193607184](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521193607184.png)

清空完成,同样清空子节点

![image-20230521193709026](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521193709026.png)

卸载上述的东西完成,执行onUnMounted这个生命周期函数

![image-20230521193722662](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521193722662.png)

## 学习下less预处理器和实操组件

## Bem架构

block-element-modify这样的样式规范

![image-20230521194249152](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521194249152.png)

el-input里面的**-**代表这是一个**块:block**

el-input**__**wrapper里的**双下划线**代表**wrapper**`是`el-input**块内的一个元素**

modify也就是修饰的意思

![image-20230521194541366](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521194541366.png)

双横杠**--**去链接的,表示修饰词,此处表示这个button的样子是primary

## sass

### 嵌套规则

![image-20230521194850864](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521194850864.png)

`写在里面的会加上父亲的类名`

编译为:

![image-20230521195137227](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521195137227.png)

原先的.redbox加上了#main p

#### 如果你想跳出嵌套规则,就在想跳出去的类名上加入@at-root即可

![image-20230521195813100](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521195813100.png)

### 父亲选择符: &

![image-20230521195256882](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521195256882.png)

更多嵌套

![image-20230521195359232](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521195359232.png)

### 插值语句

![image-20230521195605510](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521195605510.png)

也即是`类名`和`属性名`都可以**是动态的**

## 混合指令@mixin

可以把@mixin当作css里面的函数,或者叫做预先定义好的一大团css代码,你可以使用`@include`去应用这一团代码

![image-20230521203425372](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230521203425372.png)

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> large-text &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: Arial;</span><br><span class="line">    size: <span class="number">20px</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

@mixin同样包含选择器和属性,可以使用&引用父选择器

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> clearfix &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">  * <span class="selector-tag">html</span> &amp; &#123; <span class="attribute">height</span>: <span class="number">1px</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### Including a Mixin: `@include`

@include large-text,还有需要的参数,这样就是为什么可以看作函数的原因

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.page-title</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> large-text;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

编译成

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.page-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>; &#125;</span><br></pre></td></tr></table></figure>

## 实际案例!! !

#### 终于知道什么md,sm还有xl是啥意思了

| Breakpoint断点          | Class infix类中缀 | Dimensions尺寸  |
| ----------------------- | ----------------- | --------------- |
| Extra small特小号       | *None* 无         | <576px          |
| Small小                 | `sm`              | ≥576px≥ 576px   |
| Medium中等              | `md`              | ≥768px≥ 768px   |
| Large大                 | `lg`              | ≥992px≥ 992px   |
| Extra large特大号       | `xl`              | ≥1200px≥ 1200px |
| Extra extra large特大号 | `xxl`             | ≥1400px≥ 1400px |

就是相应英文的简写

**/* 一般在App.vue这个文件内部是不用scoped的,全局生效 */**

#### 写一个简单的layout布局

##### vite配置文件:

##### 全局导入scss

![image-20230522001813094](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522001813094.png)

##### bem.scss的相关配置,因为嵌套,所以&的取值不同

![image-20230522001912836](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522001912836.png)

##### 最终在app.vue的编写

![image-20230522001957344](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522001957344.png)

##### 编译出的css

![image-20230522002017419](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522002017419.png)

##### 呈现效果:

![image-20230522002039837](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522002039837.png)

#### 正式写这个layOut布局

## 父子组件传参

defineProps

现在我倾向于使用全局状态管理pinia去搞.

但是有时候遇到了一个数据保存在一个组件中,这个数据在这个组件里面变化,

想把变化的值传到兄弟组件,如何传值?,

可以**借助父组件去传值**,回调函数的参数

#### A组件

![image-20230529215432503](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230529215432503.png)

但是每次都要父组件去处理中间的逻辑

#### 父组件

![image-20230529215710555](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230529215710555.png)

#### EventBus实现兄弟组件传值

##### 全局事件总线

大概实现原理就是js内部的发布订阅机制,构建调度中心 

emit这个发送事件的参数最终会传递到on这个监听函数内.

![image-20230529220106202](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230529220106202.png)

对象签名?

...args:Array<any>取剩余的所有参数

目的是把emit的参数传递给on

![image-20230529220958496](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230529220958496.png)

基本上和pinia差不多,一个全局的仓库,一个全局的事件发布和接受

这样不用通过父组件去传值而是利用自己写的这个bus去传值和传参

## Emit派发事件

### Child组件

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">//声明触发的事件</span><br><span class="line">const emit = defineEmits([&#x27;response&#x27;])</span><br><span class="line"></span><br><span class="line">const sendEmit=()=&gt;&#123;</span><br><span class="line">  emit(&#x27;response&#x27;, &#x27;hello from child&#x27;,&quot;hello from lhg&quot;)</span><br><span class="line">&#125;//前面的参数是要发送的事件,后面的参数是要送给父组件的信息</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;Child component&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;sendEmit&quot;&gt;</span><br><span class="line">    发送事件</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

### App组件

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import ChildComp from &#x27;./ChildComp.vue&#x27;</span><br><span class="line"></span><br><span class="line">const childMsg = ref(&#x27;No child msg yet&#x27;)</span><br><span class="line">const Msg=ref(&#x27;&#x27;)</span><br><span class="line">const handleRes=(...args)=&gt;&#123;</span><br><span class="line">  Msg.value=args;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">//在组件上直接写@response</span><br><span class="line">//就是监听发送的事件,事件名称是response</span><br><span class="line">//response子组件定义好的</span><br><span class="line">//接收到事件后触发handleRes这个函数</span><br><span class="line">  &lt;ChildComp @response=&quot;handleRes&quot; /&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; Msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

##### 最终结果

![image-20230529224940825](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230529224940825.png)

此处的

const handleRes=(...args)=>

{
          Msg.value=args;
    }

里面的...args是扩展运算符,把传入的参数直接解出来,然后组成数组,赋值给Msg.

所以可以一直接受传递过来的参数

总结来看就是子组件定义事件,然后发送.

父组件收到子组件发送的事件消息,触发以后,可以在父组件里面写相应的事件处理逻辑,也就是说:

-   子组件只负责传递信息和发送事件
-   父组件负责在收到事件和接受消息(子组件传递的参数)
-   然后发生函数的调用(在父组件中,处理相对应的逻辑)

### 使用Mitt

在vue3中$on，$off 和 $once 实例方法已被移除，组件实例不再实现事件触发接口，因此大家熟悉的EventBus便无法使用了。然而我们习惯了使用EventBus，对于这种情况我们可以使用Mitt库（其实就是我们视频中讲的发布订阅模式的设计）

##### 1.安装

`npm install mitt -S`

##### 2.main.ts 初始化

全局总线，vue 入口文件 main.js 中挂载全局属性

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&#x27;mitt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mit</span> = <span class="title function_">mitt</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//TypeScript注册</span></span><br><span class="line"><span class="comment">// 由于必须要拓展ComponentCustomProperties类型才能获得类型提示</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;vue&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ComponentCustomProperties</span> &#123;</span><br><span class="line">        <span class="attr">$Bus</span>: <span class="keyword">typeof</span> <span class="title class_">Mit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue3挂载全局API</span></span><br><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$Bus</span> = <span class="title class_">Mit</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

##### 3.使用方法通过emit派发， on 方法添加事件，off 方法移除，clear 清空所有

###### A组件派发（emit）

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;我是A&lt;/h1&gt;</span><br><span class="line">        &lt;button @click=&quot;emit1&quot;&gt;emit1&lt;/button&gt;</span><br><span class="line">        &lt;button @click=&quot;emit2&quot;&gt;emit2&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&#x27;ts&#x27;&gt;</span><br><span class="line">import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;</span><br><span class="line">const instance = getCurrentInstance();</span><br><span class="line">const emit1 = () =&gt; &#123;</span><br><span class="line">    instance?.proxy?.$Bus.emit(&#x27;on-num&#x27;, 100)</span><br><span class="line">&#125;</span><br><span class="line">const emit2 = () =&gt; &#123;</span><br><span class="line">    instance?.proxy?.$Bus.emit(&#x27;*****&#x27;, 500)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



###### B组件监听（on）

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;我是B&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&#x27;ts&#x27;&gt;</span><br><span class="line">import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;</span><br><span class="line">const instance = getCurrentInstance()</span><br><span class="line">instance?.proxy?.$Bus.on(&#x27;on-num&#x27;, (num) =&gt; &#123;</span><br><span class="line">    console.log(num,&#x27;===========&gt;B&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

###### 监听所有事件（ on("*") ）

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">instance?.<span class="property">proxy</span>?.<span class="property">$Bus</span>.<span class="title function_">on</span>(<span class="string">&#x27;*&#x27;</span>,<span class="function">(<span class="params"><span class="keyword">type</span>,num</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">type</span>,num,<span class="string">&#x27;===========&gt;B&#x27;</span>)</span><br><span class="line">&#125;)<span class="comment">//type是事件的名称 </span></span><br></pre></td></tr></table></figure>

###### 移除监听事件（off）

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Fn</span> = (<span class="params">num: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num, <span class="string">&#x27;===========&gt;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">instance?.<span class="property">proxy</span>?.<span class="property">$Bus</span>.<span class="title function_">on</span>(<span class="string">&#x27;on-num&#x27;</span>,<span class="title class_">Fn</span>)<span class="comment">//listen</span></span><br><span class="line">instance?.<span class="property">proxy</span>?.<span class="property">$Bus</span>.<span class="title function_">off</span>(<span class="string">&#x27;on-num&#x27;</span>,<span class="title class_">Fn</span>)<span class="comment">//unListen </span></span><br></pre></td></tr></table></figure>

###### 清空所有监听(clear)

`instance?.proxy?.$Bus.all.clear()`

## 递归组件和全局组件

## 动态组件



## 可选链操作符(?.):

![image-20230522154637930](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522154637930.png)

**里的**![image-20230522154649748](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522154649748.png)

![image-20230522154815839](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522154815839.png)

此处的a.children.length在常规情况下是读取不到,并且报错的

但是加上?.这个操作符,最终就会读到undefined,防止报错,并且undefined会隐式转换成false.

### ??

![image-20230522155057599](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522155057599.png)

当左边的表达式返回undefined || or,最终就会得到右边的值:[]

#### 不处理null和0

![image-20230522155250675](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522155250675.png)

动态组件代码

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;h1&gt;动态组件练习,基本应用场景就是Tab切换了&lt;/h1&gt;</span><br><span class="line">		&lt;div style=&quot;display: flex; justify-content: center&quot;&gt;</span><br><span class="line">			&lt;div</span><br><span class="line">				@click=&quot;switchTab(item, index)&quot;//此处传入得到的item和index,这都是v-for的参数,从data中获取的</span><br><span class="line">				v-for=&quot;(item, index) in data&quot;</span><br><span class="line">				class=&quot;tabs&quot;</span><br><span class="line">				:class=&quot;[isActive == index ? &#x27;active&#x27; : &#x27;&#x27;]&quot;&gt;//数组内部可使用三元运算符</span><br><span class="line">				&lt;div&gt;&#123;&#123; item.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;component :is=&quot;comId&quot;&gt;&lt;/component&gt;</span><br><span class="line">		&lt;div class=&quot;flex-container&quot;&gt;</span><br><span class="line">			&lt;heart class=&quot;heart&quot;&gt;&lt;/heart&gt;</span><br><span class="line">			&lt;Switch&gt;&lt;/Switch&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- 这个is属性必须对应引入的组件名称 --&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref, reactive, watch, computed, markRaw, shallowRef &#125; from &quot;vue&quot;;</span><br><span class="line">	import &#123; useRoute, useRouter &#125; from &quot;vue-router&quot;;</span><br><span class="line">	import AVue from &quot;@/components/expame/A.vue&quot;;</span><br><span class="line">	import BVue from &quot;@/components/expame/B.vue&quot;;</span><br><span class="line">	import CVue from &quot;@/components/expame/C.vue&quot;;</span><br><span class="line">	import heart from &quot;@/components/UIverse/heart.vue&quot;;</span><br><span class="line">	import Switch from &quot;@/components/UIverse/Switch.vue&quot;;</span><br><span class="line">	const comId = shallowRef(&quot;DVue&quot;); //将引入的组件名称直接放入ref,就能展示了</span><br><span class="line">	const isActive = ref(0);</span><br><span class="line">	//console.log(&quot;AVue::: &quot;, AVue.__file);组件的信息也就是个对象</span><br><span class="line">	const switchTab = (item: any, index: any) =&gt; &#123;</span><br><span class="line">		comId.value = item.component;</span><br><span class="line">		isActive.value = index;</span><br><span class="line">		console.log(comId.value);</span><br><span class="line">	&#125;;</span><br><span class="line">	const data = reactive([</span><br><span class="line">		&#123;</span><br><span class="line">			name: &quot;A组件&quot;,</span><br><span class="line">			component: &quot;DVue&quot;,</span><br><span class="line">			//component: markRaw(AVue),</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			name: &quot;B组件&quot;,</span><br><span class="line">			component: &quot;EVue&quot;,</span><br><span class="line">			// component: markRaw(BVue),</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			name: &quot;C组件&quot;,</span><br><span class="line">			component: &quot;FVue&quot;,</span><br><span class="line">			// component: markRaw(CVue),</span><br><span class="line">		&#125;,</span><br><span class="line">	]);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">	//第二种导入动态组件的方式</span><br><span class="line">	import DVue from &quot;@/components/expame/A.vue&quot;;</span><br><span class="line">	import EVue from &quot;@/components/expame/B.vue&quot;;</span><br><span class="line">	import FVue from &quot;@/components/expame/C.vue&quot;;</span><br><span class="line">	export default &#123;</span><br><span class="line">		components: &#123;</span><br><span class="line">			DVue,</span><br><span class="line">			EVue,</span><br><span class="line">			FVue,</span><br><span class="line">		&#125;, //类似于vue2的方式注册组件,同时使用字符串操控</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">	.heart &#123;</span><br><span class="line">		height: 2rem;</span><br><span class="line">		width: 2rem;</span><br><span class="line">	&#125;</span><br><span class="line">	.active &#123;</span><br><span class="line">		background: skyblue;</span><br><span class="line">	&#125;</span><br><span class="line">	.tabs &#123;</span><br><span class="line">		border: 1px solid #ccc;</span><br><span class="line">		padding: 5px 10px;</span><br><span class="line">		margin: 5px;</span><br><span class="line">		cursor: pointer;</span><br><span class="line">	&#125;</span><br><span class="line">	.flex-container &#123;</span><br><span class="line">		display: flex;</span><br><span class="line">		justify-content: center;</span><br><span class="line">		flex-direction: column;</span><br><span class="line">		align-items: center;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



##  动态组件的性能优化

因为在性能上,comId直接代理组件,会导致代理不少的组件信息,造成**信息赘余**,使用下述方式就可以浅层代理了

信息赘余

![image-20230522165739553](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522165739553.png)

1.   使用`markRaw`

![image-20230522165413235](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522165413235.png)

这样的话这个属性就会多一个__skip__然后到了proxy就会跳过它.

2.   使用shallowRef,浅层代理

![image-20230522165537959](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522165537959.png)

![image-20230522170055690](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230522170055690.png)

这时候走的就是普通的对象了,而不是全部走proxy代理

## 手写一个toggle切换按钮,

基本上配合网页调试工具就做起来很爽!!!

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;label</span><br><span class="line">			for=&quot;lhg-check&quot;</span><br><span class="line">			class=&quot;switch&quot;&gt;</span><br><span class="line">			&lt;input</span><br><span class="line">				type=&quot;checkbox&quot;</span><br><span class="line">				id=&quot;lhg-check&quot;</span><br><span class="line">				name=&quot;lhg-check&quot;</span><br><span class="line">				class=&quot;input__check&quot; /&gt;</span><br><span class="line">			&lt;span class=&quot;slider&quot;&gt;&lt;/span&gt;</span><br><span class="line">		&lt;/label&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref, reactive, watch, computed &#125; from &quot;vue&quot;;</span><br><span class="line">	import &#123; useRoute, useRouter &#125; from &quot;vue-router&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;</span><br><span class="line">	$slider-width: 1.4rem;</span><br><span class="line">	$slider-height: 1.4rem;</span><br><span class="line">	$slider-Move: 1.5rem;</span><br><span class="line">	.switch &#123;</span><br><span class="line">		font-size: 17px;</span><br><span class="line">		position: relative;</span><br><span class="line">		display: inline-block;</span><br><span class="line">		width: 3.5rem;</span><br><span class="line">		height: 2rem;</span><br><span class="line">		transform-style: preserve-3d;</span><br><span class="line">		//设置这个属性使得子元素不会粘在一起,而是逐级分开</span><br><span class="line">		//transform-style的默认值是flat.</span><br><span class="line">		perspective: 500px; //3d相关,使得整个容器具有3d效果,设置视角:500px</span><br><span class="line">		animation: toggle__animation 3s infinite;</span><br><span class="line">		input &#123;</span><br><span class="line">			//隐藏默认的html checkbox</span><br><span class="line">			opacity: 0;</span><br><span class="line">			width: 0;</span><br><span class="line">			height: 0;</span><br><span class="line">		&#125;</span><br><span class="line">		&amp;::before &#123;</span><br><span class="line">			content: &quot;&quot;;</span><br><span class="line">			position: absolute;</span><br><span class="line">			top: 0;</span><br><span class="line">			left: 0;</span><br><span class="line">			width: 100%;</span><br><span class="line">			height: 100%;</span><br><span class="line">			filter: blur(20px); //经典营造氛围感</span><br><span class="line">			z-index: -1; //基本上就是造了一个阴影</span><br><span class="line">			border-radius: 50px;</span><br><span class="line">			background-color: #d8ff99;</span><br><span class="line">			background-image: radial-gradient(</span><br><span class="line">					at 21% 46%,</span><br><span class="line">					hsla(183, 65%, 60%, 1) 0px,</span><br><span class="line">					transparent 50%</span><br><span class="line">				),</span><br><span class="line">				radial-gradient(at 23% 25%, hsla(359, 74%, 70%, 1) 0px, transparent 50%),</span><br><span class="line">				radial-gradient(at 20% 1%, hsla(267, 83%, 75%, 1) 0px, transparent 50%),</span><br><span class="line">				radial-gradient(at 86% 87%, hsla(204, 69%, 68%, 1) 0px, transparent 50%),</span><br><span class="line">				radial-gradient(at 99% 41%, hsla(171, 72%, 77%, 1) 0px, transparent 50%),</span><br><span class="line">				radial-gradient(at 55% 24%, hsla(138, 60%, 62%, 1) 0px, transparent 50%);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	.slider &#123;</span><br><span class="line">		position: absolute;</span><br><span class="line">		cursor: pointer;</span><br><span class="line">		top: 0;</span><br><span class="line">		left: 0;</span><br><span class="line">		bottom: 0;</span><br><span class="line">		right: 0; //基本上就是放到父元素的位置上,也就是switch的原位置</span><br><span class="line">		background-color: #fdfefedc;</span><br><span class="line">		transition: 0.4s;</span><br><span class="line">		border-radius: 30px; //创建一个容器</span><br><span class="line">		&amp;::before &#123;</span><br><span class="line">			position: absolute;</span><br><span class="line">			content: &quot;&quot;;</span><br><span class="line">			height: $slider-height;</span><br><span class="line">			width: $slider-width;</span><br><span class="line">			left: 0.3em;</span><br><span class="line">			bottom: 0.35em;</span><br><span class="line">			transition: 0.4s;</span><br><span class="line">			border-radius: 50%; //经典创建一个圆的点</span><br><span class="line">			background-color: #ff99fd;</span><br><span class="line">			box-shadow: rgba(0, 0, 0, 0.17) 0px -10px 10px 0px inset,</span><br><span class="line">				rgba(0, 0, 0, 0.09) 0px -1px 15px -8px;</span><br><span class="line">			background-image: radial-gradient(</span><br><span class="line">					at 81% 39%,</span><br><span class="line">					hsla(327, 79%, 79%, 1) 0px,</span><br><span class="line">					transparent 50%</span><br><span class="line">				),</span><br><span class="line">				radial-gradient(at 11% 72%, hsla(264, 64%, 79%, 1) 0px, transparent 50%),</span><br><span class="line">				radial-gradient(at 23% 20%, hsla(75, 98%, 71%, 1) 0px, transparent 50%);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	.input__check:checked + .slider &#123;</span><br><span class="line">		background-color: #17202a; //切换背景颜色为黑色</span><br><span class="line">	&#125;</span><br><span class="line">	.input__check:checked + .slider::before &#123;</span><br><span class="line">		transform: translateX(</span><br><span class="line">			$slider-Move</span><br><span class="line">		); //在这个checkbox被检查的时候,选中这个小球,然后让他滑动,调参数即可</span><br><span class="line">	&#125;</span><br><span class="line">	@keyframes toggle__animation &#123;</span><br><span class="line">		0%,</span><br><span class="line">		100% &#123;</span><br><span class="line">			transform: translateY(-10px) rotateX(15deg) rotateY(-20deg);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		50% &#123;</span><br><span class="line">			transform: translateY(0px) rotateX(15deg) rotateY(-20deg);</span><br><span class="line">		&#125;//其实只是让它上下滑动而已</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

## 计算属性

当computed(()=>{})这个**回调函数内依赖的值发生变化**后,计算属性**自动更新**,**readonly**,同时当**依赖的值没更新,还会带有缓存**,不会重复调用,节省内存

![image-20230524000955055](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230524000955055.png)

在函数式写法中,这个计算属性是只读属性:`readonly`,不能二次修改,

而选项式是你完全自定义

1.   get(){}读取值的操作
2.   set(){}设置值的操作
3.   在其他地方修改会有一个参数去得到修改的值:newVal

## 获取子组件实例

#### 和获取dom元素是一样的

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> editRef=<span class="title function_">ref</span>(<span class="literal">null</span>);<span class="comment">//获取子组件的实例</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Edit</span> <span class="attr">ref</span>=<span class="string">&quot;editRef&quot;</span> @<span class="attr">on-updated</span>=<span class="string">&quot;getList()&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

-   子组件实例默认是封闭的,所以需要**defineExpose**去抛出想要暴露的方法和属性,
-   暴露的方法和属性才能在父组件里面去使用
-   ![image-20230603141159469](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230603141159469.png)
-   然后在父组件中获取到子组件的实例,
-   ![image-20230603141214599](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230603141214599.png)
-   通过调用函数,修改子组件的属性.
-   `const onEdit=(row)=>{
      editRef.value.open(row);
    }`
-   此处的row还能够用到open里面
-   ![image-20230603141103081](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230603141103081.png)
-   在open里面就能够使用定义的row![image-20230603141125186](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230603141125186.png)进行接收了
-   

-   父组件调用子组件的函数,照样能够像emit进行传值.
-   ![image-20230603141257803](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230603141257803.png)
-   ![image-20230603141313661](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230603141313661.png)

## vue3响应式原理

![image-20230603172344010](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230603172344010.png)

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faf059ee41664a69a4fcd89f471c20f8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

## Transition动画组件

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h1&gt;我是练习transition的页面&lt;/h1&gt;</span><br><span class="line">	&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">		&lt;button @click=&quot;flag = !flag&quot;&gt;Switch&lt;/button&gt;</span><br><span class="line">		&lt;Transition name=&quot;fade&quot;&gt;</span><br><span class="line">			&lt;div</span><br><span class="line">				v-if=&quot;flag&quot;</span><br><span class="line">				class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">		&lt;/Transition&gt;</span><br><span class="line">		&lt;div&gt;</span><br><span class="line">			&lt;button @click=&quot;show = !show&quot;&gt;Toggle&lt;/button&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;Transition</span><br><span class="line">			name=&quot;custom-classes&quot;</span><br><span class="line">			enter-active-class=&quot;animate__animated animate__slideInRight&quot;&gt;</span><br><span class="line">			&lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">		&lt;/Transition&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">	import &#123; RouterLink, RouterView &#125; from &quot;vue-router&quot;;</span><br><span class="line">	import &#123; reactive, ref, watch &#125; from &quot;vue&quot;;</span><br><span class="line">	const flag = ref&lt;boolean&gt;(false);</span><br><span class="line">	const show = ref&lt;boolean&gt;(true);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">	.box &#123;</span><br><span class="line">		width: 200px;</span><br><span class="line">		height: 200px;</span><br><span class="line">		background-color: red;</span><br><span class="line">	&#125;</span><br><span class="line">	.fade-enter-from &#123;</span><br><span class="line">		width: 0px;</span><br><span class="line">		height: 0px;</span><br><span class="line">	&#125;</span><br><span class="line">	.fade-enter-active &#123;</span><br><span class="line">		transition: all 1.5s ease;</span><br><span class="line">	&#125;</span><br><span class="line">	.fade-enter-to &#123;</span><br><span class="line">		width: 200px;</span><br><span class="line">		height: 200px;</span><br><span class="line">		background: blue;</span><br><span class="line">	&#125;</span><br><span class="line">	.fade-leave-active &#123;</span><br><span class="line">		transition: all 3s ease;</span><br><span class="line">	&#125;</span><br><span class="line">	.fade-leave-from &#123;</span><br><span class="line">		background-color: bisque;</span><br><span class="line">	&#125;</span><br><span class="line">	.fade-leave-to &#123;</span><br><span class="line">		transform: rotate(360deg);</span><br><span class="line">		scale: 0;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

### 主要内容



![image-20230626204402645](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626204402645.png)

**上述样式是隐藏到显示的效果**

from就是开始的那一个动画帧

to就是结束的那一个动画帧

![image-20230626204459835](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626204459835.png)

结束的`to`基本样式和原来的`保持一致`即可

然后enter的`active`,也就是**进入的时候整个过程的一个状态**,_通常设置过渡效果_

**下列样式是显示到隐藏的效果**

![image-20230626204630421](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626204630421.png)

### 自定义类名

![image-20230626210918628](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626210918628.png)

也就是直接在组件的属性上设置对应的类名

类名对应的样式在style下写

#### 使用animate.css

![image-20230626211654646](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626211654646.png)

直接`pnpm i animate.css -S`

然后使用就直接引入就行了`import "animate.css"`

在上面的自定义类名中就可以使用了

#### 自定义持续时间

![image-20230626213358102](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626213358102.png)

可以单独定义持续时间

![image-20230626213424834](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626213424834.png)

也可以直接定义全部的持续时间

### 生命周期函数

![image-20230626214306443](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626214306443.png)

反映在组件身上就是**监听相应的事件**,然后`执行相应的处理函数`

![image-20230626214445180](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626214445180.png)

接收几个参数,在enter:`对应enter-active这个class`中接收`el这个HTML元素和done`

表示动画执行完成

然后就可以得到`enterTO`这个函数的执行结果了

#### 当然还有leave

![image-20230626214808815](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626214808815.png)

上面的`before-leave和leave:对应离开的过渡曲线`

![image-20230626214746288](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626214746288.png)

执行结果

![image-20230626214950403](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626214950403.png)

这个`done`参数是个**函数**,基本就是*人为设置*动画的结束事件,当结束函数:`done`执行以后,才会触发

`after-leave这个函数`

### 小DEMO

![image-20230626215157647](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626215157647.png)

基本常用的函数

#### 使用gasp完成

![image-20230626215414059](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626215414059.png)

基本使用如图,**set就是初始化状态**,参数:`HTMLElement`

这个onComplete函数就是结束的回调,直接指定为done即可.

![image-20230626215529454](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626215529454.png)

离开的时候执行函数

### appear

页面加载就执行动画![image-20230626215701874](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626215701874.png)

![image-20230626215731174](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626215731174.png)

中间active就是整个初始动画的过程,加载**过渡使用**.

![image-20230626215751940](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626215751940.png)

### transition-group过渡列表

![image-20230626220022110](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626220022110.png)

使用**transition-group**一定要给列表渲染:`v-for`这个元素+key,不然报错

![image-20230626220144624](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626220144624.png)

这是列表的**父元素**样式

![image-20230626221554180](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626221554180.png)

必须在列表元素有更改的时候才能应用过渡效果

![image-20230626221628019](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626221628019.png)

![image-20230626222023672](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626222023672.png)

数组的方法

### 酷炫动画

实现网格过渡平面效果

![image-20230626223712649](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626223712649.png)

`生成每九个为一组的数据格式`.

![image-20230626224137380](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626224137380.png)

使用下面**方式生成数组.可以初始化一些数据**

完整生成数据的代码

![image-20230626224404675](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626224404675.png)

使用如下样式

![image-20230626224520066](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626224520066.png)

此处`使用calc计算宽度,然后得到匹配的九宫格`

使用lodash库内部函数shuffle打乱数组元素

![image-20230626224810901](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626224810901.png)

安装类型声明文件![image-20230626224830499](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626224830499.png)

添加`move-class`即可让元素在群体移动的时候改变样式.![image-20230626224943732](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626224943732.png)

#### 不知道为啥在vue开发环境老是抽风

#### 无奈到vue的单页面PlayGround去看代码是否能运行

代码如下

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;button @click=&quot;random&quot;&gt;Random&lt;/button&gt;</span><br><span class="line">		&lt;transition-group</span><br><span class="line">			tag=&quot;div&quot;</span><br><span class="line">			class=&quot;wraps&quot;</span><br><span class="line">			move-class=&quot;move&quot;&gt;</span><br><span class="line">			&lt;div</span><br><span class="line">				class=&quot;items&quot;</span><br><span class="line">				:key=&quot;item.id&quot;</span><br><span class="line">				v-for=&quot;item in list&quot;&gt;</span><br><span class="line">				&#123;&#123; item.number &#125;&#125;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/transition-group&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">	import &#123; reactive, ref, watch &#125; from &quot;vue&quot;;</span><br><span class="line">  import &quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;//引入loadsh这个库</span><br><span class="line">    //暴露出全局对象 _</span><br><span class="line">	let list = ref(</span><br><span class="line">		Array.apply(null, &#123; length: 81 &#125; as number[]).map((_, index) =&gt; &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				id: index,</span><br><span class="line">				number: (index % 9) + 1, //生成1-9的随机数</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;)</span><br><span class="line">	); //生成1-9的随机数,基本就是二维数组</span><br><span class="line">	const random = () =&gt; &#123;</span><br><span class="line">		list.value = _.shuffle(list.value);</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">	.wraps &#123;</span><br><span class="line">		width: calc(10 * 25px + 9px);</span><br><span class="line">		display: flex;</span><br><span class="line">		flex-wrap: wrap;</span><br><span class="line">	&#125;</span><br><span class="line">	.items &#123;</span><br><span class="line">		width: 25px;</span><br><span class="line">		height: 25px;</span><br><span class="line">		border: 1px solid #464040;</span><br><span class="line">		text-align: center;</span><br><span class="line">		line-height: 25px;</span><br><span class="line">	&#125;</span><br><span class="line">	.move &#123;</span><br><span class="line">		transition: all 1.5s;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

**如图所示**

![image-20230627144919069](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230627144919069.png)



## 状态机实现减业务逻辑

![image-20230626173531581](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626173531581.png)

`业务方`提出**业务需求**

`产品经理`综合**业务需求**,把PRD:`ProductRequirement Document`,也就是*产品需求文档*发给设计师

让设计师交给评审,评审完成以后,前后端就可以联调开发了

UAT:`用户验收测试`也就是**User Acceptance Test**

状态机就是用来解决基于行为的复杂状态维护问题的

### 状态模式

![image-20230626190141492](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626190141492.png)

### 状态机基本组成

![image-20230626190320367](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626190320367.png)

我们平时使用的`fetchAPI就是一组有限状态机`

![image-20230626190446748](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230626190446748.png)

最终状态**fulfilled**,和**rejected**

初始状态`IDle`

中间状态:`Pending`

这些都是由事件驱动转换的

# pinia

## 持久化存储

就是把东西存到本地存储里面

本来刷新页面就会丢失pinia的数据

## 存在的api

### $patch

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">change</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  store.$patch(<span class="function"><span class="params">state</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(state);</span><br><span class="line">    <span class="comment">//只会存在不是计算属性和方法的东西</span></span><br><span class="line">    <span class="comment">//也就是只放响应式数据</span></span><br><span class="line">    state.<span class="property">count</span>+=<span class="number">10</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

批量修改store里面的数据,但是最好还是使用store里面提供的方法,想象成一个类.

# 可视化页面

![image-20230526130257403](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230526130257403.png)

一种偷数据的方式,直接在别的网站上点击f12看网络选项,查找请求的数据和url,然后看下有没有保护,就可以去使用别人的接口了

![image-20230526134338144](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230526134338144.png)

#### 通过媒体查询:prefers-color-scheme这个属性去查找系统的偏选

### Echarts

#### dataSets:数据集合

1.   数据设置在数据集合中,好处
2.   贴近数据可视化的思维方式,提供数据->指定数据到图的映射->图表
3.   只用改变数据,不用瞎找
4.   数据集合可以复用
5.   支持数据的常用格式,二维数组,对象数组

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">			id=&quot;main&quot;</span><br><span class="line">			style=&quot;width: 300px; height: 300px&quot;&gt;&lt;/div&gt;</span><br><span class="line">		&lt;div</span><br><span class="line">			id=&quot;scatter&quot;</span><br><span class="line">			style=&quot;height: 300px; width: 600px&quot;&gt;&lt;/div&gt;</span><br><span class="line">		&lt;!-- 作为存放echars的容器,其实就是canvas --&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			</span><br><span class="line">			let mychart = echarts.init(document.querySelector(&quot;#main&quot;));</span><br><span class="line">			let mychart2 = echarts.init(document.querySelector(&quot;#scatter&quot;));</span><br><span class="line"></span><br><span class="line">			let option3 = &#123;</span><br><span class="line">				xAxis: &#123;//x轴</span><br><span class="line">					type: &quot;category&quot;,</span><br><span class="line">                    // &#x27;category&#x27; 类目轴，适用于离散的类目数据。</span><br><span class="line">                    // 为该类型时类目数据可自动从 series.data 或 dataset.source 中取，</span><br><span class="line">                    // 或者可通过 xAxis.data 设置类目数据。</span><br><span class="line">					data: [&quot;Matcha Latte&quot;, &quot;Milk Tea&quot;, &quot;Cheese Cocoa&quot;, &quot;Walnut Brownie&quot;],</span><br><span class="line">				&#125;,</span><br><span class="line">				yAxis: &#123;&#125;,//y轴</span><br><span class="line">				tooltip: &#123;&#125;, //空对象指的是自动配置相关项,tooltip指提示框</span><br><span class="line">				series: [//系列配置的是图表的主要显示内容</span><br><span class="line">					&#123;</span><br><span class="line">						type: &quot;bar&quot;,//柱状图</span><br><span class="line">						name: &quot;2015&quot;,</span><br><span class="line">						data: [89.3, 92.1, 94.4, 85.4],</span><br><span class="line">					&#125;,</span><br><span class="line">					&#123;</span><br><span class="line">						type: &quot;bar&quot;,</span><br><span class="line">						name: &quot;2016&quot;,</span><br><span class="line">						data: [95.8, 89.4, 91.2, 76.9],</span><br><span class="line">					&#125;,</span><br><span class="line">					&#123;</span><br><span class="line">						type: &quot;bar&quot;,</span><br><span class="line">						name: &quot;2017&quot;,</span><br><span class="line">						data: [97.7, 83.1, 92.5, 78.1],</span><br><span class="line">					&#125;,//设置series这个系列为数组,则每个数组里的对象,都可以单独配置</span><br><span class="line">                    //itemStyle还有lable还有emphasis</span><br><span class="line">				],</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			let option2 = &#123;</span><br><span class="line">				xAxis: &#123;</span><br><span class="line">					type: &quot;category&quot;,//这个表示就是显示以下的data,category:分类的意思</span><br><span class="line">					data: [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;],</span><br><span class="line">				&#125;,</span><br><span class="line">				yAxis: &#123;</span><br><span class="line">					type: &quot;value&quot;,</span><br><span class="line">				&#125;,</span><br><span class="line">				series: &#123;</span><br><span class="line">					type: &quot;scatter&quot;,</span><br><span class="line"></span><br><span class="line">					// 普通样式。</span><br><span class="line">					itemStyle: &#123;//每个项目的颜色</span><br><span class="line">						// 点的颜色。</span><br><span class="line">						color: &quot;red&quot;,</span><br><span class="line">					&#125;,</span><br><span class="line">					label: &#123;</span><br><span class="line">						show: true,</span><br><span class="line">						// 标签的文字。</span><br><span class="line">						formatter: &quot;This is a normal label.&quot;,</span><br><span class="line">					&#125;,</span><br><span class="line"></span><br><span class="line">					// 高亮样式。</span><br><span class="line">					emphasis: &#123;</span><br><span class="line">						itemStyle: &#123;</span><br><span class="line">							// 高亮时点的颜色。</span><br><span class="line">							color: &quot;blue&quot;,</span><br><span class="line">						&#125;,</span><br><span class="line">						label: &#123;</span><br><span class="line">							show: true,</span><br><span class="line">							// 高亮时标签的文字。</span><br><span class="line">							formatter: &quot;This is a emphasis label.&quot;,</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;;</span><br><span class="line">			let option = &#123;</span><br><span class="line">				backgroundColor: &#123;</span><br><span class="line">					type: &quot;linear&quot;,</span><br><span class="line">					x: 0.3,</span><br><span class="line">					y: 0.3,</span><br><span class="line">					r: 0.8,</span><br><span class="line">					colorStops: [</span><br><span class="line">						&#123;</span><br><span class="line">							offset: 0,</span><br><span class="line">							color: &quot;#f7f8fa&quot;,</span><br><span class="line">						&#125;,</span><br><span class="line">						&#123;</span><br><span class="line">							offset: 1,</span><br><span class="line">							color: &quot;#cdd0d5&quot;,</span><br><span class="line">						&#125;,</span><br><span class="line">					],</span><br><span class="line">				&#125;,</span><br><span class="line">				title: &#123;</span><br><span class="line">					//修改左上角的标题</span><br><span class="line">					text: &quot;入门示例&quot;,</span><br><span class="line">				&#125;,</span><br><span class="line">				tooltip: &#123;</span><br><span class="line">					//修改提示框</span><br><span class="line">					// backgroundColor: &quot;red&quot;,</span><br><span class="line">					trigger: &quot;axis&quot;,</span><br><span class="line">				&#125;,</span><br><span class="line">				legend: &#123;</span><br><span class="line">					data: [&quot;销量&quot;, &quot;更多销量&quot;, &quot;公安部队撒旦&quot;],</span><br><span class="line">				&#125;,</span><br><span class="line">				xAxis: &#123;</span><br><span class="line">					data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;],</span><br><span class="line">				&#125;,</span><br><span class="line">				yAxis: &#123;&#125;, //不设置y轴,y轴将会根据数据:data自动设置自己</span><br><span class="line">				series: [</span><br><span class="line">					&#123;</span><br><span class="line">						name: &quot;销量如何?&quot;,</span><br><span class="line">						type: &quot;bar&quot;,</span><br><span class="line">						//scatter点图</span><br><span class="line">						//bar是柱图</span><br><span class="line">						data: [5, 20, 136, 10, 10, 20],</span><br><span class="line">						itemStyle: &#123;</span><br><span class="line">							shadowBlur: 10, //阴影模糊</span><br><span class="line">							shadowColor: &quot;rgba(120, 36, 50, 0.5)&quot;,</span><br><span class="line">							shadowOffsetY: 5,</span><br><span class="line">							color: &quot;red&quot;,</span><br><span class="line">						&#125;,</span><br><span class="line">						label: &#123;</span><br><span class="line">							show: false,</span><br><span class="line">							// 标签的文字。</span><br><span class="line"></span><br><span class="line">							color: &quot;white&quot;,</span><br><span class="line">						&#125;,</span><br><span class="line">						emphasis: &#123;</span><br><span class="line">							itemStyle: &#123;</span><br><span class="line">								color: &quot;blue&quot;,</span><br><span class="line">							&#125;,</span><br><span class="line">							label: &#123;</span><br><span class="line">								show: true,</span><br><span class="line">								formatter: &quot;测试标签&quot;,</span><br><span class="line">							&#125;,</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;,</span><br><span class="line">				],</span><br><span class="line">			&#125;;</span><br><span class="line">			//使用指定的配置项和数据显示图表</span><br><span class="line">			mychart.setOption(option);</span><br><span class="line">			mychart2.setOption(option3);</span><br><span class="line">		&lt;/script&gt;</span><br></pre></td></tr></table></figure>

# Electron

使用Electron开发桌面级应用,首先就是它会创建chrome内核和nodejs内核,前者用来解析html,后者用来解析js代码.这也导致了他的开发极其耗费内存.

js的传统约定:

以帕斯卡命名法 (PascalCase) 命名可实例化的类 (如 BrowserWindow, Tray 和 Notification)，

以驼峰命名法 (camelCase) 命名不可实例化的函数、变量等 (如 app, ipcRenderer, webContents) 。

## 摘要

Electron 是通过 npm 包安装的。 您应将 Electron 依赖安装到 `devDependencies` ，然后在 package.json 中设置一个strat脚本`"start": "electron .",`来运行。

执行命令后，Electron 程序会运行您在 package.json 文件的 `main` 字段设置的入口文件*"main": "index.js",*。 这个入口文件控制着 Electron 的**Main Process**，这个主进程，负责应用的lifecycle、展示Window、执行特殊操作和管理渲染进程。

这个主进程:Main Process是**app**这个东西管理的.从electron直接`解构出来`

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from Electron 👋&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;electron&quot;</span>);</span><br><span class="line"><span class="comment">//将可复用的函数写入实例化窗口</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createWindow</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> win = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">		<span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">		<span class="attr">height</span>: <span class="number">600</span>,</span><br><span class="line">	&#125;); <span class="comment">//新的 BrowserWindow 实例</span></span><br><span class="line"></span><br><span class="line">	win.<span class="title function_">loadFile</span>(<span class="string">&quot;index.html&quot;</span>); <span class="comment">//将您的页面加载到新的 BrowserWindow 实例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">whenReady</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//在应用准备就绪时调用函数</span></span><br><span class="line">	<span class="comment">//BrowserWindows只能在app的ready事件触发后调用</span></span><br><span class="line">	<span class="title function_">createWindow</span>();</span><br><span class="line">	app.<span class="title function_">on</span>(<span class="string">&quot;activate&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="title class_">BrowserWindow</span>.<span class="title function_">getAllWindows</span>().<span class="property">length</span> === <span class="number">0</span>) <span class="title function_">createWindow</span>();</span><br><span class="line">	&#125;); <span class="comment">//在macOS上面,如果没有窗口打开,则创建一个新窗口</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//或者使用下列方法</span></span><br><span class="line"><span class="comment">// app.on(&quot;ready&quot;, () =&gt; &#123;</span></span><br><span class="line"><span class="comment">// 	createWindow();</span></span><br><span class="line"><span class="comment">// &#125;);//但是上述whenReady是ready事件的专用监听器</span></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&quot;window-all-closed&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (process.<span class="property">platform</span> !== <span class="string">&quot;darwin&quot;</span>) app.<span class="title function_">quit</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

渲染进程:Render是`BrowserWindow`:浏览器窗口这个东西.用来展示Html文件或者是外部的web地址

**Render进程**(简称渲染器) 负责展示图形内容。 您可以将渲染的网页指向 web 地址或本地 HTML 文件。 渲染器和常规的网页行为很相似，访问的 web API 也相同。

在教程下一节，我们将会学习如何使用 API 给渲染器提权，以及如何在进程间通信。

# NestJs

后端服务器的一个基于JavaScript的框架

## 依赖注入

依赖注入:DL:Dependency Injection

就是控制反转:Inversion of Control:IOC

定义:**是高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。**

主要是为了解决class和object直接强**耦合**:`就是父亲改代码了,子孙全部都得改代码`的问题

看这个例子

开始的代码:

![image-20230530160909738](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230530160909738.png)

此时a在使用class A的name,但是要是**改了A类的代码**,将`name`改成传进来的方式

则:

![image-20230530161026679](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230530161026679.png)

B和C的代码全部都得改.

为了改变这种强耦合的方式,发明了依赖注入和控制反转

我们可以看到，**B** 中代码的实现是需要依赖 **A** 的，**两者的代码耦合度非常高。当两者之间的业务逻辑复杂程度增加的情况下，维护成本与代码可读性都会随着增加，并且很难再多引入额外的模块进行功能拓展**。

为了解决这个问题可以使用一个容器:container

### 依赖注入

创建一个容器去收集依赖:`provide`

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">	<span class="attr">module</span>: <span class="built_in">any</span>; <span class="comment">//this.module,是这个类里面的module</span></span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">module</span> = &#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">provide</span>(<span class="params">key: <span class="built_in">string</span>, <span class="variable language_">module</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">module</span>[key] = <span class="variable language_">module</span>; <span class="comment">//此处的module是传入的module</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params">key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">module</span>[key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

**大概就是实现传入模块/组件,然后通过get方法从容器中取出东西**

完整版示例代码:

*其实就是写了一个中间件，来收集依赖，主要是为了解耦，减少维护成本*

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	&#125; <span class="comment">//初始化函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">	<span class="attr">module</span>: <span class="built_in">any</span>; <span class="comment">//this.module,是这个类里面的module</span></span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">module</span> = &#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">provide</span>(<span class="params">key: <span class="built_in">string</span>, <span class="variable language_">module</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">module</span>[key] = <span class="variable language_">module</span>; <span class="comment">//此处的module是传入的module</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">inject</span>(<span class="params">key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">module</span>[key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ModuleSum</span> = <span class="keyword">new</span> <span class="title class_">Container</span>();</span><br><span class="line"><span class="title class_">ModuleSum</span>.<span class="title function_">provide</span>(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> <span class="title function_">A</span>(<span class="string">&quot;李昊戈nb&quot;</span>));</span><br><span class="line"><span class="title class_">ModuleSum</span>.<span class="title function_">provide</span>(<span class="string">&quot;c&quot;</span>, <span class="keyword">new</span> <span class="title function_">C</span>(<span class="string">&quot;KfcV我50挑战&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="built_in">any</span>;</span><br><span class="line">	<span class="attr">c</span>: <span class="built_in">any</span>;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"><span class="variable language_">module</span>: Container</span>) &#123;</span><br><span class="line">		<span class="comment">//module的类型是Container</span></span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">a</span> = <span class="variable language_">module</span>.<span class="title function_">inject</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">c</span> = <span class="variable language_">module</span>.<span class="title function_">inject</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">		<span class="comment">//这种方式的话,相当于经过了一层容器的包装,是没有强耦合性的,B类和A,C类不再有依赖关系,只是注入.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lhg = <span class="keyword">new</span> <span class="title function_">B</span>(<span class="title class_">ModuleSum</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;lhg.a::: &quot;</span>, lhg.<span class="property">a</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;lhg.b::: &quot;</span>, lhg.<span class="property">c</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

![image-20230530163641002](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230530163641002.png)

## 装饰器:Decorator

### 装饰器是个函数!!!

其实**装饰器就是一个函数**,不过**@doc**的方式使他用起来特别方便罢了

装饰器是一种特殊的类型声明，他可以附加在类，方法，属性，参数上面

首先开启一项配置:

![img](https://img-blog.csdnimg.cn/95a018ec2abe4c20adeea449534d0ded.png)

装饰器可以用来`类`,`类的方法上`,`函数的参数上`,`还有函数上`

### 类装饰器 

主要是通过@符号添加装饰器
    他会自动把class的构造函数传入到装饰器的第一个参数 target

然后通过prototype可以自定义添加属性和方法

####  这东西是个函数,自己会自动执行,也就是说target, key,index这些参数只是让装饰器得到数据罢了,在装饰器内部处理逻辑

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decotators</span> (<span class="attr">target</span>:<span class="built_in">any</span>) &#123;</span><br><span class="line">    target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;小满&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@decotators</span></span><br><span class="line"><span class="comment">//上述方式等价于===</span></span><br><span class="line"><span class="title function_">decotators</span>(<span class="params">Xiaoman</span>)&#123;</span><br><span class="line">	<span class="title class_">Xiaoman</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;小满&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Xiaoman</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span> () &#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">xiaoman</span>:<span class="built_in">any</span> = <span class="keyword">new</span> <span class="title class_">Xiaoman</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xiaoman.<span class="property">name</span>)</span><br></pre></td></tr></table></figure>

### 属性装饰器

同样使用@符号给属性添加装饰器

他会返回两个参数

1.属性所在的对象

2.属性的名称

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">currency</span>: <span class="title class_">PropertyDecorator</span> = <span class="function">(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target, key)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Xiaoman</span> &#123;</span><br><span class="line">    <span class="meta">@currency</span></span><br><span class="line">    <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

####  这东西是个函数,自己会自动执行,也就是说target, key,index这些参数只是让装饰器得到数据罢了,在装饰器内部处理逻辑

运行结果:

![img](https://img-blog.csdnimg.cn/959aaf97cc6947aca0f251421bc1ea80.png)

### 参数装饰器

同样使用@符号给属性添加装饰器

他会返回两个参数

1.参数所在的对象

2.方法的名称

3.参数的位置从0开始

####  这东西是个函数,自己会自动执行,也就是说target, key,index这些参数只是让装饰器得到数据罢了,在装饰器内部处理逻辑

代码的执行还是在装饰器这个函数内部编写代码执行

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">currency</span>: <span class="title class_">ParameterDecorator</span> = <span class="function">(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,index:<span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target, key,index);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Xiaoman</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params">name:<span class="built_in">string</span>,<span class="meta">@currency</span> age:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

![img](https://img-blog.csdnimg.cn/3f11e88774bc4339993b1571a80da72a.png)

### 装饰器搭配Axios实现get请求获取数据

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Get</span> = (<span class="attr">url</span>: <span class="built_in">string</span>): <span class="function"><span class="params">MethodDecorator</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">target, key, descriptor: PropertyDescriptor</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> fnc = descriptor.<span class="property">value</span>;</span><br><span class="line">		axios</span><br><span class="line">			.<span class="title function_">get</span>(url)</span><br><span class="line">			.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="title function_">fnc</span>(res, &#123;</span><br><span class="line">					<span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;)</span><br><span class="line">			.<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="title function_">fnc</span>(e, &#123;</span><br><span class="line">					<span class="attr">status</span>: <span class="number">500</span>,</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义控制器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">	<span class="meta">@Get</span>(<span class="string">&quot;https://api.apiopen.top/api/getHaoKanVideo?page=0&amp;size=10&quot;</span>)</span><br><span class="line">	<span class="title function_">getList</span>(<span class="params">res: <span class="built_in">any</span>, status: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>.<span class="property">result</span>.<span class="property">list</span>, status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

# NodeJS

## 作为一名后端工程师

## 永远不要相信用户的输入



## 路由模块化

#### router对象

![image-20230605133501587](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605133501587.png)

这个router对象,相当于一个小型的app对象.

#### chatGpt

具体而言，当通过 `const router = express.Router()` 获得了一个 `Router` 对象之后，我们可以像这样定义和使用路由规则：

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理 GET / 请求的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理 POST / 请求的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将该路由对象作为中间件挂载到 /api 路径下</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, router);</span><br></pre></td></tr></table></figure>



上述代码中，我们通过 `router.get()` 和 `router.post()` 方法分别定义了针对 GET 和 POST 请求的路由规则，

然后将该 `Router` 对象通过 `app.use()` 方法挂载到了 `/api` 路径下。这意味着，当请求的路径以 `/api` 开头时，Express 会优先匹配这个 `Router` 对象中定义的路由规则，并执行相关的处理逻辑。

通过使用 `Router` 可以将路由规则模块化并分组，能够使代码更加清晰、结构更加合理，便于维护和管理。

使用中间件:`router.use()即可`

![image-20230605133646838](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605133646838.png)

导出这些东西,`router.get`创建路由就相当于给router对象上增加了一些规则.

然后`module.exports=router`;

在主页面就和使用全局中间件一样去`app.use`即可

![image-20230605133822573](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605133822573.png)

#### 总体代码:

![image-20230605133928909](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605133928909.png)

## express中间件

*“Middleware” 是由 “middle”（中间的）和 “ware”（软件）两个词组合而成，字面意思是 “中间的软件”。*

**本质是一个回调函数**.

可以访问`请求对象(request)`和`响应对象response`以及`应用程序请求-响应循环中的下一个中间件函数（next）`

使用MiddleWare就是使用函数去封装一些公开的操作.

**全局中间件就像火车里的进站口,每人来都得过一遍**

**路由中间件就像检票口,分门别类的过**

![image-20230604145035587](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604145035587.png)

#### chatGpt

中间件（Middleware）是指在应用程序中介于客户端和服务器之间的处理过程,中间件可以在请求到达服务器之前，或请求到达服务器并获取响应后**执行一些操作**。

-   在 Express 中，中间件指的是处理 HTTP 请求的函数。

-   中间件函数可以访问请求对象（req）、响应对象（res）以及应用程序请求-响应循环中的下一个中间件函数（next）。

-   中间件函数的作用是在应用程序中执行一些通用的任务，例如解析请求体、验证请求参数、设置响应头、处理错误等。

1.   需要注意的是，中间件函数的调用顺序非常重要。

2.   对于一个请求，会按照添加中间件函数的先后顺序依次调用这些函数，直到最后一个中间件函数将响应发送给客户端或者调用 next 方法将控制权交给下一个中间件函数。

3.   在使用中间件函数时需要考虑它们的顺序，以便得到期望的结果。



### 全局Middleware

**本质是一个回调函数**.

可以访问`请求对象(request)`和`响应对象response`以及`应用程序请求-响应循环中的下一个中间件函数（next）`

需求:对所有来自客户端的请求,记录ip地址和url.

使用`全局中间件`

当访问/home的时候

从请求对象(request)取出来url和ip,保存在文件access.log中

文件access.log内容如图

![image-20230604145547580](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604145547580.png)

![image-20230604145456062](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604145456062.png)

全局MiddleWare函数

![image-20230604145834200](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604145834200.png)

在调用next()方法以后,才会继续执行下面的路由回调

不执行next()方法,就会造成操作停止,代码不往下执行.

![image-20230604145918571](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604145918571.png)

### 路由Middleware

#### 需求![image-20230604150238293](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604150238293.png)

![image-20230604150554789](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604150554789.png)

在query中给code=521

如果暗号正确,直接next(),正常执行路由里面给的函数

使用就是把Middleware函数直接放到![image-20230604150744422](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604150744422.png)第二个参数里面,**放到路由路径的后面,就可以应用了**

prarm是url后面没有?,而是直接跟数据.

*路由MiddleWare*主要应用就是看用户的身份权限和密码之类的验证.

### 静态资源Middleware

**静态资源**`内容长时间不发生改变的资源`.

网站根目录->静态资源目录->public

#### 大概架构如图

![image-20230604151842510](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604151842510.png)

express.static()这个方法的返回结果是个函数(middleware函数),

![image-20230604152024059](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604152024059.png)

参数是*静态资源目录*的路径.

在上面的代码中，`express.static` 中间件被用来将 `public` 文件夹中的静态文件发送给客户端。你需要将 `index.html` 文件放在 `public` 目录下，然后访问 `http://localhost:3000/index.html` 即可通过 `Express` 发送静态文件。

![image-20230604152156370](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604152156370.png)

会自动加上文件类型和字符集

![image-20230604152437149](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604152437149.png)

如果你不想将这些文件直接放在根目录下的 `/public` 目录下，你可以在使用静态文件中间件时指定相对路径，例如：

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将 public 目录下的静态文件发送给客户端</span><br><span class="line">app.use(&#x27;/static&#x27;, express.static(&#x27;public&#x27;));</span><br></pre></td></tr></table></figure>



在这种情况下，你需要将 `index.html` 文件放在 `public` 目录下，并访问 `http://localhost:3000/static/index.html` 来通过 `Express` 发送静态文件。

#### 一些注意事项

**静态资源**`内容长时间不发生改变的资源`.

![image-20230604152835742](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604152835742.png)

1.   第一点也就是直接访问http://localhost:3000,则会寻找index.html然后打开
2.   第二点是看路由规则和静态资源的定义,看代码,这时路由写在上面就先匹配路由,静态public写在下面就不会响应了
3.   ![image-20230604152948284](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604152948284.png)
4.   动态资源:- 排行榜 - 搜索结果 - 最新的新闻
5.   静态资源:- css, - 图片, - 视频.

#### 小练习

使用express和MiddleWare去访问局域网的网站资源

![image-20230604153626444](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604153626444.png)

![image-20230604153504903](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604153504903.png)

查看ipconfig然后输入ipv4地址加上端口号,就可以访问暴露出的网站了

其实还是先发送请求给服务器要index.html

发现有相关的依赖:css,js.于是继续发送请求获取这些依赖,当然还要图片那些东西

![image-20230604153753389](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604153753389.png)

## 获取请求体数据

#### 需求

![image-20230604153949730](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604153949730.png)

基本代码

![image-20230604154230343](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604154230343.png)

用到了res:响应对象的方法`sendFile(__dirname+'index.html')`

sendFile字面意思,发送文件!!!

这就是点击登录,浏览器监听到的网络请求

![image-20230604154550024](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604154550024.png)

获取表单中的用户名和密码

![image-20230604154828367](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604154828367.png)

使用body-parser

然后使用上面的函数当作路由中间件

![image-20230604154942117](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604154942117.png)

当urlEncodedParser这个函数执行完毕后,会往request这个请求对象上附加一个属性:

body,得到转换后的结果

![image-20230604155101371](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604155101371.png)

![image-20230604155052716](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604155052716.png)

object null prototype 表明该对象的原型是指向null的 

body:object里的key:键名和表单的name属性对应

![image-20230604155232096](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604155232096.png)

## 防盗链

图片直接复制地址出问题,放到img标签无法显示

![image-20230604161457187](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604161457187.png)

简单来说就是图片所存放的服务器只允许jj20.com这个域名的网址访问图片资源,

看到咋们的域名不一样,就不让访问,也就是请求失败了![image-20230604161609411](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604161609411.png)

防盗~防盗嘛

### 防盗链原理

#### 看请求头的Referer:(来源)

失败的referer

![image-20230604161752922](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604161752922.png) 

成功的referer

![image-20230604161818955](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604161818955.png)

代码,**原理就是监测Referer:(来源)的相同和不同**

![image-20230604165251446](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604165251446.png)

因为127.0.0.1和localhost不同,则可以监测他们的referer

![image-20230604165421562](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604165421562.png)

使用URL对象提取他们的hostName.

![image-20230604165557963](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604165557963.png)

![image-20230604165609568](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604165609568.png)

自己写的代码:

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">FangDaoLian</span> = (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> referer = req.<span class="title function_">get</span>(<span class="string">&quot;referer&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (referer) &#123;</span><br><span class="line">		<span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(referer);</span><br><span class="line">		<span class="keyword">let</span> &#123; hostname &#125; = url;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hostname::: &quot;</span>, hostname);</span><br><span class="line">		<span class="keyword">if</span> (hostname !== <span class="string">&quot;127.0.0.1&quot;</span>) &#123;</span><br><span class="line">			res.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">send</span>(<span class="string">&quot;&lt;h1&gt;404 Not found&lt;/h1&gt;&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当你设置了防盗链的时候,浏览器还能访问index.html的文本资源,但是</span></span><br><span class="line">		<span class="comment">//style.css,还要项目相关的js文件都无法访问</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">next</span>();</span><br><span class="line">&#125;;</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">FangDaoLian</span>);</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&quot;public&quot;</span>));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3100</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务启动在http://127.0.0.1:3100/&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





chatGpt:

请求头中的 `Referer`（或者是 `Referrer`，两个词的拼写都是正确的）字段表示了请求的**来源**（Referrer），也可以理解为是前一个页面的 URL。

当浏览器向服务器发送请求时，**会自动在请求头中添加 `Referer` 字段，告诉服务器这个请求的来源。**

在 Web 开发中，可以使用 `Referer` 字段来进行防盗链或者是统计分析等操作。

例如，某个网站可以通过检查 `Referer` 字段来判断访问者是否从合法的来源（比如该网站的页面）访问该网站资源（比如图片、视频等）。

如果发现 `Referer` 字段为空，或者来源不合法，则可以拒绝该请求，避免资源的盗用或者滥用。

需要注意的是，由于 `Referer` 字段是由浏览器自动添加的，因此其内容可能不一定准确或者安全。

某些浏览器、插件或者工具可能会修改或者删除 `Referer` 字段，从而导致其不准确或者不完整。

因此，在使用 `Referer` 字段进行防盗链或者其他操作时，需要谨慎考虑其应用场景，以及可能存在的安全风险。

-   当你设置了防盗链的时候,浏览器还能访问index.html的文本资源,
-   但是style.css,还要项目相关的js文件都无法访问.

![image-20230604171634418](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604171634418.png)

这个是原本就有的button![image-20230604171648455](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604171648455.png)

## 模板引擎EJS

### 1.基本Render

![image-20230605134446530](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605134446530.png)

EJS就是为了分离html和js,js指的是服务端的JS,nodeJs

![image-20230605135936865](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605135936865.png)

完全分开js代码和html代码

我只用知道HTML里面哪些地方用到了<%= 变量 %>,这个语法,和插值一样,在后面的对象里面把数据放进去就行了

甚至直接放`str = fs.readFileSync().toString()这都可以`

和对象的解构赋值差不多,变量名字和变量可以一样

![image-20230605140251746](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605140251746.png)

### 2.列表渲染

原生js的方式拼接字符串

![image-20230605141125583](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605141125583.png)



EJS实现:还是<% %>这种包裹JS变量的方法

![image-20230605141406466](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605141406466.png)

放到HTML文件里面依然可以去进行渲染,render即可!!!!

![image-20230605141508269](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605141508269.png)

### 3.条件渲染

把所有用到JS的地方进行<% %>即可

![image-20230605142057485](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605142057485.png)

基本和对象的**解构赋值**的查找方式是相同的,前面是**匹配模式**,后面是**实际变量**

### 4.在Express中使用EJS

![image-20230605142640475](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605142640475.png)

**templete文件**是有上面的`<% %>`的文件,放到views目录会自动寻找

path.resolve()

完整代码

![image-20230605143021535](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605143021535.png)

直接重名title.

然后home是在/views目录的下要渲染的home.html.

`res,render()`前面是渲染的文件名,后面是数据.

## Express生成器



## 文件相关处理

### 查看图片请求报文

#### 文件上传也是在发送http请求报文.

![image-20230604142755565](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604142755565.png)

上面的form-data name=username就是我们发送的用户名

然后底下的content-type是image/jpeg就是我们发送的图片文件.

![image-20230604143143925](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604143143925.png)

如果在上传的时候不加这个请求属性,

返回结果会是这样

![image-20230604143225460](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604143225460.png)

### 处理文件上传

chatGpt:

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="title function_">formidable</span>(&#123;</span><br><span class="line">		<span class="attr">multiples</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">uploadDir</span>: __dirname + <span class="string">&quot;/../public/images&quot;</span>,</span><br><span class="line">		<span class="attr">keepExtensions</span>: <span class="literal">true</span>,</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

这段代码是使用Node.js中的插件formidable来处理文件上传的请求。具体来说，它的作用是将上传的文件数据解析成易于处理的格式，并将文件保存到指定的目录中。这段代码的含义如下：

1.  `const form = formidable({})`：定义一个变量`form`，并以配置对象作为参数创建一个formidable的实例。
2.  `multiples: true`：配置formidable可以处理多个文件上传，而不仅仅是一个文件。
3.  `uploadDir: __dirname + "/../public/images"`：配置文件上传后的存储目录，通常是指向public目录中的子目录，这样才能在客户端通过浏览器访问到上传的文件。
4.  `keepExtensions: true`：保留文件原来的扩展名，以便在保存文件时将其正确地命名。

这段代码的目的是配置和实例化formidable插件，用于在Node.js Web应用程序中处理文件上传，使得开发者可以方便地接收和处理上传的文件数据。

![image-20230604143356173](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604143356173.png)

首先安装上面的包

在路由的index.js里面放入以下代码

![image-20230604143515518](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604143515518.png)

上面的**fields**放的一般是text,radio,checked,也就是那些表单中不是文件的东西.

`fields:{username:"abc"}`

而**files**就是文件在请求报文的本体了

`下面那个persistfile就是files的内容了`

![image-20230604143934998](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604143934998.png)

以下图片是为了保存上传来的图片的设置

保存到静态资源内部

![image-20230604143908766](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604143908766.png)

得到图片后,将要把这个图片渲染给用户,为了防止网站换域名

只保存相对路径url.

这个newFilename就是files文件对象里面的东西,是用户上传到服务器,然后那个插件自己重新设置的名字

![image-20230604144302150](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230604144302150.png)

## 记账本

先使用express -e accounts

创建express应用,-e的意思是添加ejs模板引擎

### 响应静态页面

![image-20230605165757730](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605165757730.png)

render方法把views文件夹的list.ejs响应给客户端

#### 当发现网页的样式丢失

![image-20230605170002935](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605170002935.png)

打开网络控制台观察

发现无法导入文件

![image-20230605170133611](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605170133611.png)

![image-20230605170221641](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605170221641.png)

在NodeJs代码中的`./`会变成这样![image-20230605170229296](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605170229296.png)

**相对路径**受到了url路径的影响,做了一个拼接,**相对路径**不可靠的点在于,会受到网页url的影响

静态资源默认`/css/bootstarp`即可访问,也就是直接`/`

绝对路径是默认跟在域名和端口

![image-20230605170526198](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605170526198.png)

的

### 获取表单数据

为了将表单数据正确的传递给服务端,每个表单数据都得有一个name值

name的值用来当json数据的对象名称

如何获取请求体数据?

![image-20230605172734720](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605172734720.png)

requset.body即可,因为express为我们封装好了parser

![image-20230605172831308](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605172831308.png)

#### lowdb

Small JSON database for Node, Electron and the browser. Powered by Lodash. ⚡️

能够在本地创建一个数据库

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> low = <span class="built_in">require</span>(<span class="string">&#x27;lowdb&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FileSync</span> = <span class="built_in">require</span>(<span class="string">&#x27;lowdb/adapters/FileSync&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> <span class="title class_">FileSync</span>(<span class="string">&#x27;db.json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> db = <span class="title function_">low</span>(adapter)<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>

![image-20230605184904103](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605184904103.png)

想更新文件内容就调用write()方法

![image-20230605185010464](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605185010464.png)

`db.get('post').find({id:1}).assign({title:lhg}).write()`

链式调用的核心是每一步的函数都返回this

![image-20230605184729984](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230605184729984.png)

删除数据是有返回值的,就是删除的对象

### 删除数据

首先是根据`id`删除服务器的数据,然后模板是服务器数据驱动的,数据没了,模板的东西也没了

**直接remove即可.**

![image-20230606164955085](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606164955085.png)

## RestFulAPI

一种定义api的风格:`Rest:使人感到舒服的api:接口`

![image-20230607201530453](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607201530453.png)

-   找不到资源:
-   status:`404`

-   禁止访问资源
-   status:`403`

-   找到了资源
-   status:`200`

## 创建API接口

便利多个客户端程序去请求同一份数据

### 接口的作用

> 实现 <span style="color:red">前后端通信</span>

![image-20230327163353386](F:\网站开发\LearnNodejs\尚硅谷MD笔记\assets\b6836e5dc9b1f33ee5f030de2fd1780db7f2447c.png)

### 接口的开发与调用

大多数接口都是由 <span style="color:red">后端工程师</span> 开发的， <span style="color:red">开发语言不限</span>

一般情况下接口都是由 <span style="color:red">前端工程师</span> 调用的，但有时 <span style="color:red">后端工程师也会调用接口</span> ，比如短信接口，支付接口
等

### 接口的组成

一个接口一般由如下几个部分组成

- 请求方法

- 接口地址（URL）

- 请求参数

- 响应结果

一个接口示例 https://www.free-api.com/doc/325

体验一下： https://api.asilu.com/idcard/?id=371522199111299668

### 代码实操

#### 添加和展示账单数据



通过`res.json()`直接发送json数据

![image-20230607210549625](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607210549625.png)

一般设置**code**都是`20000=200*100`

**微信里面的都是**::`0000`表示成功

msg:`都会直接发给客户端`

然后data就是读取数据库得到的data



![image-20230607210000198](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607210000198.png)

读取到的结果如图	

在post请求中,我们发现直接使用json给后端发送post请求

![image-20230607212305619](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607212305619.png)

依然跑的通,因为啊

是`express生成器的中间件设置`

![image-20230607212338788](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607212338788.png)

然后可以自动解析json数据

#### 表单验证

![image-20230607213058410](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607213058410.png)在缺少了必须的属性后,就可以把状态码设置成为缺少属性对应的status,然后在API文档里面写清楚即可

#### 删除账单



## 会话控制

主要类似于vue的路由守卫功能

用户身份验证和保护数据,**目的就是为了识别用户,返回正确的数据**

必须是自己才能看数据

`一次客户端和服务器的通话就是会话`

-   客户端发送request给服务端
-   服务端发送response给客户端
-   ![image-20230607123937675](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607123937675.png)
-   这样一次通信的过程就是一次会话

### cookie

#### cookie 是什么

> cookie 是 HTTP 服务器发送到用户浏览器并保存在本地的一小块数据

<span style="color:red">cookie 是保存在浏览器端的一小块数据</span>

<span style="color:red">cookie 是按照域名划分保存的</span>

简单示例：

**cookie本质就是一些`key:value`对应的键值对, lhg = "李昊戈" 这种字符串键值对**

| 域名             | cookie                        |
| ---------------- | ----------------------------- |
| www.baidu.com    | a=100; b=200                  |
| www.bilibili.com | xid=1020abce121; hm=112411213 |
| jd.com           | x=100; ocw=12414cce           |

#### cookie 的特点

浏览器向服务器发送请求时，会自动将 `当前域名下` 可用的 cookie 设置在请求头中，然后传递给服务器

就是`client`自动向`server`传递数据的方法,每次请求都会发送这段`cookie`请求头

![2432689d3a6913a8952b0e2f7c13b6aa468fe9ce](F:\WebDeveLoper\LearnNodejs\尚硅谷MD笔记\assets\2432689d3a6913a8952b0e2f7c13b6aa468fe9ce.jpg)

这个请求头的名字也叫 `cookie` ，所以将 <span style="color:red">cookie 理解为一个 HTTP 的请求头也是可以的</span>

#### cookie 的运行流程

填写**账号**和**密码**`校验身份`，**校验通过**后下发` cookie`

也就像在网吧**充值**会员卡一样,你给网吧老板提供**身份证信息**然后交钱,网吧老板给你返回**会员卡**

这个会员卡就是cookie,校验身份用的

浏览器在解析响应报文:`response`后,就会把`cookie`存到当前域名的**请求头**里面

![image-20230327214116490](F:\WebDeveLoper\LearnNodejs\尚硅谷MD笔记\assets\f65d061b87c7b44dbddc1e9703146f9e03482aea.png)
有了 `cookie` 之后，后续向`服务器发送请求`时，就会`自动携带 cookie`

![image-20230327214554199](F:\WebDeveLoper\LearnNodejs\尚硅谷MD笔记\assets\82caab8f82650a12b76b9085e3d7b5c44a725ee8.png)

有了cookie在请求头里面就可以知道是谁发的请求了,等于知道了用户是谁

#### express设置cookie

![image-20230607130529435](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607130529435.png)

代码直接调用`res.cookie`即可

`(first:key,second:value);`

在设置cookie以后,在响应标头中如图

![image-20230607130440788](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607130440788.png)

这就是设置上了,服务器给浏览器返回的设置成功

即使发送请求404,失败,依然在请求头携带Cookie.

![image-20230607131532593](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607131532593.png)



##### 美中不足:

![image-20230607131440229](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607131440229.png)

这种设置的在浏览器关了就没了

#### 7天免登录

设置cookie的生命周期

**![image-20230607131757331](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607131757331.png)**

Max-age代表存活的最大年龄,在浏览器单位为`秒`

![image-20230607131936353](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607131936353.png)

在代码里面的单位是毫秒,换算是`10*1000`,就是10秒.

在生命周期到期了,也就是Expirs的时间到了,才销毁

然后在浏览器关闭的时候,Cookie也不会消失,等待生命周期销毁.

#### 删除cookie

 ![image-20230607132257918](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607132257918.png)

在方法放入`cookie`对应的`key`:键名即可

原理;强制设置过期时间为1970年

![image-20230607133435667](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607133435667.png)

**在用户退出时可以清除cookie**

#### 读取cookie

先安装cookie-parser

![image-20230607133928879](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607133928879.png)

然后挂载`全局中间件`

![image-20230607133910679](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607133910679.png)

直接在req里面找就行

这个log是在服务端的,然后直接得到cookie的对象.

![image-20230607134033248](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607134033248.png)



### session

是**保存在服务端的数据**

用于保存用户的信息,传递给浏览器的只是携带`sid`的`cookie`.

然后前端根据sid:`sessionId`去访问对应的用户数据即可.

#### 代码实操

##### 先安装这两个包

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 安装包 pnpm i express-session connect-mongo</span></span><br><span class="line"><span class="comment">//2. 引入 express-session connect-mongo</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MongoStore</span> = <span class="built_in">require</span>(<span class="string">&#x27;connect-mongo&#x27;</span>);</span><br></pre></td></tr></table></figure>



这个服务端生成的id,name就是这个,可自定义

![image-20230607161241910](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607161241910.png)

![image-20230607161651220](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607161651220.png)

`secret:'lihaoge'`只是你个人的签名,想写啥写啥,会自动根据算法和你的签名生成密钥

`saveUninitialized`当你想保存一些**匿名用户**可以设置为`ture`

`resave`,相当于更新session的生命周期.不断的更新session,你不会在使用网站一段时间后又要重新登录

![image-20230607162011596](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607162011596.png)

这个`maxAge`把session和cookie的`生命周期`都设置了,

用到session的时候,直接给它设置属性即可,

#### 登录功能

![image-20230607162649269](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607162649269.png)

`request.session.username='admin'`就能设置上了

![image-20230607162940688](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607162940688.png)这是成功的样子,在**响应报文**就有Set-cookie这个东西了,传过去的就是`sid`

![image-20230607163114268](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607163114268.png)

数据库的存入的session

![image-20230607163225335](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607163225335.png)

存储了`_id`和expired:`过期时间`,实际session,也就是用户的信息.

#### 读取Session

![image-20230607163507831](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607163507831.png)

app.use(`session()`)已经配置完成了,则中间件会自动判断和获取发送过来的session,

只需要req.session.username就能看是否已经登录过,有信息了.

#### 删除session

![image-20230607163907653](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607163907653.png)

删除成功的回调.

### session 和 cookie 的区别

cookie 和 session 的区别主要有如下几点：

1. 存在的位置

  - cookie：浏览器端
  - session：服务端

2. 安全性

  - cookie 是以**明文**的方式存放在客户端的，安全性相对较低
  - session 存放于服务器中，所以安全性 `相对` 较好
  - 在互联网,没有绝对的安全,安全性只能是相对

3. 网络传输量

  - cookie 设置内容过多会增大请求体中报文的体积,会影响传输效率
  - session 数据存储在服务器，只是通过 cookie 传递 id，所以不影响传输效率

4. 存储限制

  - 浏览器限制单个 cookie 保存的数据不能超过 `4K` ，且单个域名下的存储数量也有限制
  - 单个域名最多存储`165个cookie`.

  - session 数据存储在服务器中，所以没有这些限制

### token

#### token 是什么

`token` 是服务端生成并返回给 HTTP 客户端的**一串加密字符串**， `token` 中保存着`用户信息`

token 不属于 `http 标准`，完全由**前后端协商而定**，但 cookie 属于 http 标准

#### token 的作用

实现**会话控制**，可以**识别用户的身份**，主要用于**移动端 APP**

*小程序,IOS的app,都使用`token`*

#### token 的工作流程

`填写账号和密码校验身份`，**校验通过后响应 `token`**，**token 一般是在响应体中返回给客户端的**

![image-20230328135106885](F:\WebDeveLoper\LearnNodejs\尚硅谷MD笔记\assets\5e03daa442b749955aac291d68ffa22c3506ba86.png)
后续发送请求时，需要前端`手动`将 token 添加在请求报文中(<span style="color:red">cookie是自动携带的</span>)，一般是放在请求头中
![image-20230328135122945](F:\WebDeveLoper\LearnNodejs\尚硅谷MD笔记\assets\7e7369958050ccff563122b9618f09c28dae956b.png)

#### token 的特点

- 服务端压力更小,因为SessIon保存在服务端,用户一多,就要高度的收发信息.

    - 而token数据存储在客户端:`app`中,每次通过请求头发送即可
- 相对更安全
    - 数据加密:用户信息完全加密.
    - token不会自动被携带到请求体中,比cookie安全,
    - 可以避免 CSRF（跨站请求伪造）
- 扩展性更强
    - 服务间可以共享
    - ![image-20230607165126125](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607165126125.png)
    - 一个token,多个服务进行校验
    - 使用token,在增加服务节点更简单,因为使用cookie,在增加服务结点时,还要增加对应的session信息,不然就无法识别用户了,因为直接使用token即可

### JsonWebToken

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnpm i jsonwebtoken</span><br></pre></td></tr></table></figure>

创建和生成token的工具包,同时还能校验token

#### 代码

![image-20230607165954987](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607165954987.png)

成功的`data:`

![image-20230607170108660](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230607170108660.png)

如果时间过期,则触发`err`这个回调函数的参数,发送校验失败!.

# accessToken and refreshToken

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">const</span> <span class="title function_">refreshToken</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">const</span> data = <span class="keyword">await</span> $fetch(<span class="string">&quot;/api/auth/refresh&quot;</span>); <span class="comment">//获取新的token</span></span><br><span class="line">				<span class="title function_">setToken</span>(data.<span class="property">access_token</span>);</span><br><span class="line">				<span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">				<span class="title function_">reject</span>(error);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useFetchApi</span>(url, options = &#123;&#125;) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; useAuthToken &#125; = <span class="title function_">useAuth</span>();</span><br><span class="line">	<span class="keyword">const</span> authToken = <span class="title function_">useAuthToken</span>();</span><br><span class="line">	<span class="keyword">return</span> $fetch(url, &#123;</span><br><span class="line">		...options,</span><br><span class="line">		<span class="attr">headers</span>: &#123;</span><br><span class="line">			...options.<span class="property">headers</span>,</span><br><span class="line">			<span class="title class_">Authorization</span>: <span class="string">`Bearer <span class="subst">$&#123;authToken.value&#125;</span>`</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">getUser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">useFetchApi</span>(<span class="string">&quot;/api/auth/user&quot;</span>); <span class="comment">//传递accessToken获取用户id</span></span><br><span class="line">				<span class="comment">//通过id获取用户信息</span></span><br><span class="line">				<span class="title function_">setUser</span>(data.<span class="property">user</span>); <span class="comment">//将用户信息存储在useAuthUser中</span></span><br><span class="line">				<span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">				<span class="title function_">reject</span>(error);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reRefreshAccessToken</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="comment">//实现功能:当访问令牌接近过期时自动刷新令牌</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> authToken = <span class="title function_">useAuthToken</span>();</span><br><span class="line">		<span class="comment">//如果没有access_token就return</span></span><br><span class="line">		<span class="keyword">if</span> (!authToken.<span class="property">value</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//解析为一个 JSON Web Token (JWT) 对象</span></span><br><span class="line">		<span class="keyword">const</span> jwt = <span class="title function_">jwtDecode</span>(authToken.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//在过期前的 60000 毫秒（即 1 分钟）内进行刷新</span></span><br><span class="line">		<span class="keyword">const</span> newRefreshTime = jwt.<span class="property">exp</span> - <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取新的refreshToken</span></span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">			<span class="keyword">await</span> <span class="title function_">refreshToken</span>();</span><br><span class="line">			<span class="title function_">reRefreshAccessToken</span>(); <span class="comment">//递归调用,在每次刷新后继续进行下一次刷新操作</span></span><br><span class="line">		&#125;, newRefreshTime);</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用refreshtoken完成用户自动登录.	</span></span><br><span class="line"><span class="comment">//当用户进入网页就触发这个函数.</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">initAuth</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">			<span class="title function_">setIsAuthLoading</span>(<span class="literal">true</span>); <span class="comment">//状态初正在加载中</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;准备执行refreshToken函数&quot;</span>);</span><br><span class="line">				<span class="keyword">await</span> <span class="title function_">refreshToken</span>();</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;准备执行getUser函数&quot;</span>);</span><br><span class="line">				<span class="keyword">await</span> <span class="title function_">getUser</span>();</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;准备执行reRefreshAccessToken函数&quot;</span>);</span><br><span class="line">				<span class="title function_">reRefreshAccessToken</span>();</span><br><span class="line">				<span class="title function_">resolve</span>(<span class="literal">true</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">				<span class="title function_">reject</span>(error);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="title function_">setIsAuthLoading</span>(<span class="literal">false</span>); <span class="comment">//状态末加载完毕</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>



accessToken和refreshToken是常用于认证和授权过程中的两种令牌。

1.  accessToken（访问令牌）：accessToken是一个短期的令牌，用于验证用户的身份和权限。它通常具有较短的过期时间，并在用户进行身份验证后颁发。accessToken在每次用户与服务器进行交互时都需要被发送，以证明用户已通过身份验证，并且具有访问受限资源的权限。它可以用于访问受保护的API端点，或授予用户特定的权限。
2.  refreshToken（刷新令牌）：refreshToken是一个长期的令牌，用于更新或获取新的accessToken。它通常具有较长的过期时间，并在用户进行身份验证后颁发。当accessToken过期时，refreshToken可以用于向服务器发送请求，以获取一个新的accessToken。这对于避免用户频繁进行身份验证且保持登录状态非常有用。

通常的工作流程如下：

1.  用户提供凭据（如用户名和密码）进行身份验证。
2.  服务器验证用户凭据，并颁发一个accessToken和一个refreshToken。accessToken在响应中返回，而refreshToken则可以安全地存储在客户端（如浏览器的cookie或本地存储）。
3.  客户端使用accessToken进行后续请求，以访问被保护的资源。
4.  当accessToken过期时，客户端使用refreshToken向服务器发送请求，以获取一个新的accessToken。
5.  服务器验证refreshToken的有效性，并在成功后颁发一个新的accessToken。

这个流程确保了用户的身份验证和访问授权的安全性，同时减少了用户频繁进行身份验证的需要。

请注意，具体的实现和使用方法取决于所使用的认证和授权协议，如OAuth2或JWT（JSON Web Token）。每个协议都有自己的规范和工作流程。

## 记账本添加会话控制

### 注册都差不多

`网站把数据传递给服务器,然后服务器把这个注册的数据传递到数据库里面`

### 实现注册

第一步,对应method,表单设置的post,必须是对应的方法

![image-20230608140359867](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608140359867.png)

先获取请求体数据(`req.body`)看看

在获取登录信息之后,创建数据库的文档模型

![image-20230608141848443](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608141848443.png)

基本代码如图,想像你是用户,然后把失败和成功的回调写好一点

因为密码是数据库比较重要的东西,然后可以使用

#### md5加密

[md5 - npm (npmjs.com)](https://www.npmjs.com/package/md5)

这种东西是**单向,不可逆加密**的算法,只能通过原数据生成加密数据

![image-20230608144057060](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608144057060.png)

但是加密数据到原数据不行

![image-20230608144249978](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608144249978.png)

包裹md5算法

### 登录功能

#### session



##### 写入SessIon

![image-20230608153604987](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608153604987.png)

先安装依赖,安装到全局的App.js里面

然后为了解耦合,还有模块化,导入配置项

![image-20230608153850904](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608153850904.png)

**登录成功**后写入SessIon

![image-20230608154057878](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608154057878.png)

获取data的_id:`new objectID的值`_

登录成功看下网络的请求报文的`Set-Cookie`

![image-20230608154226132](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608154226132.png)

![image-20230608154242954](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608154242954.png)

这就是设置上了,`cookie`里面就会导入`SessIon Id`

##### 监测SessIon

![image-20230608154712750](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608154712750.png)

如果没有,直接重定向

但是用到这样的场景太多了!!!!

所以想到设置这个操作到一个**中间件函数里面**

然后就直接use即可

![image-20230608155001784](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608155001784.png)

你就把`router`当做一个小型的App对象.

模块化:

直接把这个中间件提取出来即可

##### 销毁SessIon

直接调用请求对象:`req`的session属性上的destroy方法即可

**Destroys the session and will unset the `req.session` property. Once complete, the `callback` will be invoked:`执行`.**

这个回调中含有err参数,查看报错

![image-20230608171353872](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608171353872.png)

#### token

在请求接口的时候,是没有限制的,这是不行的

![image-20230608181051105](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608181051105.png)

你直接把请求发过来,在apifox等软件中,我就直接把结果返给你,这是不行的.

##### Api端口

![image-20230608181427214](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608181427214.png)

token主要是限制对接口的调用,如果没有token,就不能访问我的服务器的资源和接口

自己的完整代码,**新建了一个文件,注意,新建模块,记得引入模块文件**

![image-20230608184607037](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608184607037.png)

![image-20230608184712923](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608184712923.png)

这里判断data是否===null,如果等于,则必须在下面写**return**＋`代码`

不然的话,代码会继续走下面的东西,然后底层就会执行两个res.json,会出大问题.

##### 校验token

![image-20230608204853735](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608204853735.png)

如图,校验token,token从哪获取?,一般是后端给前端说的,去约束的

![image-20230608205119382](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608205119382.png)

直接`req.get()即可`:Return request header.

The `Referrer` header field is special-cased, both `Referrer` and `Referer` are interchangeable:`可交换的,可交替的`.:`可相互替換的零件`,意思就是**都行**

Examples:

req.get('Content-Type');
// => "text/plain"

`req.headers.authorization`

或者设置在上面也行

**因为需要保证所有的路由规则都由token保护,则设置路由中间件...**

![image-20230608210511878](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608210511878.png)

**封装完这个中间件,就可以全部使用中间件去执行路由的函数!!!**

`**但是模块化的中间件函数会出一些问题,暂时还不知道如何解决!!!**`

**在封装完模块之后,记得引入其中所需要的依赖项!!!!**

![image-20230608222911181](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608222911181.png)

**我是傻逼**!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

现在我就处于封装出问题,然后不知道如何debug

一个bug:请求方法出现问题

![image-20230608222707585](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608222707585.png)

我在路由里写的是`post`方法,但是,发送登录信息获取token的时候,搞成了**get**,导致报错,而且报错信息被app.js的错误拦截程序给拦截了

![image-20230608222821440](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608222821440.png)

草,解决了.

1.   看清请求方法

2.   在把代码模块化之后,记得导入依赖项!!!!!

3.   const jwt = require("jsonwebtoken");//导入依赖项

4.   jwt.verify(token, "lihaoge", (err, data) => {

     ​    if (err) {

     ​      //如果有错误信息,则断定token无效,返回json数据

     ​      return res.json({

     ​        code: "2004",

     ​        msg: "token 无效",

     ​        data: null,

     ​      });

     ​    }

     ​    // console.log(data); //这个data可以得到用户的id和用户名,知道是哪个token发送的请求

     ​    //验证成功就放行

     ​    next();

       });

##### 完善

###### 在配置文件中导入密钥,因为密钥用了两次,后面改不好改

把token的密钥导入配置项

![image-20230608230757151](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608230757151.png)

解构赋值:

![image-20230608230816353](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608230816353.png)

就可以了

-   在做成多人的记账本的时候,就要保存当前用户的信息了

![image-20230608230346204](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608230346204.png)

-   在请求对象里面添加了一个属性`user`,

-   中间件函数是可以访问req和res这个对象的
-   然后在get(/account)这个路由回调就能访问了
-   ![image-20230608230520187](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608230520187.png)
-   之前的`req.session`和`req.body`
-   ![image-20230608230635101](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608230635101.png)
-   都是中间件函数对请求报文:`req`做的处理,
-   然后把这些数据存到了req和res的身上

### 本地域名配置

所谓本地域名就是 <span style="color:red">只能在本机使用的域名</span>，一般在开发阶段使用

#### 操作流程

编辑文件 `C:\Windows\System32\drivers\etc\hosts`

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1   www.baidu.com</span><br></pre></td></tr></table></figure>

如果修改失败，<span style="color:red">可以修改该文件的权限</span>

![11_会话控制](F:\网站开发\LearnNodejs\尚硅谷MD笔记\assets\bfe2b3b80fe871577ca342891eef6201f352b682.jpg)

#### 原理

在地址栏输入 `域名` 之后，浏览器会先进行 DNS（Domain Name System）查询，获取该域名对应的 IP 地
址
请求会发送到 DNS 服务器，可以 `根据域名返回 IP 地址`

![image-20230608233427904](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608233427904.png)

*就是你输入`www.baidu.com`DNS服务器:`域名系统`就会去查询这个域名:`www.baidu.com`对应的ip地址,然后使用这个`5.69.36.125`去发送实际的请求,根据域名返回ip地址,然后优先查询的是本机的hosts文件,也就是上面的设置文件.*

###### 屏蔽广告

把那些广告对应的域名对应的**ip地址**改成本机的**ip地址**,这个请求当然ping不通啊,然后就可以达到广告屏蔽的作用

###### 屏蔽更新

相同的原理:把更新的域名对应的ip也修改成你本机的域名`127.0.0.1`,这样发送请求的时候,也是发送到本机,导致请求失败

可以通过 `ipconfig /all` 查看本机的 DNS 服务器

`hosts` 文件也可以设置域名与 IP 的映射关系，在发送请求前，可以通过该文件获取域名的 IP 地址

### 跨站请求伪造

CSRF:`跨站请求伪造`

![image-20230608172211768](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608172211768.png)

这个网站的运行端口是`5500`然后和我们的端口port:`3000`不一样

![image-20230608172347039](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608172347039.png)

![image-20230608172357142](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608172357142.png)

-   所以相当于不同的网站.

-   但是在link这个css文件的时候,发送请求的网址是logout的网址,等于说发送了登出请求.

-   然后A网站直接退出登录了

-   ![image-20230608172448510](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608172448510.png)

    并且B网站在发送这个请求的时候,还会带上A网站的CookIe

    ![image-20230608172630466](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608172630466.png)

    带上了Cookie

-   这就是跨站请求伪造

解决方法:

设置表单:form退出,设置对应的路由规则为post,设置button提交,因为a标签默认提交的是get方法

![image-20230608173122716](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608173122716.png)

原本的`a标签要不得了啊`

![image-20230608173225079](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608173225079.png)

改成这样即可

原因就是这个![image-20230608173103340](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608173103340.png)

这种`link`和`script的src`,还有`img的src`这些发送的都是默认的get请求

### 设置首页

![image-20230608180514765](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608180514765.png)

直接重定向到账单即可

但是会造成发送多次请求,先给`/`发送

然后是`account`发送请求,然后检测到没有登录的话,还会跳到err界面,

这还是发送请求了,**负担!**

#### 设置404

在`app.js`里面设置即可

![image-20230608180710126](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230608180710126.png)

处理404的函数,嘻嘻

# MongoDb数据库

## 如何开启数据库的副本集模式?

支持prisma开启事务功能

**最佳答案**

**只需添加一个有效服务器使用的端口**，

**只需添加一个有效服务器使用的端口**

**只需添加一个有效服务器使用的端口**

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod --port 27017 --replSet rs0 #即可成功开启副本集模式</span><br></pre></td></tr></table></figure>

它就可以正确运行:

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongo --port 27020 &lt; init_replica.js </span><br></pre></td></tr></table></figure>

我很遗憾，但我希望这能帮助那些也在学习这门类(class)但发现自己陷入类似困境的人。

## Mongoose

### JS代码链接数据库

![image-20230606181906543](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606181906543.png)

协议不同,然后要操作的数据库名称跟在后面即可,`没有这个dataBase的名称`会**新建**

![image-20230606182127940](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606182127940.png)

这里的`on`就是监听事件,然后跟上要监听的事件名称

完整代码:

![image-20230606183238605](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606183238605.png)

总之就是一系列监听的回调.

![image-20230606183435335](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606183435335.png)

此处使用once也就是监听一次open事件的回调,然后防止bug出现

### 插入document数据

#### 新增

![image-20230606184828446](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606184828446.png)

`create(first,second):`

-   first:要插入的**document**对象,就是js对象

-   second:接收两个参数:

-   err:报错参数

-   data:输入插入后的文本对象

![image-20230606184013727](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606184013727.png)

在链接成功的回调函数中,我们写实际操作

`Schema:有图表和结构的意思`*此处就是定义document里面的Key:`属性`和key:属性的类型*

same as interFace in ts , 然后就是对这个collection:`集合`内部的document:`文档`的约束

![image-20230606184324819](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606184324819.png)

这段就是根据刚定义的`Schema`创建对`document`操作的封装对象

内部有增:`create`删:`delete`改:`remove`查:`find`的操作

##### 一次添加多个

![image-20230606221257882](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606221257882.png)

直接`BOOkModal.insertMany();`传入数组即可

#### 删除

`删除一条`:

![image-20230606223355915](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606223355915.png)

现在是Promise的天下了

`删除多条`:

![image-20230606223448363](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606223448363.png)

根据`is_hot值批量删除`

![image-20230606223633967](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606223633967.png)

删除响应结果

![image-20230606223650273](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606223650273.png)

这个deletedCount是因为上面的id删除已经被删了

然后这次没有东西要删,当然为0了

#### 更新

`更新一条:`

接收两个参数,({`查找内容`},{`要更新的内容`}).then(()=>{})

![image-20230606224325125](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606224325125.png)

如图.返回结果

![image-20230606224401229](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606224401229.png)

`更新多条`

![image-20230606224515247](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606224515247.png)

这段代码的意思是,寻找所有`author="余华的"`,然后把数据里面的`is_hot`更新为`true`

#### 读取

![image-20230606224852237](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606224852237.png)

-   通过id查找数据,id就是 new objectId的里面的id
-   在回调的data中拿到数据
-   ![image-20230606224932109](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606224932109.png)
-   ![image-20230606224952380](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606224952380.png)
-   findOne方法, 读取符合条件:`name='狂飙'`的第一条数据,
-   在回调的data中拿到值
-   ![image-20230606225048526](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606225048526.png)
-   find()方法,不写条件获取所有数据捏
-   有获取条件
-   ![image-20230606230128694](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606230128694.png)
-   要是,是多条数据,则返回对象数组.
-   ![image-20230606230152132](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606230152132.png)
-   不写条件
-   ![image-20230606230217009](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606230217009.png)
-   

### Schema的类型要求

![image-20230606211629312](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606211629312.png)

![image-20230606211642562](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606211642562.png)

如果把这个名字`is_hot`写错了,写成`is_hotxxx`,则在传递数据的时候会直接忽略该数据.

在数据库一般**不存储** *buffer*,也就是图片和视频,基本上都是存储这种字符串和数字还有数组.

然后在public这种文件夹里面存储视频和图片.然后在数据库里面存储指向**静态资源**的`URL`

通过URL去找这些资源,呈现给用户.

#### 字段验证

#### 1.requird

![image-20230606215255809](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606215255809.png)

当![image-20230606215316481](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606215316481.png)

设置了这个,name就是必填项,没填报错,和deFineProps差不多

#### 2.default

![image-20230606215523032](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606215523032.png)

设置默认值,如果没传author,则默认`匿名`

![image-20230606215607856](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606215607856.png)

#### 3.enum

![image-20230606220256898](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606220256898.png)

**如果给的值不是enum数组里的值,就会报错,内容约束**

报错结果:

![image-20230606220426119](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606220426119.png)

不是可用的枚举值

#### 4.unique

应用独一无二的值,必须重建collection

然后报错提示:

![image-20230606220754169](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606220754169.png)

1 dup key,一个重复的key

![image-20230606220816135](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606220816135.png)

设置unique,加了一个唯一的限制

## 条件控制

基本如下

然后`$lt`:lt就是**less than**小于的意思

查询的条件也是个对象

![image-20230606230706382](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606230706382.png)

找到所有价格小于20的图书.

![image-20230606230605014](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606230605014.png)

找到作者:余华||曹雪芹

![image-20230606231437971](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230606231437971.png)

$or表示后面是或的逻辑关系,然后使用author这个条件放到对象里面,外面套一层数组即可

## 项目上线

代码上传到github仓库

#### 设置gitignore文件

在git push代码的时候

![image-20230609133423307](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609133423307.png)

忽略这一部分文件

![image-20230609133506361](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609133506361.png)

也可以去看看gitee的教程

#### 也可以看看教程:设置远程存储卡的URL

![image-20230609133617113](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609133617113.png)

![image-20230609133631636](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609133631636.png)

出现这个

然后输入你码云:gitee的这些账号:username和密码:password,就可以去进行远程代码的上传了

远程服务器地址

![image-20230609170552872](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609170552872.png)

![image-20230609171900102](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609171900102.png)

网关没有设置好

![image-20230609171913039](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609171913039.png)在安全组这个位置设置网关的端口为80

# 小满前端网络

## OSI七层网络参考模型

-   OSI的全称是开放式系统互连基本参考模型（Open Systems Interconnection Basic Reference Model）

-   通常简称为OSI模型或OSI参考模型。
-   它是一个由国际标准化组织（ISO）制定的概念性框架，用于将计算机通信协议划分为七个不同的层次。
-   每个层次都执行特定的功能，并在各个层次之间传递信息，以实现计算机之间的通信。
-   该模型旨在确保不同厂商的计算机和网络设备可以相互通信，而不必了解其他设备的详细信息。

![image-20230609201722752](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609201722752.png)

只是参考模型罢了

### 物理层

![image-20230609201827750](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609201827750.png)

**最重要的是物理的通讯,也就是物理层的信道**

![image-20230609201937162](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609201937162.png)

![image-20230609202028590](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609202028590.png)

  最重要的,最终电,光,无线电波,这些东西,我们会获取他们对应的传送信号和电压,转换成`0101`这种东西,但是数据还没有组织,单位是`bit`传输:**比特流**

![image-20230609202150821](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609202150821.png)

### 数据链路层

![image-20230609202501450](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609202501450.png)

将传过来的比特流,组合成**字节**,然后把字节组合成帧,使用电脑or手机的无线网卡上的`MACID`访问介质

![image-20230610135824487](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610135824487.png)

本机的这个physical address:物理地址.

**就是数据链路层的MAC地址**

#### MACID

![image-20230609202903526](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230609202903526.png)



知道谁是接收者,谁是发送者,知道了数据的内容,同时知道如何进行分组

**进行广播的方式去传输**,在局域网的所有计算机都能收到消息

### 网络层

![image-20230610134911330](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610134911330.png)

数据链路层的数据在这一层被转换为数据包,通过路径选择,分段组合,将信息从一个网络设备传送到另一个网络设备

寻址,就是根据ip地址去唯一标识互联网上的设备,网络层依靠ip地址相互通信

在同一个网络中的内部通信不需要借助`网络层`,直接根据数据链路层的MAC:`media access control`上的id地址就可以去相互通信,在不同网络的痛惜必须借助路由器等三层设备

![image-20230610135611199](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610135611199.png)

​    数据链路层传递消息是广播的形式传递消息

网络十分巨大,通过各个路由器端对端的进行查找

划分用户:自己在自己的小网段中广播

-   `网络地址`帮我们**确定**计算机所在的子网络
-   MAC地址将数据包送到该子网络的目标网卡
-   网络地址:在网络层引入了一套新的地址,让我们能够区分不同的网段,  这套地址就是网络地址                      

### 传输层

![image-20230610141058548](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610141058548.png)

Transmission Control Protocol会反复的确认你这个消息对不对

**TCP的全称是`Transmission Control Protocol`，中文名称为“`传输控制协议`”。它是一种面向连接的、可靠的数据传输协议，用于应用层之间的数据传输。TCP通过三次握手来建立连接，通过流量控制、拥塞控制等机制来保证数据传输的可靠性。**

**UDP的全称是`User Datagram Protocol`，中文名称为“`用户数据包协议`”。它是一种无连接的、不可靠的数据传输协议，用于应用层之间的数据传输。UDP不提供建立连接、数据重传等机制，因此传输速度更快，但数据传输的可靠性较差。UDP通常用于实时数据传输场景，如音视频传输**

“数据包:`datagram`”是计算机网络中数据传输的基本单元，是一个独立的、自包含的信息包。它由一个标头和一个有效载荷组成，其中标头包含源和目的地地址、控制信息以及将有效载荷传递到正确目的地的任何其他必要信息。一旦数据报被发送，它就不能保证到达其预期目的地，而且它可能会丢失、复制或无序发送

#### Websocket

**WebSocket就是一种实现服务器可以向客户端发送信息的协议?**

-   是的，WebSocket 是一种协议或者通信标准，它使得服务器可以向客户端实时地推送消息或数据。

-   传统的 HTTP 协议是一种“请求-响应”协议，即客户端发送请求，服务器返回响应，这个过程完成后连接就断开了。
-   而 WebSocket 是一种“双向通信”协议，即服务器和客户端都可以主动地发送和接收消息，连接会一直保持开启状态，直到被关闭。

-   通过 WebSocket 实现的双向通信，可以在客户端浏览网页的过程中，实现实时的消息推送、实时数据更新等功能。

-   WebSocket 协议相对于传统的 HTTP 协议，更适合于实现实时通信、在线游戏等需要高实时性和高并发的场景

**在计算机网络中，“`socket`”是指在网络上运行的两个程序之间的双向通信链路的终点:`endpoint`。**

-   它是IP地址和端口号的组合，允许网络识别数据应该发送到哪个应用程序或进程。

-   socket是由程序创建的，用于建立连接或接收数据，它可以用于通过各种协议（如TCP、UDP等）在网络上发送或接收数据。

-   socket可以被视为一扇门，通过它可以发送或接收数据，它为两个程序通过网络相互通信提供了一种机制.

### 会话层

![image-20230610142625487](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610142625487.png)

像qq和微信,在每一个群聊和每一个个人信息聊天,都是有一个会话id去维护的.

#### 断点下载:

断点下载是指**在下载文件过程中，如果由于某种原因导致下载中断，再次下载时可以从中断的地方继续下载，而不是从头开始下载。**其原理如下：

-   当开始下载一个文件时，服务器会把整个文件分为多个大小相等的部分，称为`数据块`。客户端会按顺序依次下载这些`数据块`，每下载一个数据块，就把它追加到已下载的文件中。同时，客户端会不断地记录已经下载的数据块的数量、大小、位置等信息，并保存在一个临时文件里。

-   如果下载中断了，客户端**只需要获取到已下载的数据块的信息**，就可以**从中断的地方开始下载**，而不是从头开始。- 
-   客户端会向服务器发送一个请求，请求指定数据块的范围，服务器收到请求后，只会返回请求的那一部分数据块，这样客户端就可以从中断的位置继续下载文件了。
-   在下载完成后，客户端会将所下载的所有数据块合并成一个文件，并删除临时文件。

-   断点下载的原理主要是通过可以指定从哪个位置开始获取数据块的功能来实现的。客户端保存已经下载的数据块的信息，使得下载文件时可以快速找到中断的位置，从而节省了下载时间和带宽的消耗。
-   同时，由于数据块是分散下载的，这样也可以避免服务器过载或者网络拥堵等问题导致整个文件下载失败的风险。

### 表示层

![image-20230610143035733](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610143035733.png)

### 应用层

![image-20230610144214882](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610144214882.png)

SMTP:

SMTP的全称是**Simple Mail Transfer Protocol**，中文意思是“简单邮件传输协议”。

`Simple Mail Transfer Protocol`是电子邮件系统中使用的一种标准协议。

-   SMTP协议可以帮助用户在不同的网络环境中发送电子邮件文本和附件。
-   SMTP协议通常与POP3和IMAP协议一起使用，这些协议可以帮助用户使用电子邮件客户端（如Gmail, Outlook, Yahoo Mail, 等等）收取和管理他们的电子邮件。

-   SMTP协议通过 TCP/IP 网络协议在服务器之间传输邮件。

使用SMTP协议发送电子邮件的过程通常包括以下步骤：

1.  用户编写电子邮件，并在电子邮件客户端中选择“发送”。
2.  电子邮件客户端将电子邮件发送至用户所在服务器的SMTP服务器
3.  SMTP服务器查找电子邮件的DNS地址，并将邮件传递到目标SMTP服务器
4.  目标SMTP服务器将邮件存储在接收者的电子邮件邮箱中
5.  接收者查看邮箱，并可以通过POP3、IMAP协议从服务器中下载电子邮件。

SMTP协议对于电子邮件系统的运作非常重要。它使得人们可以在全球范围内发送电子邮件，使得电子邮件交流成为了人们日常生活中不可或缺的一个部分

## TCP三次握手

![image-20230610151937055](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610151937055.png)

**SynChronous**:`happening or existing at the same time`,发起一个新连接

同时发生(或存在)的;同步的;共时的

#### `sequence number`:序列号,使用算法生成的

#### 因为客户端的报文很多,使用序列号主要的目的是,方便整理顺序

#### ack:`acknowledge ment`number.:确认号,=seq+1,也就是序列号+1.

#### RET:Reset报文:

RST 报文的全称是 “复位（Reset）” 报文，它是TCP（Transmission Control Protocol，传输控制协议）中的一种控制报文，用于终止一个TCP连接。

当一个主机或应用程序需要中断一个TCP连接时，可以通过发送 RST 报文来实现。RST 报文告诉对方主机或应用程序，它想要结束当前的TCP连接，所有未传输成功的数据包都会被抛弃，不会进行重传。

RST 报文的发送有很多原因，一些常见的情况包括：

-   连接超时
-   应用程序错误
-   网络故障
-   安全策略限制

总之，RST 报文作为一种重要的TCP控制报文，可以用于及时终止连接并释放网络资源，确保网络的正常运行和数据的安全传输。

### 字节面试概括起来，是这两个问题：

TCP 三次握手中，客户端收到的第二次握手中 ack 确认号不是自己期望的，会发生什么？是直接丢弃 or 回 RST 报文？
什么情况下会收到不正确的 ack（第二次握手中的 ack） 呢？
问题解答
回 ReSet:RST:`重置` 报文。过程如下图：

![img](https://img-blog.csdnimg.cn/img_convert/816bf6183bec674be77d94f0de63321a.png)

三次握手避免历史连接

当客户端连续发送多次建立连接的 SYN 报文，然后在网络拥堵的情况，就会发生客户端收到不正确的 ack 的情况。具体过程如下：

客户端先发送了 SYN（seq = 90） 报文，但是被网络阻塞了，服务端并没有收到，接着客户端又重新发送了 SYN（seq = 100） 报文，注意不是重传 SYN，重传的 SYN 的序列号是一样的。
「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文的确认号是 91（90+1）。
客户端收到后，发行自己期望收到的确认号应该是 100+1，而不是 90 + 1，于是就会回 RST 报文。
服务端收到 RST 报文后，就会中止连接。
后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。
上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的最主要原因就是防止「历史连接」初始化了连接。

我们也可以从 RFC 793 知道 TCP 连接使用三次握手的首要原因：

The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.

## Fetch

### Get

**第一个参数**:`url`,啥都不加默认就是get请求,返回一个promise对象

可用`async`和`await`等待`promise的执行结果`

直接请求返回的是一个promise.

`promise`传递过来的是`response响应对象`

然后在`response:object`上有这几个重要的方法:

![image-20230616220542035](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616220542035.png)

![image-20230616220738861](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616220738861.png)

在then方法中返回的数值,在下一个then里面就能接收到.也就是下一个then的回调参数.

![image-20230616220835685](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616220835685.png)

### post请求

![image-20230616221045276](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616221045276.png)

**第二个参数**指定方法:`post`

在`body`:也就是请求体中,需要把对象序列化成`json字符串`

后端返回json对象.前端要转化一下.

![image-20230616221217379](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616221217379.png)

### 进度条

![image-20230616231129534](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616231129534.png)

进度条需要得到当前的进度和总进度

然后使用reader用流的方式去进行读取

### 中断请求

![image-20230616231525271](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616231525271.png)

调用abort的`abort()方法即可`

![image-20230616231545038](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616231545038.png)



# 数据结构

![image-20230610154953015](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610154953015.png)

基本上从32页开始读就行

刷刷算法题,生活有滋味

![image-20230610164604415](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610164604415.png)

**原子型的意思就是不可以再分解的基本类型**

![image-20230610164654348](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610164654348.png)

为什么要分出数据类型?
主要是因为每个`变量`和`常量`还有`表达式`都有`各自的取值范围`,而`类型`用来说明**变量或者表达式的取值范围和所能进行的操作**

也就是int a,此时a不能超出int这个数据类型要求的取值范围,也就是大整数不行了

![image-20230610164945115](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610164945115.png)

我们是高级语言开发者,我们只想实现操作罢了

抽象:**抽取出事物具有的普遍性的本质**,只保留实现目标所必需要的信息

我们在定义class的时候,也就是定义类的时候,其实就是在定义::抽象数据类型

![image-20230610170108692](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610170108692.png)

这就是类的定义啊

![image-20230610170130758](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610170130758.png)

这一组操作在代码层面不就是函数吗?

也就是类里面的方法:`其实也是函数,放到类里面就叫做方法了`

## 算法

算法是**为了解决某个特定的问题**然后一步步写出对这个问题的求解步骤的描述

也就是解完一道题,然后写出这道题的求解步骤,这个求解步骤就是算法

也就是解决问题的方法,就是算法.

空间复杂度,例子:求解闰年,可以直接创建一个有`2050个元素的数组`

然后把问题转化为查找数组的某一项的值是多少的问题

![image-20230610171857723](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610171857723.png)

## 线性表:

![image-20230610172126284](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610172126284.png)

p68页

序列,元素之前是有顺序的,线性表是有限的

![image-20230610172247476](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610172247476.png)

这东西是有序的,也就是有方向的

![image-20230610172312263](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610172312263.png)

星座就是线性表,有前驱和后继,然后是有限的,一共只有12个,符合线性表定义

![image-20230610172356493](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610172356493.png)

这种东西就不是线性表了.这种就是树,二叉树.类似于二叉树

![image-20230610172629305](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230610172629305.png)

当你传递一个参数给一个函数,如果这个参数需要被改动

则传递指向这个参数的指针,

如果不用被改动,则直接传递这个参数即可

-   其实看书也就是想看啥看啥喽,没人阻挡你,没人阻挠你.

# TypeScript

## declare

创建声明文件,获得代码提示.

![image-20230616215100464](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616215100464.png)

在具有声明文件的情况下,可以获得代码补全,然后使用![image-20230616215137349](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230616215137349.png)

这个命令去添加express的声明文件,记得加上`@types`代表你要获取的是声明文件,

这个npm的declare文件主要是一些第三方社区的热心人士编写的.

# 蓝桥杯

## 自适应页面

先打开F12调试工具看懂电脑端的布局和样式,再去移动端调节即可

![image-20230617181357100](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230617181357100.png)

此处使用网格布局,然后把两列调成一列即可.基本上和flex差不多.但是分成几列好一点

既然已经离不开ai,那就离不开喽!!!,大势所趋!!!!.

## C++算法系列

开始看STL了吧.

# Docker

**Docker**

`a person whose job is moving goods on and off ships`

# TailwindCSS

## 导入配置

官网看文档,后面会写,

[Install Tailwind CSS with Vite - TailwindCSS中文文档 | TailwindCSS中文网](https://www.tailwindcss.cn/docs/guides/vite#vue)



和`DeiyuUI`配合即可

抄掘金的文档,原文地址[快速掌握 Tailwind：最流行的原子化 CSS 框架 - 掘金 (juejin.cn)](https://juejin.cn/post/7231539903649398843)

## Tailwind 是流行的原子化 css 框架。

有多流行呢？

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43cb29ccb69f462cbb7cfaec866d122c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

它现在有 68k star 了，要知道 express 才 60k：

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b34e4e5df2147f9a1b85f6d49804292~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

那什么是原子化 css？

我们平时写 css 是这样的：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.aaa &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    border: 1px solid #000;</span><br><span class="line">    padding: 4px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在 html 里指定 class，然后在 css 里定义这个 class 的样式。

也就是 class 里包含多个样式：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aecedc8ad6344918b19bedfb5505a54a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### 原子化 css 

是这样的写法：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html</span><br><span class="line">复制代码<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-base p-1 border border-black border-solid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">css复制代码.text-base &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line">.p-1 &#123;</span><br><span class="line">    padding: 4px;</span><br><span class="line">&#125;</span><br><span class="line">.border &#123;</span><br><span class="line">    border-width: 1px;</span><br><span class="line">&#125;</span><br><span class="line">.border-black &#123;</span><br><span class="line">    border-color: black;</span><br><span class="line">&#125;</span><br><span class="line">.border-solid &#123;</span><br><span class="line">    border-style: solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25e18f4e6eb3470986c8735964f486da~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

定义一些细粒度的 class，叫做原子 class，然后在 html 里直接引入这些原子化的 class。

这个原子化 css 的概念还是很好理解的，但它到底有啥好处呢? 它解决了什么问题？

口说无凭，我们试下 tailwind 就知道了，它就是一个提供了很多原子 class 的 css 框架。

我们通过 crerate-react-app 创建一个 react 项目：

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">npx <span class="built_in">create</span>-react-app tailwind-test</span><br></pre></td></tr></table></figure>

然后进入 tailwind-test 目录，执行

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">npm install -D tailwindcss</span><br><span class="line">npx tailwindcss <span class="keyword">init</span></span><br></pre></td></tr></table></figure>

安装 tailwindcss 依赖，创建 tailwindcss 配置文件。

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7930ae6846d438ebd7d83586fceaac4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

tailwind 实际上是一个 postcss 插件，因为 cra 内部已经做了 postcss 集成 tailwind 插件的配置，这一步就不用做了：

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc7f7d94bf4e419dabb2cf60446f78c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### 然后在入口 css 里加上这三行代码：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd6778fe2dc74822b3735b6c83b55777~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

这三行分别是引入 tailwind 的基础样式、组件样式、工具样式的。

之后就可以在组件里用 tailwind 提供的 class 了：

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;text-base p-1 border border-black border-solid&#x27;</span>&gt;</span>guang<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

我们执行 npm run start 把开发服务跑起来。

可以看到，它正确的加上了样式：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8c82e20547b4b06a8c523f7e0edd04a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

用到的这些原子 class 就是 tailwind 提供的：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05094ce1ae1d4adf9a57b5ab74e4bea0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### 这里的 p-1 

是 padding:0.25rem，你也可以在配置文件里修改它的值：

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/966b4d4f72aa41bcbd111f752d82f1a3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### 在 tailwind.config.js 

的 theme.extend 修改 p-1 的值，设置为 30px。

刷新页面，就可以看到 p-1 的样式变了：

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb389cb5661a4f84a040e9cb87dbbbce~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### .text-base 

是 font-size、line-height 两个样式，这种通过数组配置：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/055a97a29ade4afab612340ada86a4c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a7fa0353bb24d23a1c3d82c501d338e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

也就是说所有 tailwind 提供的所有内置原子 class 都可以配置。

但这些都是全局的更改，

## 有的时候你想临时设置一些值，可以用 [] 语法。

**比如 text-[14px]，它就会生成 font-size:14px 的样式：**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82af77d4f8da48dc8a4a742a762e4398~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

比如 aspect-[4/3]，就是这样的样式：

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/259366d7084241789e49a9a428131f28~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

我们平时经常指定

###  hover

 时的样式，在 tailwind 里怎么指定呢？

很简单，这样写：

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a77e52e52d7a4545b3587668f018dec0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

**生成的就是带状态的 class：**

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f42c891999c44e3a4d2140fb440abca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3cfb7a2d5444cb39603b5f01e787012~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

此外，写

### 响应式的页面

的时候，我们要指定什么宽度的时候用什么样式，这个用 tailwind 怎么写呢？

也是一样的写法：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a865f8e38a9e4c92b5abcbea3a2651e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9ce674e44414a3e85fcced80085f670~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

生成的是这样的代码：

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a466932569514c0c840fe0035f99ff73~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

这个

### 断点位置配置

自然也是可以配置的：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/805f82920d75400ba0a307dea0ace8cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

可以看到 md 断点对应的宽度变了：

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eebd397537274b4693738c97383325d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ae904d37de049b880badfed8aacfcc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

光这些就很方便了。

### 对比hover和md断点和hover

之前要这么写：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.aaa &#123;</span><br><span class="line">    background: red;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.aaa:hover &#123;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media(min-width:768px) &#123;</span><br><span class="line">    .aaa &#123;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

现在只需要这样：

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-[14px] bg-red-500 hover:text-[30px] md:bg-blue-500&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

省去了很多样板代码，还省掉了 class 的命名。

并且这些 class 都可以通过配置来统一修改。

感受到原子化 css 的好处了么？

### tailwind 文档提到了 3 个好处：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbac4dde269c4b58bbcf52c7873447bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

不用起 class 名字，这点简直太爽了，我就经常被起 class 名字折磨。

css 不会一直增长，因为如果你用之前的写法可能是这样的：

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2304e0d40eb4889b92cd898fe78979c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

多个 class 里都包含了类似的样式，但你需要写多次，而如果用了原子 class，就只需要定义一次就好了。

css 没有模块作用域，所以可能你在这里加了一个样式，结果别的地方样式错乱了。

而用原子 class 就没这种问题，因为样式是只是作用在某个 html 标签的。

我觉得光这三点好处就能够说服我用它了，特别是不用起 class 名字这点。

当然，社区也有一些反对的声音，我们来看看他们是怎么说的：

**一堆 class，可读性、可维护性太差了**

真的么？

这种把 css 写在 html 里的方式应该是更高效才对。

想想为啥 vue 要创造个单文件组件的语法，把 js、css、template 放在一个文件里写，不就是为了紧凑么？

之前你要在 css、js 文件里反复跳来跳去的，查找某个 class 的样式是啥，现在不用这么跳了，直接在 html 里写原子样式，它不香么？

而且 tailwindcss 就前面提到的那么几个语法，没啥学习成本，很容易看懂才对。

**但是还要每次去查文档哪些 class 对应什么样式呀**

这个可以用 tailwind css 提供的 vscode 插件来解决：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6a69fce59034989800b424d2bfda9a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

安装这个 

### Tailwind CSS IntelliSense 

之后的体验是这样的：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8adcfd3c52bc4a0bb9c06392a1434910~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

有智能提示，可以查看它对应的样式。

不需要记。

**难以调试**

在 chrome devtools 里可以直接看到有啥样式，而且样式之间基本没有交叉，很容易调试：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf37f8087da4406b9d13e29cf8670f96~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

相反，我倒是觉得之前那种写法容易多个 class 的样式相互覆盖，还要确定优先级和顺序，那个更难调试才对：

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a57d24ddeda24c05b888dbe77b7e5bfe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### **类型太长了而且重复多次**

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11687714e4044a67ad4e67c84d33acef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

这种问题可以用 

#### @layer @apply 

指令来扩展：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/010f4acf2c7e48f09d62260a67905965~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

前面讲过 @tailwind 是引入不同的样式的，而 @layer 就是在某一层样式做修改和扩充，里面可以用 @apply 应用其他样式。

效果是这样的：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2956afd271aa4c49912fc3e8d1a85a2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50654d7d033143afba709d6944ab0392~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### **内置 class 不能满足我的需求**

其实上面那个 @layer 和 @apply 就能扩展内置原子 class。

但如果你想跨项目复用，那可以开发个 

#### tailwind 插件

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plugin = <span class="built_in">require</span>(<span class="string">&#x27;tailwindcss/plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">plugin</span>(<span class="keyword">function</span>(<span class="params">&#123; addUtilities &#125;</span>) &#123;</span><br><span class="line">    <span class="title function_">addUtilities</span>(&#123;</span><br><span class="line">        <span class="string">&#x27;.guang&#x27;</span>: &#123;</span><br><span class="line">            <span class="attr">background</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">            <span class="attr">color</span>: <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;.guangguang&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;font-size&#x27;</span>: <span class="string">&#x27;70px&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

在 tailwind.config.js 里引入：

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e87fda951404486ca635d4dce5cdf20f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

这样就可以用这个新加的原子 class 了：

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bda8233be614380b21024c8b9481663~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03ffad6493234519abc76b795db33a53~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

插件的方式或者 @layer 的方式都可以扩展。

### **tailwind 的 class 名和我已有的 class 冲突了咋办？**

比如我本来有个 border 的 class：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8849532b5b8d46c399fb8ce31f7a750c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

而 tailwind 也有，不就冲突了么？

这个可以通过加 

#### prefix

 解决：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/391a3bb491324a31a3fad76abcc560e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

不过这样所有的原子 class 都得加 prefix 了：

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/468ff84a39fd477980b1a46c1ae9ff0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a0a1ce212ce4a169fd50056a3ac326a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

知道了什么是原子 css 以及 tailwind 的用法之后，我们再来看看它的实现原理。

tailwind 可以单独跑，也可以作为 postcss 插件来跑。这是因为如果单独跑的话，它也会跑起 postcss，然后应用 tailwind 的插件：

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f5e082f60564af69b942d45e8ca605d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

所以说，**tailwind 本质上就是个 postcss 插件**。

## postcss 是一个 css 编译器，它是 parse、transform、generate 的流程。

在 astexplorer.net 可以看到 postcss 的 AST：

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0984ec9ef913416daa9efe3781201fe8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

而 postcss 就是通过 AST 来拿到 @tailwind、@layer、@apply 这些它扩展的指令，分别作相应的处理，也就是对 AST 的增删改查。

那它是怎么扫描到 js、html 中的 className 的呢？

这是因为它有个 **extractor** 的东西，用来通过**正则匹配文本中的 class**，之后添加到 AST 中，最终生成代码。

extractor 的功能看下测试用例就明白了：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfb065c57ed34f0e99899eb87275fafa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

所以说，

### **tailwind 就是基于 postcss 的 AST 实现的 css 代码生成工具，并且做了通过 extractor 提取 js、html 中 class 的功能。**

tailwind 还有种叫 JIT 的编译方式，这个原理也容易理解，本来是全部引入原子 css 然后过滤掉没有用到的，而 JIT 的话就是根据提取到的 class 来动态引入原子 css，更高效一点。

最后，为啥这个 css 框架叫 tailwind 呢？

因为作者喜欢叫做 kiteboarding 风筝冲浪的运动。

就是这样的，一个风筝，一个冲浪板：

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17c133b1b1d48b59bc3029886dbe944~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

这种运动在顺风 tailwind 和逆风 headwind 下有不同的技巧。而 tailwind 的时候明显更加省力。

所以就给这个 css 框架起名叫 tailwind 了。

确实，我也觉得用这种方式来写 css 更加省力、高效，不用写 class 名字了，代码更简洁了，还不容易样式冲突了。

## 总结

tailwind 是一个流行的原子化 css 框架。

传统 css 写法是定义 class，然后在 class 内部写样式，而原子化 css 是预定义一些细粒度 class，通过组合 class 的方式完成样式编写。

tailwind 用起来很简单：

所有预定义的 class 都可以通过配置文件修改值，也可以通过 aaa-[14px] 的方式定义任意值的 class。

所有 class 都可以通过 hover:xxx、md:xxx 的方式来添加某个状态下的样式，响应式的样式，相比传统的写法简洁太多了。

它的优点有很多，我个人最喜欢的就是不用起 class 的名字了，而且避免了同样的样式在多个 class 里定义多次导致代码重复，并且局部作用于某个标签，避免了全局污染。

它可以通过 @layer、@apply 或者插件的方式扩展原子 class，支持 prefix 来避免 class 名字冲突。

tailwind 本质上就是一个 postcss 插件，通过 AST 来分析 css 代码，对 css 做增删改，并且可以通过 extractor 提取 js、html 中的 class，之后基于这些来生成最终的 css 代码。

是否感受到了 tailwind 的简洁高效，易于扩展？就是这些原因让它成为了最流行的原子化 css 框架。

# Prisma

## 麻了,副本集模式

[MongoDB 复制(副本集) | 菜鸟教程 (runoob.com)](https://www.runoob.com/mongodb/mongodb-replication.html)
直接看这个教程即可,加入一行命令即可使用副本集模式启动,支持事务

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod --port 27017 --replSet rs0</span><br></pre></td></tr></table></figure>

` --replSet rs0`加入这一行命令即可

同时:一定要指定端口号:`--port 27017`不然也会发生报错.

## 基本介绍



ORM:`Object Relational Mapping`

>   有人说ORM是天使，也有人说ORM是噩梦

ORM全称是：Object Relational Mapping(对象关系映射)，其主要作用是在编程中，**把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录。**

也就是把SQL语句转化成对象的属性和方法操作

从代码上来看吧。拿Django的model来举例:

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User1</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">255</span>)</span><br></pre></td></tr></table></figure>

对应的数据库中可能就是一个表:user,里面有一个字段（我们假设不定义的自动不存在，包括主键），那就是name 类型是varchar(255)。

那么，如果我们有一个User的实例，比如:

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user = User1()</span><br><span class="line">user.name = <span class="string">&#x27;the5fire&#x27;</span></span><br><span class="line">user.save()   <span class="comment"># 存入数据库</span></span><br></pre></td></tr></table></figure>

那么对应着数据库中就有一条记录，name为the5fire。此时的user实例，对应的正是这个表的这一条记录。

用ORM的好处就是你不用操作表，可以在程序中用面向对象的思路，直接操作对象即可。比如上面那个代码，我要插入一条语句，直接user.save()即可。ORM会帮我们产生一条SQL语句。

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">INSERT INTO user1(name) VALUES(&quot;the5fire&quot;);</span><br></pre></td></tr></table></figure>

当然这只是从对象到SQL的映射，还有从SQL到对象的映射，也是类似的过程。我在之前那篇文章[Django分表的两个方案](https://link.zhihu.com/?target=https%3A//www.the5fire.com/django-sharding-model.html)中也有提及到，可以一并看看。

## 具体实现

这个Prisma就是数据表的抽象,抽象成面向对象

![image-20230701134703098](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230701134703098.png)

上面`model User就是对应数据库模型`

在`schema.prisma文件中存储model数据模型`

![image-20230701134903091](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230701134903091.png)

新建数据库图表,使用migrate这个库去执行一次变更

,--name,代表给这次变更命名一个名字

![image-20230701135522033](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230701135522033.png)

**创建好这个变更之后,就可以使用`npx prisma studio`**

![image-20230701140049937](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230701140049937.png)

这个命令,然后打开网页版本的数据库管理了

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Prisma Studio is up on http://localhost:<span class="number">5555</span></span><br><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│  Update available <span class="number">2.25</span>.<span class="number">0</span> -&gt; <span class="number">4.16</span>.<span class="number">2</span>             </span><br><span class="line">         │</span><br><span class="line">│  Run the following to update                   </span><br><span class="line">         │</span><br><span class="line">│    npm i <span class="literal">--save-dev</span> prisma                     </span><br><span class="line">         │</span><br><span class="line">│    npm i @prisma/client                        </span><br><span class="line">         │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

控制台::

![image-20230701140317829](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230701140317829.png)


### 插入后,在main函数里面查询和插入数据

不用写数据库查询语句

在具体的对应模型中,把之前定义的`model User`

看作一个编程世界的对象:

更新的时候使用`where关键字去确定一下`![image-20230701135046766](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230701135046766.png)

输出::

![image-20230701135257527](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230701135257527.png)

创建数据

![image-20230701141745821](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230701141745821.png)

先看看视频得了,后面连接MYsql 

### 添加Post模型

![image-20230702181557782](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702181557782.png)

上面的`author`关联的类型就是`User`,使用`@relation`,可以`关联数据类型`,

**这个references就是下面User里面描写的id**

在`author`**关联**`User`之后,还需要`User`去**关联**`author`

![image-20230702181733356](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702181733356.png)

数组标识符`[]`标识一个`User`对应多个`author`.在`Post`这个`Model`中,只能有一个user

第二次数据库变更`npx migrate`

![image-20230702182011636](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702182011636.png)

添加一个数据库模型表文件

在`更新数据`中,记得使用`where`去限定条件.

![image-20230702182115416](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702182115416.png)

prisma有自动类型体生成,也就是每次新建一个table,就能在代码里有自动补全提示

#### 新建数据的结果

![image-20230702182304503](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702182304503.png)

#### 将作者:auther连接到Post的文章里面.

![image-20230702182505552](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702182505552.png)

使用connect关键字连接到User那张表,然后绑定完成就是authorId是User数据表中存储的id

![image-20230702182604742](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702182604742.png)

因为此时的`fields`是{`authorId`},然后参考:`references`是`User`里面的`id`,也就实现绑定了

#### 查询用户的文章和id信息

![image-20230702182835155](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702182835155.png)

具体使用`include关键字`

限定查询的条件,`select,选择哪些信息是能被查询到的`

![image-20230702183009337](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702183009337.png)

#### 同时创建一个人和一个他的文章

![image-20230702183204175](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702183204175.png)

#### 查询到一部分符合条件的数据

`startsWith`,name是从`v`开头的数据,

具体含义:查询,条件:where,名字:name,以`v`开头的名字

![image-20230702183424116](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702183424116.png)

#### 分页查询

1.   skip是跳过几条数据

2.   take是取几条数据
3.   数据库一共5条数据
4.   ![image-20230702183718632](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702183718632.png)

搭建restFul-api

![image-20230702183856681](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702183856681.png)

createAt:@default(now()),也就是当前的时间戳

viewCount是文章的浏览量

### 创建数据库

![image-20230702184043751](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702184043751.png)

### 安装REST Client![image-20230702184331604](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702184331604.png)

这个插件以后,直接使用下面的`test.http`文件,就可以发送http请求了,**Send Request**.

可以指定`content-type`,然后再底下附带json数据就能发送请求了

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span>&#x27;LHG&#x27;<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span>&#x27;<span class="number">1320503154</span>@qq.com&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

使用`###`作为分隔符

![image-20230702184322512](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702184322512.png)

好用捏

![image-20230702185605680](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702185605680.png)

### 开发RESTFul服务器

#### 用户注册

![image-20230702185819108](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702185819108.png)

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> (req,res) =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name,email&#125; = req.<span class="property">body</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> prisma.<span class="property">user</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">          name,</span><br><span class="line">          email</span><br><span class="line">   		 &#125;)</span><br><span class="line">&#125;</span><br><span class="line">res.<span class="title function_">json</span>(result).<span class="comment">//也就是插入成功返回的插入结果</span></span><br></pre></td></tr></table></figure>

因为prisma会自动为数据表提供类型补全,所以开发时直接TAB就很快.

#### 新建文章

![image-20230702190157445](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702190157445.png)

#### 浏览量+1的功能.

![image-20230702190520067](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702190520067.png)

这里的`increment`是指的数据库的底层的自增操作.

防止在用户多的情况下,同一时间访问文章造成的抢占数据问题.

#### 更新下已经发布的文章

![image-20230702190745879](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702190745879.png)

#### 查询用户的草稿

就是`published==false`,查询单个用户,使用`findUnique`

此处的result.posts,就是User底下的posts文章,符合思维习惯,然后方便开发.

![image-20230702191057397](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702191057397.png)

#### 通过用户id查询文章

![image-20230702191543998](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702191543998.png)

此处`Number(id)`,主要是因为`req.params`的`id`传过来是`string类型`

然后查询的时候必须是`int,类型,和定义的时候一样即可`,

最后使用`res.json` **发送json数据格式响应**

#### 获取所有已经发布的文章

![image-20230702191826496](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702191826496.png)



### 开发Graphql服务器

#### 已经注入进去了content在prisma里面了

![image-20230702193603769](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702193603769.png)

相当于类型声明

#### 在graphql风格的服务器中查询::

![image-20230702194048923](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702194048923.png)

#### 查询Post文章byid

![image-20230702194220735](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702194220735.png)

基本就是`context是返回的响应`,然后`args就相当于前端给的参数了`

直接条件:`where`查询即可

#### 查询所有文章

![image-20230702194426339](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702194426339.png)

直接读英语即可

![image-20230702194520860](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702194520860.png)

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">skip</span>:<span class="title class_">Number</span>(args.<span class="property">skip</span>) || <span class="literal">undefined</span>&#125;<span class="comment">//如果没有使用undefined代替</span></span><br></pre></td></tr></table></figure>

#### 查询一个用户所有的草稿.

逻辑就是先查询到用户:`User`,然后查询用户下面的`草稿:post`

![image-20230702194802237](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702194802237.png)

published:false

#### 创建用户和创建草稿

![image-20230702194937138](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702194937138.png)

author就要连接到email:args.authorEmail.

#### 删除发布的内容:

![image-20230702195156227](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702195156227.png)

让其自增得这样嵌套着来写:

![image-20230702195238001](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702195238001.png)

#### 根据用户查询文章和根据文章查询用户

![image-20230702195440105](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702195440105.png)

#### 图查询:

![image-20230702195548808](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702195548808.png)

![image-20230702195718646](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702195718646.png)

##### mutation语句

![image-20230702195812057](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702195812057.png)

在整个查询对象的前面添加`mutation`即可

![image-20230702195916032](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702195916032.png)

  ### 在VUE中GraphqL查询数据

#### 安装依赖

![image-20230702204109921](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702204109921.png)

![image-20230702203948851](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702203948851.png)



![image-20230702204042517](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230702204042517.png)



# 数据库MYSQL

先上目录:

![image-20230628161043854](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628161043854.png)

## 数据库基本概念

### 什么是数据库

![image-20230628161323751](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628161323751.png)

### 数据库类型的对比

关系型数据库（Relational Database）是一种基于关系模型的数据库，它通过表（Table）来组织和存储数据。在关系型数据库中，数据以二维表的形式表示，表由行（Row）和列（Column）组成，每一行代表一个记录，每一列代表一个属性。关系型数据库使用结构化查询语言（Structured Query Language，简称SQL）来进行数据的管理和操作。

与关系型数据库不同，MongoDB是一种NoSQL（Not Only SQL）数据库，它主要使用文档（Document）来组织和存储数据。MongoDB以文档的形式存储数据，文档可以是结构化的、非结构化的或者半结构化的。文档以类似于JSON的BSON格式（Binary JSON）存储，BSON是一种二进制编码的序列化格式，能够有效地表示复杂的数据结构。

以下是关系型数据库和MongoDB之间的一些主要区别：

1.  数据模型：关系型数据库使用表和行的结构来组织和存储数据，而MongoDB使用文档的结构。文档可以是更灵活和动态的，不需要事先定义固定的表结构。
2.  Schema（模式）：关系型数据库需要定义表的结构和字段的类型，以及字段之间的关系。而MongoDB可以更加灵活，不强制要求文档具有相同的结构。
3.  扩展性：关系型数据库在水平扩展（Scale-Out，通过增加服务器来提高性能）方面相对困难，通常只能进行垂直扩展（Scale-Up，通过升级硬件来提高性能）。而MongoDB在水平扩展方面更加简单，可以通过添加更多的服务器来提高性能和存储容量。
4.  查询语言：关系型数据库使用SQL作为查询语言，而MongoDB使用基于文档的查询语言。
5.  ACID属性：关系型数据库通常保证ACID属性（原子性、一致性、隔离性和持久性），而MongoDB在默认配置下是弱一致性的，支持更高的可伸缩性。

选择关系型数据库还是MongoDB取决于具体的应用需求。关系型数据库适合于结构化数据和需要事务支持的应用，而MongoDB适合于需要灵活数据模型和大规模数据存储的场景。

### 常见的数据库

![image-20230628161709717](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628161709717.png)

![image-20230628161732485](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628161732485.png)

### 数据库的数据组织结构

![image-20230628161854532](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628161854532.png)

`数据组织`也**就是让一团乱麻的数据,变得井然有序**

#### 类似于Excel

![image-20230628162038759](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628162038759.png)

`工作溥`也就是一个**Excel程序**,然后`工作表`就是底部的**user和books**

![image-20230628162127981](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628162127981.png)

页签,也就是`工作表`,存储的数据都是固定的

**数据行**![image-20230628162402067](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628162402067.png)

**列**![image-20230628162414580](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628162414580.png)![image-20230628162443637](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628162443637.png)

而且还有`数据类型`,上述的编号里面都是数字:`Number`,密码都是字符串`String`

##### 总结

![image-20230628162344670](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628162344670.png)

#### 传统数据库的数据组织结构

![image-20230628162817057](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628162817057.png)

和Excel对比理解即可,`字段`就是**一列列**的,组成**数据行:`raw`**和数据表,就是工作表

#### 实际开发,dataBase和Table和raw和field:字段的关系

![image-20230628163114844](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628163114844.png)

**结合上面的Excel理解**

## Mysql workBench

### 安装的软件



![image-20230628163319632](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628163319632.png)

安装教程:[安装《MySql8.0保姆级》 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv18753383?spm_id_from=333.999.0.0)

### 连接数据库

![image-20230628170948156](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628170948156.png)



![image-20230628171517908](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628171517908.png)

从Ad管理界面切换到

**Schemas这个界面,才显示的是数据表的内容**

### 创建数据库

#### 设计表的字段

![image-20230628173817036](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628173817036.png)

![image-20230628173843829](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628173843829.png)

如图所示,**设计表的字段就是**

设计这个`column Name`的位置

![image-20230628173915155](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628173915155.png)

设计后端的ID![image-20230628173948335](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628173948335.png)

![image-20230628174009626](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628174009626.png)

**需要加入ID这样的字段**,也就是`Column:**列**`

主要是看**DataType**

![image-20230628174328978](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628174328978.png)

**varchar(`len`)**里面的**len代表字符串的最大长度**

#### 设计完成

![image-20230628174755545](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628174755545.png)

#### 设计字段的特殊标识

![image-20230628174953453](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628174953453.png)

**也就是这些复选框**

![image-20230628175002208](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628175002208.png)

![image-20230628175128128](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628175128128.png)

`具体含义`

![image-20230628175142582](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628175142582.png)

软件是有说明的

![image-20230628175346260](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628175346260.png)

`Unsigned`也就是无符号数,翻译成人话就是**无正负的数字**

![image-20230628175735760](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628175735760.png)

创建表点击右下角的`APPLY`

脚本输出::

![image-20230628175857306](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628175857306.png)

创建成功::

![image-20230628175952213](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628175952213.png)

![image-20230628175946469](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628175946469.png)

看底下的Information状态框

#### 插入数据

![image-20230628180227430](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628180227430.png)

插入数据的选项

![image-20230628180322376](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628180322376.png)

出现如图

![image-20230628180333766](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628180333766.png)

**鼠标点上去直接写就行**

![image-20230628180519856](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628180519856.png)

然后点击`APPLY应用`即可

## 使用SQL管理数据库

### 什么是SQL?

![image-20230628182109937](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628182109937.png)

### SQL能干啥?

![image-20230628182205524](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628182205524.png)

### 学习目标

![image-20230628182248306](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628182248306.png)

### 基本使用

#### SELECE语句

![image-20230628182733763](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628182733763.png)

`*`就是通配符的意思,代表`all`

![image-20230628182649738](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628182649738.png)

单独查询一列

![image-20230628182718232](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628182718232.png)

##### 全选择



![image-20230628183113728](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628183113728.png)

如图,看到`Result Grid了嘛`,这就是结果集

##### 部分选择

![image-20230628183412178](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628183412178.png)

![image-20230628183440880](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628183440880.png)

分号代表语句的结束

![image-20230628183631114](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628183631114.png)

**点击此按钮执行语句**

![image-20230628183648316](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628183648316.png)

#### INSERT语句

![image-20230628183802291](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628183802291.png)

##### 具体实例

![image-20230628183829733](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628183829733.png)

#### UPDATE语句

![image-20230628185245579](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628185245579.png)

##### 具体操作

###### 更新一列

![image-20230628185459755](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628185459755.png)

###### 更新多列

![image-20230628190149252](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628190149252.png)

如图

![image-20230628190705443](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628190705443.png)

#### DELETE语句

![image-20230628190916986](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628190916986.png)

##### 实例

![image-20230628191008610](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628191008610.png)

,**不要忘记提供where条件!!!!!!!**,不然删除整张表的数据

#### 总结

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 经典-- 双减号+空格写注释</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users;</span><br><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users;</span><br><span class="line"><span class="comment">-- into别写错成info</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users (username,password) <span class="keyword">values</span> (<span class="string">&#x27;TFBOYS&#x27;</span>,<span class="string">&#x27;114514捏&#x27;</span>);</span><br><span class="line"><span class="comment">-- 把 id 为 4 的用户,密码更新成为888888</span></span><br><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27;888888&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27;我们是三小只&#x27;</span>,status<span class="operator">=</span><span class="number">1</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">教程代码</span><br></pre></td></tr></table></figure>

### SQL的Where子句

![image-20230628191812680](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628191812680.png)

#### 主句

![image-20230628191715810](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628191715810.png)

就是前面的可以被实际执行的语句,可以脱离where执行

#### 运算符

![image-20230628191845501](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628191845501.png)

#### 实例

![image-20230628191940201](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628191940201.png)

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> status<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="operator">!=</span> <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line"><span class="keyword">where</span>表示在哪?,也就是条件罢了</span><br></pre></td></tr></table></figure>

### and和or语句

#### 语法

![image-20230628195343534](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628195343534.png)

#### 实例

![image-20230628195409912](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628195409912.png)

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用and</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> status<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> id<span class="operator">&lt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

![image-20230628195631206](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628195631206.png)

![image-20230628195707565](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628195707565.png)

### order BY语句

![image-20230628195842816](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628195842816.png)



`升序`:**也就是从小到大的顺序排序**

使用`DESC关键字降序排序`,也就是**从大到小**

#### 实例

#### 升序排序ASC

![image-20230628200017233](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628200017233.png)

#### 降序排序DESC

![image-20230628200256722](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628200256722.png)

![image-20230628200356804](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628200356804.png)

#### 多重排序,写多个指令即可

![image-20230628200742896](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628200742896.png)

签名前面的指令先执行,然后后面的执行.先后顺序

![image-20230628201537265](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628201537265.png)

### COUNT(*)函数

语法

![image-20230628201731943](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628201731943.png)

也就是**-- 使用count(*)去统计users表里面,状态=0的用户的总数目.**

实例

![image-20230628201810043](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628201810043.png)

![image-20230628201913264](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628201913264.png)

### 设置别名

![image-20230628202253470](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628202253470.png)

![image-20230628202412000](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628202412000.png)

### 总结

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 经典-- 双减号+空格写注释</span></span><br><span class="line"><span class="comment">-- 查询语句SELECT</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> status<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username <span class="operator">!=</span> <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line"><span class="comment">-- 使用and</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> status<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> id<span class="operator">&lt;=</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> status<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> username <span class="operator">=</span> <span class="string">&#x27;王源&#x27;</span>;</span><br><span class="line"><span class="comment">-- 排序语句,从小到大排序,默认asc,也就是从小到大</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> status <span class="keyword">asc</span>;</span><br><span class="line"><span class="comment">-- desc,从大到小</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 多重排序,写多个指令即可</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span>,status <span class="keyword">desc</span>;</span><br><span class="line"><span class="keyword">select</span> username,password <span class="keyword">from</span> users;</span><br><span class="line"><span class="comment">-- into别写错成info</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users (username,password) <span class="keyword">values</span> (<span class="string">&#x27;TFBOYS&#x27;</span>,<span class="string">&#x27;114514捏&#x27;</span>);</span><br><span class="line"><span class="comment">-- 把 id 为 4 的用户,密码更新成为888888</span></span><br><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27;888888&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27;我们是三小只&#x27;</span>,status<span class="operator">=</span><span class="number">1</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 删除id为4的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 使用count(*)去统计users表里面,状态=0的用户的总数目.</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> users <span class="keyword">where</span> status <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 起别名AS</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> <span class="string">&#x27;total&#x27;</span> <span class="keyword">from</span> users <span class="keyword">where</span> status <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

## NODEJS操作Mysql

### mysql模块

![image-20230628203855959](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628203855959.png)

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i mysql</span><br></pre></td></tr></table></figure>

**安装第三方操作数据库的模块**

#### 配置

![image-20230628203952920](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628203952920.png)

#### 测试

![image-20230628205532660](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628205532660.png)



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> db = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">	<span class="attr">host</span>: <span class="string">&quot;127.0.0.1&quot;</span>, <span class="comment">//数据库的IP地址</span></span><br><span class="line">	<span class="attr">user</span>: <span class="string">&quot;root&quot;</span>, <span class="comment">//登录数据库的账号</span></span><br><span class="line">	<span class="attr">password</span>: <span class="string">&quot;yours password&quot;</span>, <span class="comment">//登录数据库的密码</span></span><br><span class="line">	<span class="attr">database</span>: <span class="string">&quot;lhg_database&quot;</span>, <span class="comment">//指定要操作哪个数据库</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//检测是否连接成功</span></span><br><span class="line">db.<span class="title function_">query</span>(<span class="string">&quot;SELECT 1&quot;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (err) <span class="keyword">throw</span> err.<span class="property">message</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

输出结果::

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">PS</span> <span class="attr">F</span>:\<span class="title class_">WebDeveLoper</span>\<span class="title class_">Learn</span> <span class="title class_">MySql</span>\<span class="title class_">NodeJS</span>&gt; node <span class="string">&quot;f:\WebDeveLoper\Learn MySql\NodeJS\使用node操作sql文件.js&quot;</span></span><br><span class="line">[ <span class="title class_">RowDataPacket</span> &#123; <span class="attr">sum</span>: <span class="number">2</span> &#125; ]</span><br><span class="line"><span class="variable constant_">PS</span> <span class="attr">F</span>:\<span class="title class_">WebDeveLoper</span>\<span class="title class_">Learn</span> <span class="title class_">MySql</span>\<span class="title class_">NodeJS</span>&gt; node <span class="string">&quot;f:\WebDeveLoper\Learn MySql\NodeJS\使用node操作sql文件.js&quot;</span></span><br><span class="line">[ <span class="title class_">RowDataPacket</span> &#123; <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span> &#125; ]</span><br></pre></td></tr></table></figure>

#### 查询table的数据

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&quot;SELECT * FROM users&quot;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (err) <span class="keyword">throw</span> err.<span class="property">message</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回的数据</span></span><br><span class="line"><span class="punctuation">[</span></span><br><span class="line">  RowDataPacket <span class="punctuation">&#123;</span></span><br><span class="line">    id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    username<span class="punctuation">:</span> &#x27;理塘丁真&#x27;<span class="punctuation">,</span></span><br><span class="line">    password<span class="punctuation">:</span> &#x27;<span class="number">114514</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">    status<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  RowDataPacket <span class="punctuation">&#123;</span></span><br><span class="line">    id<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    username<span class="punctuation">:</span> &#x27;王源&#x27;<span class="punctuation">,</span></span><br><span class="line">    password<span class="punctuation">:</span> &#x27;<span class="number">52</span>chouyan&#x27;<span class="punctuation">,</span></span><br><span class="line">    status<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  RowDataPacket <span class="punctuation">&#123;</span></span><br><span class="line">    id<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    username<span class="punctuation">:</span> &#x27;王俊凯&#x27;<span class="punctuation">,</span></span><br><span class="line">    password<span class="punctuation">:</span> &#x27;<span class="number">52</span>wangyuan&#x27;<span class="punctuation">,</span></span><br><span class="line">    status<span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  RowDataPacket <span class="punctuation">&#123;</span></span><br><span class="line">    id<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    username<span class="punctuation">:</span> &#x27;TFBOYS&#x27;<span class="punctuation">,</span></span><br><span class="line">    password<span class="punctuation">:</span> &#x27;我们是三小只&#x27;<span class="punctuation">,</span></span><br><span class="line">    status<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

#### 插入数据

![image-20230628211006195](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628211006195.png)

![image-20230628211905519](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628211905519.png)

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出结果:</span></span><br><span class="line"><span class="title class_">OkPacket</span> &#123;</span><br><span class="line">  <span class="attr">fieldCount</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">affectedRows</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">insertId</span>: <span class="number">7</span>,</span><br><span class="line">  <span class="attr">serverStatus</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">warningCount</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">protocol41</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">changedRows</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//affectedRows: 1,检验是否插入成功的属性</span></span><br></pre></td></tr></table></figure>

占位符和中间件

![image-20230628212450133](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628212450133.png)

使用第二个参数,传入数组,然后在?处替换字符串

回调函数::

![image-20230628212537811](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628212537811.png)

此处出现`id`跳跃的原因是

![image-20230628212720180](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628212720180.png)

**id具有`唯一性`,之前`删除的数据的id还是唯一的`,即使自增,也是不可以继续一样的id**

True reason:

![image-20230628212844816](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628212844816.png)

![image-20230628213242158](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628213242158.png)

简便形式

![image-20230628213435618](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20230628213435618.png)

就是新增的时候,

扩展运算符展开user这个对象,

然后和解构赋值一样,直接将属性对应列名,

然后值直接插入即可

# ServerLess

无服务器模式

无服务器模式存储就是对象存储,实体服务器支撑,

开发者不需要使用服务器这种硬件设施

关注和访问的人越来越多?

访问流量是不可控的,服务器本身也需要各种维护,开发者只需要写更好的代码,按需付费,服务高可用的

服务器

## 对象存储

![image-20231126124938996](https://s2.loli.net/2023/11/26/3kfrDqSJRA9COK6.png)

将所有文件存储到bucket存储桶中,然后通过对象id访问数据.

而对象存储也要维护一个账本,里面存储者id和实际硬盘位置的对应,就是通过id访问数据

\![image-20231126125208487](C:\Users\13205\AppData\Roaming\Typora\typora-user-images\image-20231126125208487.png)![image-20231126125208487](https://s2.loli.net/2023/11/26/KFA16eiCdRZwtcs.png)

### 非结构化数据

![image-20231126125843023](https://s2.loli.net/2023/11/26/sExyROl4ZMJwezv.png)

为什么图片,pdf,视频叫做非结构化数据?

因为它们在存储和处理过程中缺乏明确的结构和组织形式。

相对于结构化数据，如关系数据库中的表格和字段，非结构化数据并不遵循特定的数据模型或预定义的结构。

![image-20231126125533166](https://s2.loli.net/2023/11/26/LYcKETS7v31rAdo.png)

在非结构化数据中，这些数据通常以二进制格式存储，没有明确的规范定义如何组织和解释这些数据。

![image-20231126125547363](https://s2.loli.net/2023/11/26/NtyYTMDZngHrsh8.png)

图片、PDF和视频等非结构化数据通常包含多媒体元素，如像素值、音频信号、视频帧等。它们可能包含不同类型的信息，例如图像中的颜色、形状，文本或图形，视频中的连续图像帧和音频流等。这些数据以自由形式存在，其结构和语义常常需要人工理解和处理。

![image-20231126125609606](https://s2.loli.net/2023/11/26/BcZPGSmFDdRNVHU.png)

![image-20231126125731302](https://s2.loli.net/2023/11/26/hdQDLisw7oMx1NE.png)

[三大企业级存储类型01- SAN存储_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV12T41197if/?spm_id_from=333.999.0.0&vd_source=dc4491d23247de9bc4628ca7a93eb3ad)

[网站前端部署最佳实践-对象存储加CDN实现低成本支撑大规模用户_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Jg4y1F7kb/?spm_id_from=333.337.search-card.all.click&vd_source=dc4491d23247de9bc4628ca7a93eb3ad)

[【先锋科普】BT下载|P2P原理介绍_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ef4y1N7LF/?spm_id_from=333.337.search-card.all.click&vd_source=dc4491d23247de9bc4628ca7a93eb3ad)

P2P下载原理:

​	BT下载,比特流是?

**专业名词就是傻逼**

P2P指的是**对等计算机网络**,一台计算器既充当网络服务的请求者,又能利用剩余算力充当服务器提供资源和服务.

下载文件之后,开机就相当于一个服务器,当别人下载磁力链接的时候,就从你的电脑可以获取数据,这就是P2P

![image-20231126132401094](https://s2.loli.net/2023/11/26/kdc6CDwJlob3geS.png)

越多人上传,越多人充当服务器,下载的速度也越快

**文件互传**,由服务器提供文件到电脑

-   牙签现象:当一根牙签竖立在桌上时，很容易倒下。但是，如果将多根牙签以并列的方式放在一起，那么它们会相互支撑，变得更加稳定，不容易倒下。类似地，人际关系和社交网络中的个体也能相互影响和支持。

1.   如果我们将牙签现象应用于服务器的 C/S（Client/Server）架构，可以理解为服务器端的稳定性和可扩展性受到客户端的影响。

2.   在这种情况下，服务器充当支撑牙签的角色，而客户端则是牙签。服务器需要能够稳定地承受来自多个客户端的请求和负载，类似于多根牙签并列放置，相互支持以增强稳定性。

3.   然而，当客户端数量增加时，服务器的负载也会增加，可能导致服务器性能下降或崩溃。这就好像多根牙签中新增了一根导致其他牙签无法支撑而倒下。

4.   为了解决这个问题，服务器需要具备良好的扩展性，即能够动态地添加更多的服务器节点来应对不断增长的客户端请求。这样就可以保持服务器的稳定性，类似于通过添加额外的牙签来保持整个结构的稳定性。

5.   牙签现象在服务器的 C/S 架构中提醒我们，服务器的设计和架构需要考虑负载均衡、扩展性和吞吐量等因素，以确保能够有效处理大量客户端请求，并为用户提供稳定和可靠的服务。

]]></content>
  </entry>
</search>
